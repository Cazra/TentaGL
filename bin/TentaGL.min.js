/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * This script makes gl context constants globally available. 
 * Each of these constants has the prefix "GL_". The reason for this is twofold:
 * To avoid collisions with other global names, and because all the constants
 * in traditional OpenGL have the prefix "GL_". 
 */


//////// ClearBufferMask

GL_DEPTH_BUFFER_BIT = 0x00000100;
GL_STENCIL_BUFFER_BIT = 0x00000400;
GL_COLOR_BUFFER_BIT = 0x00004000;
 
 
//////// BeginMode
 
GL_POINTS = 0x0000;
GL_LINES = 0x0001;
GL_LINE_LOOP = 0x0002;
GL_LINE_STRIP = 0x0003;
GL_TRIANGLES = 0x0004;
GL_TRIANGLE_STRIP = 0x0005;
GL_TRIANGLE_FAN = 0x0006;
 
 
//////// Blending
 
GL_ZERO = 0;
GL_ONE = 1;
GL_SRC_COLOR = 0x0300;
GL_ONE_MINUS_SRC_COLOR = 0x0301;
GL_SRC_ALPHA = 0x0302;
GL_ONE_MINUS_SRC_ALPHA = 0x0303;
GL_DST_ALPHA = 0x0304;
GL_ONE_MINUS_DST_ALPHA = 0x0305;
GL_DST_COLOR = 0x0306;
GL_ONE_MINUS_DST_COLOR = 0x0307;
GL_SRC_ALPHA_SATURATE = 0x0308;

GL_FUNC_ADD = 0x8006;
GL_BLEND_EQUATION = 0x8009;
GL_BLEND_EQUATION_RGB = 0x8009;
GL_BLEND_EQUATION_ALHPA = 0x883D;

GL_FUNC_SUBTRACT = 0x800A;
GL_FUNC_REVERSE_SUBTRACT = 0x800B;

GL_BLEND_DST_RGB = 0x80C8;
GL_BLEND_SRC_RGB = 0x80C9;
GL_BLEND_DST_ALPHA = 0x80CA;
GL_BLEND_SRC_ALPHA = 0x80CB;
GL_CONSTANT_COLOR = 0x8001;
GL_ONE_MINUS_CONSTANT_COLOR = 0x8002;
GL_CONSTANT_ALPHA = 0x8003;
GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004;
GL_BLEND_COLOR = 0x8005;


//////// Buffers

GL_ARRAY_BUFFER = 0x8892;
GL_ELEMENT_ARRAY_BUFFER = 0x8893;
GL_ARRAY_BUFFER_BINDING = 0x8894;
GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

GL_STREAM_DRAW = 0x88E0;
GL_STATIC_DRAW = 0x88E4;
GL_DYNAMIC_DRAW = 0x88E8;

GL_BUFFER_SIZE = 0x8764;
GL_BUFFER_USAGE = 0x8765;

GL_CURRENT_VERTEX_ATTRIB = 0x8626;


//////// CullFaceMode

GL_FRONT = 0x0404;
GL_BACK = 0x0405;
GL_FRONT_AND_BACK = 0x0408;


//////// EnableCap

GL_CULL_FACE = 0x0B44;
GL_BLEND = 0x0BE2;
GL_DITHER = 0x0BD0;
GL_STENCIL_TEST = 0x0B90;
GL_DEPTH_TEST = 0x0B71;
GL_SCISSOR_TEST = 0x0C11;
GL_POLYGON_OFFSET_FILL = 0x8037;
GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
GL_SAMPLE_COVERAGE = 0x80A0;


//////// ErrorCode

GL_NO_ERROR = 0;
GL_INVALID_ENUM = 0x0500;
GL_INVALID_VALUE = 0x0501;
GL_INVALID_OPERATION = 0x0502;
GL_OUT_OF_MEMORY = 0x0505;


//////// FrontFaceDirection

GL_CW = 0x0900;
GL_CCW = 0x0901;


//////// GetPName

GL_LINE_WIDTH = 0x0B21;

GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;

GL_CULL_FACE_MODE = 0x0B45;
GL_FRONT_FACE = 0x0B46;

GL_DEPTH_RANGE = 0x0B70;
GL_DEPTH_WRITEMASK = 0x0B72;
GL_DEPTH_CLEAR_VALUE = 0x0B73;
GL_DEPTH_FUNC = 0x0B74;

GL_STENCIL_CLEAR_VALUE = 0x0B91;
GL_STENCIL_FUNC = 0x0B92;
GL_STENCIL_FAIL = 0x0B94;
GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95;
GL_STENCIL_PASS_DEPTH_PASS = 0x0B96;
GL_STENCIL_REF = 0x0B97;
GL_STENCIL_VALUE_MASK = 0x0B93;
GL_STENCIL_WRITEMASK = 0x0B98;
GL_STENCIL_BACK_FUNC = 0x8800;
GL_STENCIL_BACK_FAIL = 0x8801;
GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
GL_STENCIL_REF = 0x8CA3;
GL_STENCIL_BACK_VALUE_MASK = 0x8CA4;
GL_STENCIL_BACK_WRITEMASK = 0x8CA5;

GL_VIEWPORT = 0x0BA2;
GL_SCISSOR_BOX = 0x0C10;

GL_COLOR_CLEAR_VALUE = 0x0C22;
GL_COLOR_WRITEMASK = 0x0C23;

GL_UNPACK_ALIGNMENT = 0x0CF5;
GL_PACK_ALIGNMENT = 0x0D05;

GL_MAX_TEXTURE_SIZE = 0x0D33;
GL_MAX_VIEWPORT_DIMS = 0x0D3A;

GL_SUBPIXEL_BITS = 0x0D50;
GL_RED_BITS = 0x0D52;
GL_GREEN_BITS = 0x0D53;
GL_BLUE_BITS = 0x0D54;
GL_ALPHA_BITS = 0x0D55;
GL_DEPTH_BITS = 0x0D56;
GL_STENCIL_BITS = 0x0D57;

GL_POLYGON_OFFSET_UNITS = 0x2A00;
GL_POLYGON_OFFSET_FACTOR = 0x8038;

GL_TEXTURE_BINDING_2D = 0x8069;

GL_SAMPLE_BUFFERS = 0x80A8;
GL_SAMPLES = 0x80A9;
GL_SAMPLE_COVERAGE_VALUE = 0x80AA;
GL_SAMPLE_COVERAGE_INVERT = 0x80AB;

GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;


//////// Hints

GL_DONT_CARE = 0x1100;
GL_FASTEST = 0x1101;
GL_NICEST = 0x1102;
GL_GENERATE_MIPMAP_HINT = 0x8192;


//////// DataType

GL_BYTE = 0x1400;
GL_UNSIGNED_BYTE = 0x1401;

GL_SHORT = 0x1402;
GL_UNSIGNED_SHORT = 0x1403;

GL_INT = 0x1404;
GL_UNSIGNED_INT = 0x1405;

GL_FLOAT = 0x1406;
GL_FLOAT_VEC2 = 0x8B50;
GL_FLOAT_VEC3 = 0x8B51;
GL_FLOAT_VEC4 = 0x8B52;

GL_INT_VEC2 = 0x8B53;
GL_INT_VEC3 = 0x8B54;
GL_INT_VEC4 = 0x8B55;

GL_BOOL = 0x8B56;
GL_BOOL_VEC2 = 0x8B57;
GL_BOOL_VEC3 = 0x8B58;
GL_BOOL_VEC4 = 0x8B59;

GL_FLOAT_MAT2 = 0x8B5A;
GL_FLOAT_MAT3 = 0x8B5B;
GL_FLOAT_MAT4 = 0x8B5C;

GL_SAMPLER_2D = 0x8B5E;
GL_SAMPLER_CUBE = 0x8B60;


//////// PixelFormat

GL_DEPTH_COMPONENT = 0x1902;
GL_ALPHA = 0x1906;
GL_RGB = 0x1907;
GL_RGBA = 0x1908;
GL_LUMINANCE = 0x1909;
GL_LUMINANCE_ALPHA = 0x190A;

GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
GL_UNSIGNED_SHORT_5_6_5 = 0x8363;


//////// Shaders

GL_FRAGMENT_SHADER = 0x8B30;
GL_VERTEX_SHADER = 0x8B31;

GL_MAX_VERTEX_ATTRIBS = 0x8869;
GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
GL_MAX_VARYING_VECTORS = 0x8DFC;
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

GL_SHADER_TYPE = 0x8B4F;
GL_DELETE_STATUS = 0x8B80;
GL_LINK_STATUS = 0x8B82;
GL_VALIDATE_STATUS = 0x8B83;

GL_ATTACHED_SHADERS = 0x8B85;
GL_ACTIVE_UNIFORMS = 0x8B86;
GL_ACTIVE_ATTRIBUTES = 0x8B89;
GL_SHADING_LANGUAGE_VERSION = 0x8B8C;
GL_CURRENT_PROGRAM = 0x8B8D;


//////// StencilFunction

GL_NEVER = 0x0200;
GL_LESS = 0x0201;
GL_EQUAL = 0x0202;
GL_LEQUAL = 0x0203;
GL_GREATER = 0x0204;
GL_NOTEQUAL = 0x0205;
GL_GEQUAL = 0x0206;
GL_ALWAYS = 0x0207;


//////// StencilOp

GL_KEEP = 0x1E00;
GL_REPLACE = 0x1E01;
GL_INCR = 0x1E02;
GL_DECR = 0x1E03;
GL_INVERT = 0x150A;
GL_INCR_WRAP = 0x8507;
GL_DECR_WRAP = 0x8508;


//////// StringName

GL_VENDOR = 0x1F00;
GL_RENDERER = 0x1F01;
GL_VERSION = 0x1F02;


//////// Textures

GL_NEAREST = 0x2600;
GL_LINEAR = 0x2601;
GL_NEAREST_MIPMAP_NEAREST = 0x2700;
GL_LINEAR_MIPMAP_NEAREST = 0x2701;
GL_NEAREST_MIPMAP_LINEAR = 0x2702;
GL_LINEAR_MIPMAP_LINEAR = 0x2703;

GL_TEXTURE_MAG_FILTER = 0x2800;
GL_TEXTURE_MIN_FILTER = 0x2801;
GL_TEXTURE_WRAP_S = 0x2802;
GL_TEXTURE_WRAP_T = 0x2803;

GL_TEXTURE_2D = 0x0DE1;
GL_TEXTURE = 0x1702;

GL_TEXTURE_CUBE_MAP = 0x8513;
GL_TEXTURE_BINDING_CUBE_MAP = 0x8514;
GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

GL_TEXTURE0 = 0x84C0;
GL_TEXTURE1 = 0x84C1;
GL_TEXTURE2 = 0x84C2;
GL_TEXTURE3 = 0x84C3;
GL_TEXTURE4 = 0x84C4;
GL_TEXTURE5 = 0x84C5;
GL_TEXTURE6 = 0x84C6;
GL_TEXTURE7 = 0x84C7;
GL_TEXTURE8 = 0x84C8;
GL_TEXTURE9 = 0x84C9;
GL_TEXTURE10 = 0x84CA;
GL_TEXTURE11 = 0x84CB;
GL_TEXTURE12 = 0x84CC;
GL_TEXTURE13 = 0x84CD;
GL_TEXTURE14 = 0x84CE;
GL_TEXTURE15 = 0x84CF;
GL_TEXTURE16 = 0x84D0;
GL_TEXTURE17 = 0x84D1;
GL_TEXTURE18 = 0x84D2;
GL_TEXTURE19 = 0x84D3;
GL_TEXTURE20 = 0x84D4;
GL_TEXTURE21 = 0x84D5;
GL_TEXTURE22 = 0x84D6;
GL_TEXTURE23 = 0x84D7;
GL_TEXTURE24 = 0x84D8;
GL_TEXTURE25 = 0x84D9;
GL_TEXTURE26 = 0x84DA;
GL_TEXTURE27 = 0x84DB;
GL_TEXTURE28 = 0x84DC;
GL_TEXTURE29 = 0x84DD;
GL_TEXTURE30 = 0x84DE;
GL_TEXTURE31 = 0x84DF;
GL_ACTIVE_TEXTURE = 0x84E0;

GL_REPEAT = 0x2901;
GL_CLAMP_TO_EDGE = 0x812F;
GL_MIRRORED_REPEAT = 0x8370;


//////// Vertex Arrays

GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;


//////// Read Format

GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;


//////// Shader source

GL_COMPILE_STATUS = 0x8B81;


//////// Shader Precision-specified types

GL_LOW_FLOAT = 0x8DF0;
GL_MEDIUM_FLOAT = 0x8DF1;
GL_HIGH_FLOAT = 0x8DF2;
GL_LOW_INT = 0x8DF3;
GL_MEDIUM_INT = 0x8DF4;
GL_HIGH_INT = 0x8DF5;


//////// Framebuffer

GL_FRAMEBUFFER = 0x8D40;
GL_RENDERBUFFER = 0x8D41;

GL_RGBA4 = 0x8056;
GL_RGB5_1 = 0x8057;
GL_RGB565 = 0x8D62;
GL_DEPTH_COMPONENT16 = 0x81A5;
GL_STENCIL_INDEX = 0x1901;
GL_STENCIL_INDEX8 = 0x8D48;
GL_DEPTH_STENCIL = 0x84F9;

GL_RENDERBUFFER_WIDTH = 0x8D42;
GL_RENDERBUFFER_HEIGHT = 0x8D43;
GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
GL_RENDERBUFFER_RED_SIZE = 0x8D50;
GL_RENDERBUFFER_GREEN_SIZE = 0x8D51;
GL_RENDERBUFFER_BLUE_SIZE = 0x8D52;
GL_RENDERBUFFER_ALPHA_SIZE = 0x8D53;
GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54;
GL_RENDERBUFFER_STENCIL_SIZE = 0x8D55;

GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

GL_COLOR_ATTACHMENT0 = 0x8CE0;
GL_DEPTH_ATTACHMENT = 0x8D00;
GL_STENCIL_ATTACHMENT = 0x8D20;
GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

GL_NONE = 0;

GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

GL_FRAMEBUFFER_BINDING = 0x8CA6;
GL_RENDERBUFFER_BINDING = 0x8CA7;
GL_MAX_RENDERBUFFER_SIZE = 0x84E8;

GL_INVALID_FRAMEBUFFER_OPERATION = 0x0506;


//////// WebGL-specific enums

GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
GL_CONTEXT_LOST_WEBGL = 0x9242;
GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
GL_BROWSER_DEFAULT_WEBGL = 0x9244;

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


 /** 
  * The TentaGL namespace.
  * It also has some utilities for getting metadata about GL data types.
  *
  * Dependencies:
  * The only library dependancy TentaGL has is the glMatrix 2.0 library, used 
  * for doing vector and matrix math in typed arrays. A minimized js file of the
  * library is included with the examples, but is not guaranteed to be the most
  * up to date version. 
  * glMatrix can be found here: http://glmatrix.net/
  */
var TentaGL = { 
  
  /** The major version number of this framework. */
  versionMajor:0, 
  
  /** The minor version number of this framework. */
  versionMinor:17,
  
  
  //////// Canvas/Context creation
  
  
  /** 
   * Initializes and returns a WebGL context for a canvas element.
   * @param {DOM Canvas element} canvas  The canvas element we're making a 
   *      WebGL context for.
   * @param {WebGLContextAttributes} attrs   Optional. attributes used to get  
   *    the WebGL context. If not provided, the default values for the
   *     WebGLContextAttributes will be used. 
   *    See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
   * @return {WebGLRenderingContext }  The WebGL rendering context.
   */
  createGL: function(canvas, attrs) {
    attrs = attrs || {};
    
    // An Error will be thrown if the user's browser doesn't support WebGL.
    try {
      
      // Create the WebGL context for the canvas.
      var gl = canvas.getContext("webgl", attrs) || canvas.getContext("experimental-webgl", attrs) || canvas.getContext("webkit-3d", attrs) || canvas.getContext("moz-webgl", attrs);
      
      // Initialize its state data.
      TentaGL.Blend.reset(gl);
      TentaGL.Cull.reset(gl);
      TentaGL.DepthBuffer.reset(gl);
      TentaGL.Scissor.reset(gl);
      TentaGL.Stencil.reset(gl);
      
      TentaGL.Viewport.set(gl, [0, 0, canvas.width, canvas.height]);
      TentaGL.ViewTrans.reset(gl);
      this._normalTrans = mat3.create();
      this._mvpTrans = mat4.create();
      
      return gl;
    }
    catch(e) {
      var msg = "Error creating WebGL context: " + e.toString();
      throw new Error(msg);
    }
  },
  
  
  /** 
   * Produces a Canvas element and adds it to a div container. 
   * The canvas's dimensions are the same as its container's.
   * @param {DOM div element} container
   * @return {DOM canvas element}
   */
  createCanvas: function(container) {
    var canvas = document.createElement("canvas");
    container.appendChild(canvas);
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    return canvas;
  },
  

  
  //////// Clear
  
  /** 
   * Clears the color and depth buffers. 
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Color} color   Optional. The clear color to use.
   */
  clear:function(gl, color) {
    TentaGL.ColorBuffer.setClearColor(gl, color);
    gl.clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  },
  
  
  //////// WebGL type metadata
  
  
  /** 
   * Returns the string representation of a WebGL constant representing 
   * some data type or uniform variable type. 
   * @param {GLenum}
   * @return {string}
   */
  glTypeName: function(type) {
    return TentaGL._glTypeName[type];
  },
  
  
  
  /** 
   * Returns the size of a WebGL type in units of its base type.
   * @param {GLenum}
   * @return {int}
   */
  glSizeUnits: function(type){
    return TentaGL._glSizeUnits[type];
  },
  
  
  
  /** 
   * Returns the size of a WebGL type in bytes.
   * @param {GLenum}
   * @return {int}
   */
  glSizeBytes: function(type){
    var units = TentaGL.glSizeUnits(type);
    type = TentaGL.glUnitType(type);
    return units*TentaGL._glSizeBytes[type];
  },
  
  
  
  /** 
   * Returns the unit GL type of the given GL type. For example, the unit type
   * of FLOAT_VEC3 would be FLOAT.
   * @param {GLenum}
   * @return {GLenum}
   */
  glUnitType: function(type){
    return TentaGL._glUnitTypes[type];
  }
};


/** Returns true for all sprites. */
TentaGL._defaultRenderFilter = function(sprite) {
  return true;
};


TentaGL._glTypeName = [];
TentaGL._glTypeName[GL_BYTE]            = "BYTE";
TentaGL._glTypeName[GL_UNSIGNED_BYTE]   = "UNSIGNED_BYTE";
TentaGL._glTypeName[GL_SHORT]           = "SHORT";
TentaGL._glTypeName[GL_UNSIGNED_SHORT]  = "UNSIGNED_SHORT";
TentaGL._glTypeName[GL_INT]             = "INT";
TentaGL._glTypeName[GL_UNSIGNED_INT]    = "UNSIGNED_INT";
TentaGL._glTypeName[GL_FLOAT]           = "FLOAT";
TentaGL._glTypeName[GL_FLOAT_VEC2]      = "FLOAT_VEC2";
TentaGL._glTypeName[GL_FLOAT_VEC3]      = "FLOAT_VEC3";
TentaGL._glTypeName[GL_FLOAT_VEC4]      = "FLOAT_VEC4";
TentaGL._glTypeName[GL_INT_VEC2]        = "INT_VEC2";
TentaGL._glTypeName[GL_INT_VEC3]        = "INT_VEC3";
TentaGL._glTypeName[GL_INT_VEC4]        = "INT_VEC4";
TentaGL._glTypeName[GL_BOOL]            = "BOOL";
TentaGL._glTypeName[GL_BOOL_VEC2]       = "BOOL_VEC2";
TentaGL._glTypeName[GL_BOOL_VEC3]       = "BOOL_VEC3";
TentaGL._glTypeName[GL_BOOL_VEC4]       = "BOOL_VEC4";
TentaGL._glTypeName[GL_FLOAT_MAT2]      = "FLOAT_MAT2";
TentaGL._glTypeName[GL_FLOAT_MAT3]      = "FLOAT_MAT3";
TentaGL._glTypeName[GL_FLOAT_MAT4]      = "FLOAT_MAT4";
TentaGL._glTypeName[GL_SAMPLER_2D]      = "SAMPLER_2D";
TentaGL._glTypeName[GL_SAMPLER_CUBE]    = "SAMPLER_CUBE";


TentaGL._glSizeUnits = [];
TentaGL._glSizeUnits[GL_BYTE]           = 1; 
TentaGL._glSizeUnits[GL_UNSIGNED_BYTE]  = 1; 
TentaGL._glSizeUnits[GL_SHORT]          = 1; 
TentaGL._glSizeUnits[GL_UNSIGNED_SHORT] = 1;
TentaGL._glSizeUnits[GL_INT]            = 1; 
TentaGL._glSizeUnits[GL_UNSIGNED_INT]   = 1; 
TentaGL._glSizeUnits[GL_FLOAT]          = 1; 
TentaGL._glSizeUnits[GL_FLOAT_VEC2]     = 2; 
TentaGL._glSizeUnits[GL_FLOAT_VEC3]     = 3; 
TentaGL._glSizeUnits[GL_FLOAT_VEC4]     = 4; 
TentaGL._glSizeUnits[GL_INT_VEC2]       = 2;
TentaGL._glSizeUnits[GL_INT_VEC3]       = 3; 
TentaGL._glSizeUnits[GL_INT_VEC4]       = 4; 
TentaGL._glSizeUnits[GL_BOOL]           = 1; 
TentaGL._glSizeUnits[GL_BOOL_VEC2]      = 2; 
TentaGL._glSizeUnits[GL_BOOL_VEC3]      = 3; 
TentaGL._glSizeUnits[GL_BOOL_VEC4]      = 4;
TentaGL._glSizeUnits[GL_FLOAT_MAT2]     = 4; 
TentaGL._glSizeUnits[GL_FLOAT_MAT3]     = 9;
TentaGL._glSizeUnits[GL_FLOAT_MAT4]     = 16; 


TentaGL._glSizeBytes = [];
TentaGL._glSizeBytes[GL_BYTE]           = 1;
TentaGL._glSizeBytes[GL_UNSIGNED_BYTE]  = 1;
TentaGL._glSizeBytes[GL_SHORT]          = 2;
TentaGL._glSizeBytes[GL_UNSIGNED_SHORT] = 2;
TentaGL._glSizeBytes[GL_INT]            = 4;
TentaGL._glSizeBytes[GL_UNSIGNED_INT]   = 4;
TentaGL._glSizeBytes[GL_FLOAT]          = 4;
TentaGL._glSizeBytes[GL_BOOL]           = 4;


TentaGL._glUnitTypes = [];
TentaGL._glUnitTypes[GL_BYTE]           = GL_BYTE;
TentaGL._glUnitTypes[GL_UNSIGNED_BYTE]  = GL_UNSIGNED_BYTE;
TentaGL._glUnitTypes[GL_SHORT]          = GL_SHORT;
TentaGL._glUnitTypes[GL_UNSIGNED_SHORT] = GL_UNSIGNED_SHORT;
TentaGL._glUnitTypes[GL_INT]            = GL_INT;
TentaGL._glUnitTypes[GL_UNSIGNED_INT]   = GL_UNSIGNED_INT;
TentaGL._glUnitTypes[GL_FLOAT]          = GL_FLOAT;
TentaGL._glUnitTypes[GL_FLOAT_VEC2]     = GL_FLOAT;
TentaGL._glUnitTypes[GL_FLOAT_VEC3]     = GL_FLOAT;
TentaGL._glUnitTypes[GL_FLOAT_VEC4]     = GL_FLOAT;
TentaGL._glUnitTypes[GL_INT_VEC2]       = GL_INT;
TentaGL._glUnitTypes[GL_INT_VEC3]       = GL_INT;
TentaGL._glUnitTypes[GL_INT_VEC4]       = GL_INT;
TentaGL._glUnitTypes[GL_BOOL]           = GL_BOOL;
TentaGL._glUnitTypes[GL_BOOL_VEC2]      = GL_BOOL;
TentaGL._glUnitTypes[GL_BOOL_VEC3]      = GL_BOOL;
TentaGL._glUnitTypes[GL_BOOL_VEC4]      = GL_BOOL;
TentaGL._glUnitTypes[GL_FLOAT_MAT2]     = GL_FLOAT;
TentaGL._glUnitTypes[GL_FLOAT_MAT3]     = GL_FLOAT;
TentaGL._glUnitTypes[GL_FLOAT_MAT4]     = GL_FLOAT;


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


// Construct the Util namespace if it doesn't exist.
var Util;
if(!Util) {
  Util = {};
}


/** 
 * This utility object contains a bunch of helpful debugging methods.
 */
Util.Debug = {
  
  /** Returns a string representation of an array or typed array. */
  arrayString:function(array) {
    var result = "[";
    var first = true;
    for(var i=0; i < array.length; i++) {
      if(first) {
        first = false;
      }
      else {
        result += ", ";
      }
      result += array[i];
    }
    result += "]";
    return result;
  },
  
  
  objString:function(obj) {
    var result = "{";
    var first = true;
    
    for(var i in obj) {
      if(first) {
        first = false;
      }
      else {
        result += ", ";
      }
      
      result += i + ":" + obj[i];
    }
    
    result += "}";
    return result;
  }
  
 };
 
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/



TentaGL.DOM = {
  
  /** 
   * Gets the absolute position of a DOM element in the document. 
   * @param {DOM element}
   * @return {length-2 array} The XY coordinates.
   */
  getAbsolutePosition: function(element) {
    // get the absolute position of the canvas element in the document.
    var obj = element;
    var offX = 0;
    var offY = 0;
    while( obj.nodeName != "BODY") {
      offX += obj.offsetLeft;
      offY += obj.offsetTop;
      
      obj = obj.parentNode;
    }
    
    return [offX, offY];
  },
  
  
  /** Returns the string for a DOM script element's text content. */
  extractScriptText:function(scriptID) {
    var shaderScript = document.getElementById(scriptID);
    if(!shaderScript) {
      throw new Error("Script ID " + scriptID + " doesn't exist in the document.");
    }
    
    // Extract the shader source code from the DOM script element.
    var str = "";
    var k = shaderScript.firstChild;
    console.log(shaderScript);
    while(k) {
      if(k.nodeType == Node.TEXT_NODE) {
        str += k.textContent;
      }
      k = k.nextSibling;
    }
    
    return str;
  }
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


// Construct the Util namespace if it doesn't exist.
var Util;
if(!Util) {
  Util = {};
}


/** 
 * Utility object for implementing type inheritance.
 */
Util.Inheritance = {
  
  /**
   * Makes an object type's prototype inherit the fields of a parent type's 
   * prototype. The derived prototype's fields override those of its parent.
   * @param {type} subtype   The derived type.
   * @param {type} supertype   The parent type.
   */
  inherit:function(subtype, supertype) {
    for(var i in supertype.prototype) {
      if(!subtype.prototype[i]) {
        subtype.prototype[i] = supertype.prototype[i];
      }
    }
  }
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Simple API for setting the blending state of the gl context. The API 
 * is optimized to avoid making unnecessary repeat calls to change the internal  
 * graphics state. Therefore, it is strongly encouraged for TentaGL
 * applications to change the blending state of the gl context through this
 * API instead of directly through the gl context.
 */
TentaGL.Blend = {
  
  
  lock:function(gl) {
    gl._blendLocked = true;
  },
  
  unlock:function(gl) {
    gl._blendLocked = false;
  },
  
  
  /** 
   * Enables or disables blending. 
   * @param {WebGLRenderingContext} gl
   * @param {boolean} enabled
   */
  setEnabled:function(gl, enabled) {
    if(gl._blendEnabled != enabled && !gl._blendLocked) {
      gl._blendEnabled = enabled;
      
      if(enabled) {
        gl.enable(GL_BLEND);
      }
      else {
        gl.disable(GL_BLEND);
      }
    }
  },
  
  
  /** 
   * Returns whether blending is enabled in the gl state. 
   * @return {boolean}
   */
  isEnabled:function(gl) {
    return gl._blendEnabled;
  },
  
  
  
  
  /** 
   * Sets the blend equation and blend functions.
   * @param {WebGLRenderingContext} gl
   * @param {glEnum} equation   Any allowed value for gl.blendEquation
   * @param {glEnum} srcFunc    Any allowed source function value for gl.blendFunc.
   * @param {glEnum} dstFunc    Any allowed dest function value for gl.blendFunc.
   */
  setEquation:function(gl, equation, srcFunc, dstFunc) {
    if(gl._blendEquation != equation) {
      gl._blendEquation = equation;
      gl.blendEquation(equation);
    }
    
    if(gl._blendSrcFunc != srcFunc || gl._blendDstFunc != dstFunc) {
      gl._blendSrcFunc = srcFunc;
      gl._blendDstFunc = dstFunc;
      
      gl.blendFunc(srcFunc, dstFunc);
    }
  },
  
  
  /** 
   * Returns the equation being used for blending.
   * @return {glEnum}
   */
  getEquation:function(gl) {
    return gl._blendEquation;
  },
  
  
  /** 
   * Returns the source function used for blending in a gl context.
   * @param {WebGLRenderingContext} gl
   * @return {glEnum}
   */
  getSrcFunc:function(gl) {
    return gl._blendSrcFunc;
  },
  
  
  /** 
   * Returns the dst function used for blending in a gl context.
   * @return {glEnum}
   */
  getDstFunc:function(gl) {
    return gl._blendDstFunc;
  },
  
  
  
  /** 
   * Sets the blend color for a gl context.
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Color} color
   */
  setBlendColor:function(gl, color) {
    var r = color.getRed();
    var g = color.getGreen();
    var b = color.getBlue();
    var a = color.getAlpha();
    
    if(gl._blendRed != r || gl._blendGreen != g || gl._blendBlue != b || gl._blendAlpha != a) {
      gl._blendRed = r;
      gl._blendGreen = g;
      gl._blendBlue = b;
      gl._blendAlpha = a;
      
      gl.blendColor(r, g, b, a);
    }
  },
  
  
  /** 
   * Returns the blending color being used by a gl context.
   * @param {WebGLRenderingContext} gl
   * @return {TentaGL.Color}
   */
  getBlendColor:function(gl) {
    var color = TentaGL.Color.RGBA(gl._blendRed, gl._blendGreen, gl._blendBlue, gl._blendAlpha);
    return color;
  },
  
  
  /** 
   * Resets the metadata about the gl context's blending state. 
   * @param {WebGLRenderingContext} gl
   */
  reset: function(gl) {
    gl._blendLocked = false;
    gl._blendEnabled = false;
    
    gl._blendEquation = GL_FUNC_ADD;
    gl._blendSrcFunc = GL_ONE;
    gl._blendDstFunc = GL_ZERO;
    
    gl._blendRed = 0;
    gl._blendGreen = 0;
    gl._blendBlue = 0;
    gl._blendAlpha = 0;
  }
  
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/**
 * A simple API for changing the color buffer state of the gl context.
 */ 
TentaGL.ColorBuffer = {
  
  
  /** 
   * Resets the metadata about the gl context's color buffer state. 
   * @param {WebGLRenderingContext} gl
   */
  reset: function(gl) {
    gl._cbLock = false;
    
    gl._cbRed = 0;
    gl._cbGreen = 0;
    gl._cbBlue = 0;
    gl._cbAlpha = 0;
    
    gl._cbWriteRed = true;
    gl._cbWriteGreen = true;
    gl._cbWriteBlue = true;
    gl._cbWriteAlpha = true;
  },
  
  
  /** 
   * Locks the clear color so that it cannot be changed through this API 
   * until unlock is called. 
   */
  lock:function(gl) {
    gl._cbLock = true;
  },
  
  
  /** Unlocks the clear color. */
  unlock:function(gl) {
    gl._cbLock = false;
  },
  
  
  
  /** 
   * Sets the color used to clear the color buffer for a gl context. 
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Color} color
   */
  setClearColor:function(gl, color) {
    if(!gl._cbLock) {
      gl._cbRed = color.getRed();
      gl._cbGreen = color.getGreen();
      gl._cbBlue = color.getBlue();
      gl._cbAlpha = color.getAlpha();
      
      gl.clearColor(gl._cbRed, gl._cbGreen, gl._cbBlue, gl._cbAlpha);
    }
  },
  
  
  /** 
   * Returns the clear color for a gl context. 
   * @return {vec4}
   */
  getClearColor:function(gl) {
    return vec4.fromValues(gl._cbRed, gl._cbGreen, gl._cbBlue, gl._cbAlpha);
  },
  
  
  /** Sets which color components are writable in the buffer. */
  setWriteable:function(gl, red, green, blue, alpha) {
    gl._cbWriteRed = red;
    gl._cbWriteGreen = green;
    gl._cbWriteBlue = blue;
    gl._cbWriteAlpha = alpha;
    
    gl.colorMask(red, green, blue, alpha);
  },
  
  
  /** 
   * Clears the color buffer.
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Color} color   Optional. Specify the clear color.
   */
  clear:function(gl, color) {
    if(color) {
      this.setClearColor(gl, color);
    }
    gl.clear(GL_COLOR_BUFFER_BIT);
  }
  
  
  
  
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A simple API for setting the face-culling state of the gl context.
 */
TentaGL.Cull = {
  
  /** 
   * Sets the face-culling mode for the gl context. 
   * @param {WebGLRenderingContext} gl
   * @param {glEnum} mode   Any allowed value for gl.cullFace.
   */
  setMode:function(gl, mode) {
    if(gl._cullMode != mode) {
      gl._cullMode = mode;
      
      if(mode == GL_NONE) {
        gl.disable(GL_CULL_FACE);
      }
      else {
        gl.enable(GL_CULL_FACE);
        gl.cullFace(mode);
      }
    }
  },
  
  
  /** 
   * Returns the face-culling mode being used.
   * @param {WebGLRenderingContext} gl
   */
  getMode:function(gl) {
    return gl._cullMode;
  },
  
  
  /** 
   * Resets the metadata about the face-culling state for a gl context. 
   * @param {WebGLRenderingContext} gl
   */
  reset: function(gl) {
    gl._cullMode = GL_NONE;
  }
  
  
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A simple API for setting the depth-testing state of the gl context.
 */
TentaGL.DepthBuffer = {
  
  /** 
   * Resets the metadata about the depth buffer test for a gl context.
   * @param {WebGLRenderingContext} gl
   */
  reset: function(gl) {
    gl._depthEnabled = false;
    gl._depthFunc = GL_LESS;
    gl._depthWrite = true;
    
    gl._depthWinNear = 0;
    gl._depthWinFar = 1;
    
    gl._depthClearVal = 1;
  },
  
  
  
  /** 
   * Enables or disables the texel depth test for a gl context. 
   * @param {WebGLRenderingContext} gl
   * @param {boolean} enabled
   */
  setEnabled:function(gl, enabled) {
    if(gl._depthEnabled != enabled) {
      gl._depthEnabled = enabled;
      
      if(enabled) {
        gl.enable(GL_DEPTH_TEST);
      }
      else {
        gl.disable(GL_DEPTH_TEST);
      }
    }
  },
  
  
  /** 
   * Returns whether the texel depth test is enabled for a gl context.
   * @param {WebGLRenderingContext} gl
   * @return {boolean}
   */
  isTestEnabled:function(gl) {
    return gl._depthEnabled;
  },
  
  
  
  /** 
   * Sets the depth comparison function. 
   * @param {WebGLRenderingContext} gl
   * @param {glEnum} func
   */
  setFunc:function(gl, func) {
    if(gl._depthFunc != func) {
      gl._depthFunc = func;
      
      gl.depthFunc(func);
    }
  },
  
  
  /** 
   * Returns the depth comparison function being used. 
   * @param {WebGLRenderingContext} gl
   * @return {glEnum}
   */
  getFunc:function(gl) {
    return gl._depthFunc;
  },
  
  
  /** 
   * Sets whether the depth buffer is enabled for writing. 
   * @param {WebGLRenderingContext} gl
   * @param {boolean} enabled
   */
  setMaskEnabled:function(gl, enabled) {
    if(gl._depthWrite != enabled) {
      gl._depthWrite = enabled;
      
      gl.depthMask(enabled);
    }
  },
  
  
  /** 
   * Returns whether the depth buffer is enabled for writing.
   * @param {WebGLRenderingContext} gl
   * @return {boolean}
   */
  isMaskEnabled:function(gl) {
    return gl._depthWrite;
  },
  
  
  /** 
   * Sets the linear mapping of depth values from normalized device coordinates 
   * [-1, 1] to window coordinates [0,1].
   * It is not necessary that near be less than far. Reverse mappings such as
   * near = 1 and far = 0 are acceptable.
   * @param {WebGLRenderingContext} gl
   * @param {float} near    The mapping of the near clipping plane to window coordinates.
   * @param {float} far     The mapping of the far clipping plane to window coordinates.
   */
  setRange:function(gl, near, far) {
    near = TentaGL.Math.clamp(near, 0, 1);
    far = TentaGL.Math.clamp(far, 0, 1);
    
    if(gl._depthWinNear != near || gl._depthWinFar != far) {
      gl._depthWinNear = near;
      gl._depthWinFar = far;
      
      gl.depthRange(near, far);
    }
  },
  
  
  /** 
   * Returns the mapping of the near clipping plane to window coordinates.
   * @param {WebGLRenderingContext} gl
   * @return {float}
   */
  getRangeNear:function(gl) {
    return gl._depthWinNear;
  },
  
  
  /** 
   * Returns the mapping of the far clipping plane to window coordinates.
   * @param {WebGLRenderingContext} gl
   * @return {float}
   */
  getRangeFar:function(gl) {
    return gl._depthWinFar;
  },
  
  
  /** 
   * Sets the clear value for the depth buffer.
   * @param {WebGLRenderingContext} gl
   * @param {float} value
   */
  setClearValue:function(gl, value) {
    value = TentaGL.Math.clamp(value, 0, 1);
    if(gl._depthClearVal != value) {
      gl._depthClearVal = value;
      
      gl.clearDepth(value);
    }    
  },
  
  
  /** 
   * Returns the clear value for the depth buffer.
   * @param {WebGLRenderingContext} gl
   * @return {float}
   */
  getClearValue:function() {
    return gl._depthClearVal;
  },
  
  
  /** 
   * Clears the depth buffer. 
   * @param {WebGLRenderingContext} gl
   */
  clear:function(gl) {
    gl.clear(GL_DEPTH_BUFFER_BIT);
  },
  
  
  /** 
   * Creates an off-screen depth buffer. 
   * @param {WebGLRenderingContext} gl
   * @param {int} width
   * @param {int} height
   * @return {WebGLRenderbuffer}
   */
  createBuffer:function(gl, width, height) {
    var buffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(GL_RENDERBUFFER, buffer);
    gl.renderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);
    gl.bindRenderbuffer(GL_RENDERBUFFER, null);
    return buffer;
  }
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A simple API for changing the scissor test state of the gl context.
 * When enabled, only pixels inside the rectangle in canvas space defined
 * by the scissor state can be modified. By default, the scissor test is disabled.
 */
TentaGL.Scissor = {
  
  
  /** Resets the meta-data about the scissor test state for a gl context. */
  reset: function(gl) {
    gl._scissorX = 0;
    gl._scissorY = 0;
    gl._scissorWidth = 1;
    gl._scissorHeight = 1;
    
    gl._scissorEnabled = false;
  },
  
  
  
  /** 
   * Specifies the scissor rectangle for the gl context. 
   * @param {WebGLRenderingContext}
   * @param {array: uint || undefined} xywh  4 integers defining the x scissor box.
   *      If undefined, scissoring will be disabled. 
   *      Otherwise, scissoring will be enabled and the scissor box will be set.
   */
  set:function(gl, xywh) {
    if(xywh) {
      gl._scissorX = xywh[0];
      gl._scissorY = xywh[1];
      gl._scissorWidth = xywh[2];
      gl._scissorHeight = xywh[3];
      gl._scissorEnabled = true;
      
      gl.enable(GL_SCISSOR_TEST);
      gl.scissor(xywh[0], xywh[1], xywh[2], xywh[3]);
    }
    else {
      gl._scissorEnabled = false;
      
      gl.disable(GL_SCISSOR_TEST);
    }
  },
  
  
  /** 
   * Returns the metrics defining the scissor test box for the gl context.
   * The metrics are an array with 4 values:
   *  The x coordinate of the left edge of the scissor box in canvas space.
   *  The y coordinate of the bottom edge of the scissor box in canvas space. (0 is at the bottom of the canvas, y increases upwards)
   *  The width of the scissor box.
   *  The height of the scissor box.
   * @return {array: uint}   
   */
  get:function(gl) {
    return [gl._scissorX, gl._scissorY, gl._scissorWidth, gl._scissorHeight];
  },
  
  
  /** 
   * Returns the x coordinate of the left edge of the scissor test box. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getX:function(gl) {
    return gl._scissorX;
  },
  
  /** 
   * Returns the y coordinate of the bottom edge of the scissor test box. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getY:function(gl) {
    return gl._scissorY;
  },
  
  
  /** 
   * Returns the width of the scissor test box. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getWidth:function(gl) {
    return gl._scissorWidth;
  },
  
  
  /** 
   * Returns the height of the scissor test box. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getHeight:function(gl) {
    return gl._scissorHeight;
  },
  
  
  /** 
   * Returns whether the scissor test is enabled for the gl context. 
   * @param {WebGLRenderingContext} gl
   * @return {boolean}
   */
  isEnabled:function(gl) {
    return gl._scissorEnabled;
  }
};
 
 
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/**
 * A simple API for setting the stencil-testing state of the gl context.
 */
TentaGL.Stencil = {
  
  /** 
   * Resets the metadata about the stencil-testing state of a gl context.
   * @param {WebGLRenderingContext} gl
   */
  reset: function(gl) {
    gl._stencilEnabled = false;
    gl._stencilClearVal = 0;
  },
  
  
  /**
   * Enables or disables stencil testing. 
   * @param {WebGLRenderingContext} gl
   * @param {boolean} enabled
   */
  setTestEnabled:function(gl, enabled) {
    if(gl._stencilEnabled != enabled) {
      gl._stencilEnabled = enabled;
      
      if(enabled) {
        gl.enable(GL_STENCIL_TEST);
      }
      else {
        gl.disable(GL_STENCIL_TEST);
      }
    }
  },
  
  
  /**
   * Returns whether stencil testing is enabled.
   * @return {boolean}
   */
  isStencilEnabled:function() {
    return gl._stencilEnabled;
  },
  
  
  /** 
   * Sets the clear value for the stencil buffer.
   * @param {WebGLRenderingContext} gl
   * @param {uint} value
   */
  setClearValue:function(gl, value) {
    if(gl._stencilClearVal != value) {
      gl._stencilClearVal = value;
      
      gl.clearStencil(value);
    }
  },
  
  
  /** 
   * Returns the clear value for the stencil buffer. 
   * @return {uint}
   */
  getClearValue:function() {
    return gl._stencilClearVal;
  },
  
  
  
  /**
   * Creates an off-screen stencil buffer.
   * @param {WebGLRenderingContext} gl
   * @param {int} width
   * @param {int} height
   * @return {WebGLRenderbuffer}
   */
  createStencilBuffer: function(gl, width, height) {
    var buffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, width, height);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    return buffer;
  }
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A simple API for changing the state of the viewport in the gl context.
 */
TentaGL.Viewport = {
  
  /** 
   * Returns the metrics of the gl context's viewport. 
   * The metrics are returned as a list containing, in order: 
   *  The x coordinate of the left edge in canvas coordinates.
   *  The y coordinate of the bottom edge in canvas coordinates. (0 corresponds to the bottom edge of the canvas. y increases upwards)
   *  The width.
   *  The height.
   * @param {WebGLRenderingContext} gl
   * @return {array: [uint, uint, uint, uint]}
   */
  get:function(gl) {
    return [gl._viewX, gl._viewY, gl._viewWidth, gl._viewHeight];
  },
  
  
  /** 
   * Returns the x coordinate of the viewport's left edge. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getX:function(gl) {
    return gl._viewX;
  },
  
  
  /** 
   * Returns the y coordinate of the viewport's bottom edge. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getY:function(gl) {
    return gl._viewY;
  },
  
  
  /** 
   * Returns the width of the viewport. 
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getWidth:function(gl) {
    return gl._viewWidth;
  },
  
  
  /** 
   * Returns the height of the viewport.
   * @param {WebGLRenderingContext} gl
   * @return {uint}
   */
  getHeight:function(gl) {
    return gl._viewHeight;
  },
  
  
  /** 
   * Sets the rectangle defining the gl context's viewport on the canvas.
   * @param {WebGLRenderingContext} gl
   * @param {array:[uint, uint, uint, uint]
   */
  set:function (gl, xywh) {
    gl._viewX = xywh[0];
    gl._viewY = xywh[1];
    gl._viewWidth = xywh[2];
    gl._viewHeight = xywh[3];
    gl.viewport(xywh[0], xywh[1], xywh[2], xywh[3]);
  }
};
 
 
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * In raidians, 1 TAU is equivalent to a 360 degree rotation. 
 * I simply find this more convenient than 2*PI for many applications.
 */
TentaGL.TAU = 2*Math.PI;

/** Math utilities. Algebraic!! */
TentaGL.Math = {
  
  //////// Coordinates
  
  /** 
   * Converts cartesian XYZ coordinates to polar [radius, thetaY, thetaX] coordinates, 
   * with thetaX and thetaY given in radians. Note that in our polar coordinate 
   * system, we rotate around the Y axis first, then the X axis.
   * @param {vec3} xyz  The cartesian coordinates
   * @return {vec3} The polar coordinates
   */
  toPolar:function(xyz) {
    var v = vec3.fromValues(xyz[0], xyz[1], xyz[2]);
    var radius = vec3.length(v);
    
    v = vec3.normalize(v, v);
    
    var thetaX = Math.asin(this.clamp(v[1], -1, 1));
    var thetaY;
    if(xyz[0] == 0) {
      if(xyz[2] > 0) {
        thetaY = TentaGL.TAU*0.75;
      }
      else {
        thetaY = TentaGL.TAU*0.25;
      }
    }
    else {
      thetaY = Math.atan(-xyz[2]/xyz[0]);
      if(xyz[0] < 0) {
        thetaY += TentaGL.TAU/2;
      }
    }
    
    return vec3.fromValues(radius, thetaY, thetaX);
  },
  
  
  /** 
   * Convertex polar coordinates [radius, thetaY, thetaX] with thetaX and thetaY
   * given in radians to cartesian XYZ coordinates.
   * @param {vec3} ryx  The polar coordinates.
   * @return {vec3} The cartesian coordinates
   */
  toCartesian:function(ryx) {
    var x = ryx[0]*Math.cos(ryx[1])*Math.cos(ryx[2]);
    var y = ryx[0]*Math.sin(ryx[2]);
    var z = 0 - ryx[0]*Math.sin(ryx[1])*Math.cos(ryx[2]);
    
    return vec3.fromValues(x, y, z);
  },
  
  
  //////// Ranges, Domains
  
  
  /** 
   * Clamps the specified value to the range [min, max]. 
   * @param {Number} value
   * @param {Number} min
   * @param {Number} max
   * @return {Number}
   */
  clamp:function(value, min, max) {
    return Math.min(max, Math.max(value, min));
  },
  
  
  /** 
   * Wraps the specified value to the range [min, max).
   * @param {Number} value
   * @param {Number} min
   * @param {Number} max
   * @return {Number}
   */
  wrap:function(value, min, max) {
    var rangeSize = max-min;
    
    var x = (value - min) % rangeSize;
    if(x < 0) {
      x += rangeSize;
    }
    
    return x + min;
  },
  
  
  /** 
   * Maps a value within some domain linearlly to a corresponding value within 
   * some range. 
   * @param {number} value
   * @param {array: [number, number]}
   * @param {array: [number, number]}
   */
  linearMap: function(value, domain, range) {
    var dDomain = domain[1] - domain[0];
    var dRange = range[1] - range[0];
    
    var alpha = (value - domain[0])/dDomain;
    
    return range[0] + dRange*alpha;
  },
  
  
  //////// Points
  
  /** 
   * Given a set of 2D or 3D points, return the point with the 
   * minimum X coordinate. 
   * @param {array: vec3}
   */
  ptsMinX: function(points) {
    var result;
    
    for(var i=0; i < points.length; i++) {
      var pt = points[i];
      
      if(!result || pt[0] < result[0]) {
        result = pt;
      }
    }
    
    return result;
  },
  
  /** 
   * Given a set of 2D or 3D points, return the point with the 
   * maximum X coordinate. 
   * @param {array: vec3}
   */
  ptsMaxX: function(points) {
    var result;
    
    for(var i=0; i < points.length; i++) {
      var pt = points[i];
      
      if(!result || pt[0] > result[0]) {
        result = pt;
      }
    }
    
    return result;
  },
  
  /** 
   * Given a set of 2D or 3D points, return the point with the 
   * minimum Y coordinate. 
   * @param {array: vec3}
   */
  ptsMinY: function(points) {
    var result;
    
    for(var i=0; i < points.length; i++) {
      var pt = points[i];
      
      if(!result || pt[1] < result[1]) {
        result = pt;
      }
    }
    
    return result;
  },
  
  /** 
   * Given a set of 2D or 3D points, return the point with the 
   * maximum Y coordinate. 
   * @param {array: vec3}
   */
  ptsMaxY: function(points) {
    var result;
    
    for(var i=0; i < points.length; i++) {
      var pt = points[i];
      
      if(!result || pt[1] > result[1]) {
        result = pt;
      }
    }
    
    return result;
  },
  
  /** 
   * Given a set of 2D or 3D points, return the point with the 
   * minimum Z coordinate. 
   * @param {array: vec3}
   */
  ptsMinZ: function(points) {
    var result;
    
    for(var i=0; i < points.length; i++) {
      var pt = points[i];
      
      if(!result || pt[2] < result[2]) {
        result = pt;
      }
    }
    
    return result;
  },
  
  /** 
   * Given a set of 2D or 3D points, return the point with the 
   * maximum Z coordinate. 
   * @param {array: vec3}
   */
  ptsMaxZ: function(points) {
    var result;
    
    for(var i=0; i < points.length; i++) {
      var pt = points[i];
      
      if(!result || pt[2] > result[2]) {
        result = pt;
      }
    }
    
    return result;
  },
  
  
  ptsEqual: function(p1, p2, tolerance) {
    if(!tolerance) {
      tolerance = 0;
    }
    
    var dx = Math.abs(p1[0] - p2[0]);
    var dy = Math.abs(p1[1] - p2[1]);
    
    return (dx <= tolerance && dy <= tolerance);
  },
  
  
  //////// Vectors
  
  
  /**
   * Returns the angle from u to v, rotated around their cross product. 
   * @param {vec3} u
   * @param {vec3} v
   * @return {number}
   */
  vectorAngle: function(u, v) {
    var uHat = vec3.normalize(vec3.create(), u);
    var vHat = vec3.normalize(vec3.create(), v);
    
    var n = vec3.cross(vec3.create(), u, v);
    nMag = vec3.length(n);
    
    var theta = Math.acos(vec3.dot(uHat, vHat));
    if(nMag < 0) {
      theta = TentaGL.TAU - theta;
    }
    
    return theta;
  },
  
  
  
  /** 
   * Computes a unit vector parametrically rotated between two vectors.
   * @param {vec3} u
   * @param {vec3} v
   * @param {number} alpha  A parametric value in the range [0,1].
   * @return {vec3}
   */
  tweenVector: function(u, v, alpha) {
    var uHat = vec3.normalize(vec3.create(), u);
    var vHat = vec3.normalize(vec3.create(), v);
    
    var n = vec3.cross(vec3.create(), u, v);
    nMag = vec3.length(n);
    
    var theta = Math.acos(vec3.dot(uHat, vHat));
    if(nMag < 0) {
      theta = TentaGL.TAU - theta;
    }
    else if(nMag == 0) {
      n = [0,0,1];
    }
    n = vec3.normalize(n, n);
    
    var q = quat.setAxisAngle(quat.create(), n, theta*alpha);
    return vec3.transformQuat(vec3.create(), uHat, q);
  },
  
  
  
  
  
  
  
  //////// Spaces
  
  
  /** 
   * Returns a matrix for changing a vector from basis B' to a vector in the 
   * standard basis of R^3. 
   * @param {vec3} vX   The X axis in B' relative to R^3.
   * @param {vec3} vY   The Y axis in B' relative to R^3.
   * @param {vec3} vZ   The Z axis in B' relative to R^3.
   * @return {mat3}
   */
  matChangeBasis:function(vX, vY, vZ) {
    var m = mat3.create();
    m[0] = vX[0];
    m[1] = vX[1];
    m[2] = vX[2];
    
    m[3] = vY[0];
    m[4] = vY[1];
    m[5] = vY[2];
    
    m[6] = vZ[0];
    m[7] = vZ[1];
    m[8] = vZ[2];
    return m;
  },
  
  
  
  //////// Orientation
  
  /** 
   * Gets the quaternion for rotating from one vector to another. 
   * @param {vec3} vFrom  The start vector.
   * @param {vec3} vTo  The end vector.
   * @return {quat}
   */
  getQuatFromTo:function(vFrom, vTo) {
    var vnFrom = vec3.normalize(this._vec3_1, vFrom);
    var vnTo = vec3.normalize(this._vec3_2, vTo);
    
    var axis = vec3.cross(this._vec3_3, vnFrom, vnTo);
    vec3.normalize(axis, axis);
    var cosTheta = TentaGL.Math.clamp(vec3.dot(vnFrom, vnTo), -1, 1);
    var sinTheta = vec3.length(axis);
    
    var theta = Math.acos(cosTheta);
    if(sinTheta < 0) {
      theta = 0-theta;
    }
    
    var q = quat.setAxisAngle(quat.create(), axis, theta);
    return quat.normalize(q, q);
  },
  
  
  
  /** 
   * Gets the quaternion for rotating from one orientation to another.
   * @param {vec3} xFrom    The start x-axis vector.
   * @param {vec3} yFrom    The start y-axis vector.
   * @param {vec3} xTo      The end x-axis vector.
   * @param {vec3} yTo      The end y-axis vector.
   * @return {quat}
   */
  getOrientation:function(xFrom, yFrom, xTo, yTo) {
    var q = this.getQuatFromTo(xFrom, xTo);
    
    var curY = vec3.transformQuat(vec3.create(), yFrom, q);
    var q2 = this.getQuatFromTo(curY, yTo);
    quat.mul(q, q2, q);
    
    return q;
  },
  
  
  
  
  
  //////// Exponents
  
  /** 
   * Returns the first power of two >= to value.
   * @param {Number} value
   * @param {int}
   */
  getPowerOfTwo:function(value) {
    var pow = 1;
    while(pow < value) {
      pow *= 2;
    }
    return pow;
  },
  
  
  
  
  //////// 
  
  /** 
   * Recyclable vec3s for intermediate Math vector operations so that we don't 
   * have to spend as much time creating new vectors for every operation.
   */
  _vec3_1:vec3.create(),
  _vec3_2:vec3.create(),
  _vec3_3:vec3.create()
  
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A finite line in 2D space.
 * @param {vec3} p1
 * @param {vec3} p2
 */
TentaGL.Math.Line2D = function(p1, p2) {
  this._p1 = vec3.clone(p1);
  this._p1[2] = 1;
  
  this._p2 = vec3.clone(p2);
  this._p2[2] = 1;
  
  this._length = vec2.dist(p1, p2);
};

TentaGL.Math.Line2D.prototype = {
  
  constructor: TentaGL.Math.Line2D,
  
  isaLine2D: true,
  
  
  /** 
   * Returns a clone of the line. 
   * @return TentaGL.Math.Line2D
   */
  clone: function() {
    return new TentaGL.Math.Line2D(this._p1, this._p2);
  },
  
  
  /** 
   * Returns the first point of the line. 
   * @return {vec3}
   */
  getPt1: function() {
    return this._p1;
  },
  
  
  /** 
   * Returns the second point of the line.
   * @return {vec3}
   */
  getPt2: function() {
    return this._p2;
  },
  
  
  /** 
   * Returns the length of this line. 
   * @return {number}
   */
  getLength: function() {
    return this._length;
  },
  
  
  /** 
   * Returns the vector component of the line defined by v = p2 - p1.
   * @return {vec3}
   */
  getVec3: function() {
    return vec3.sub(vec3.create(), this._p2, this._p1);
  },
  
  
  /** 
   * Returns the angle, in radians in the range [-PI, PI], formed from this 
   * line's vector and the vector of the positive X axis. 
   * @return {number}
   */
  getAngle: function() {
    var v = this.getVec3();
    return Math.atan2(v[1], v[0]);
  },
  
  
  
  //////// Distance
  
  
  /** 
   * Returns the distance of a point to this line.
   * @param {vec3} pt
   */
  distToPt: function(pt) {
    var u = this.getVec3();
    var v = vec2.sub(vec2.create(), pt, this._p1);
    var w = vec2.sub(vec2.create(), pt, this._p2);
    
    if(vec2.dot(u, v) <= 0) {
      return vec2.len(v);
    }
    else if(vec2.dot(u, w) >= 0) {
      return vec2.len(w);
    }
    else {
      var uHat = vec2.normalize(vec2.create(), u);
      var vHat = vec2.normalize(vec2.create(), v);
      var cross = vec2.cross(vec2.create(), uHat, vHat);
      
      return vec2.len(v)*vec3.len(cross);
    }
  },
  
  
  /** 
   * Returns the distance from this line to another. 
   * @param {TentaGL.Math.Line2D} line
   * @return {number}
   */
  distToLine: function(line) {
    if(this.intersects(line)) {
      return 0;
    }
    
    var d1 = this.distToPt(line._p1);
    var d2 = this.distToPt(line._p2);
    var d3 = line.distToPt(this._p1);
    var d4 = line.distToPt(this._p2);
    
    return Math.min(d1, d2, d3, d4);
  },
  
  
  
  //////// Intersection
  
  
  /**
   * Returns true iff the line contains some point.
   * @param {vec3} pt
   * @param {ufloat) tolerance    Optional. Default 0.
   */
  containsPt: function(pt, tolerance) {
    if(!tolerance) {
      tolerance = 0;
    }
    
    var u = this.getVec3();
    var s;
    if(this._length == 0) {
      s = 0;
    }
    else if(u[0] == 0) {
      s = (pt[1] - this._p1[1])/u[1];
    }
    else {
      s = (pt[0] - this._p1[0])/u[0];
    }
    
    var x = this._p1[0] + s*u[0];
    var y = this._p1[1] + s*u[1];
    
    return Math.ptsEqual(pt, [x,y], tolerance);
  },
  
  
  /** 
   * Returns true iff this line intersects the other line.
   * @param {TentaGL.Math.Line2D} line
   * @return {boolean}
   */
  intersects: function(line) {
    return (this.intersection(line) != undefined);
  },
  
  
  /** 
   * Returns the intersection between this line and another, or 
   * undefined if they don't intersect. This may be a point (vec3), or it could be 
   * another Line2D if they are collinear.
   * @param {TentaGL.Math.Line2D} line
   * @param {ufloat} tolerance
   * @return {vec3 | TentaGL.Math.Line2D}
   */
  intersection: function(line, tolerance) {
    if(!tolerance) {
      tolerance = 0;
    }
    
    // If either of the lines have a length of 0, treat them as a point.
    if(this._length == 0 && line.containsPt(this._p1)) {
      return this._p1;
    }
    else if(line._length ==0 && this.containsPt(line._p1)) {
      return line._p1;
    }
    
    // Both are lines with length > 0.
    else {

      // Transform the system so that we are comparing the other line to a unit 
      // vector facing in +X.
      var m = mat3.create();
      mat3.scale(m, m, [1/this._length, 1, 1]);
      mat3.rotate(m, m, -this.getAngle());
      mat3.translate(m, m, [-this._p1[0], -this._p1[1]]);
      
      var mInv = mat3.invert(mat3.create(), m);
      
      var tLine = line.transformMat3(m);
      var tVec = tLine.getVec3();
      
      // The transformed line is parallel to the X axis...
      if(tVec[1] == 0 && tLine._p1[1] != 0) {
        
        // but isn't on the X axis.
        if(tLine._p1[1] != 0) {
          return undefined;
        }
        
        // and is on the X axis and contains (0,0)...
        else if(tLine.containsPt([0,0], tolerance)) {
          
          // and also contains (1,0). Therefore, line completely overlaps this.
          if(tLine.containsPt([1,0], tolerance)) {
            return this.clone();
          }
          
          // but doesn't contain (1,0). Therefore, line contains part of this.
          else {
            var maxPoint = TentaGL.Math.ptsMaxX([tLine._p1, tLine._p2]);
            vec3.transformMat3(maxPoint, maxPoint, mInv);
            
            return new TentaGL.Math.Line2D(this._p1, maxPoint);
          }
        }
        
        // and is on the X axis and contains (1,0), but not (0,0). Therefore,
        // line contains part of this.
        else if(tLine.containsPt([1,0], tolerance)) {
          var minPoint = TentaGL.Math.ptsMinX([tLine._p1, tLine._p2]);
          vec3.transformMat3(minPoint, minPoint, mInv);
          
          return new TentaGL.Math.Line2D(minPoint, this._p2);
        }
      }
      
      // The transformed line is not parallel to the X axis, and therefore 
      // intersects the X axis at some point.
      else {
        
        var s = -tLine._p1[1]/tVec[1];
        var x = tLine._p1[0] + s*tVec[0];
        
        // The transformed lines intersect.
        if(x >= 0-tolerance && x <= 1+tolerance) {
          var pt = [x, 0, 1];
          vec3.transformMat3(pt, pt, mInv);
          
          return pt;
        }
        
        // The transformed lines do not intersect.
        else {
          return undefined;
        }
      }
    }
  },
  
  

  
  //////// Transformation
  
  /** 
   * Transforms the points of this line segment using the provided transform 
   * matrix. 
   * @param {mat3} m
   */
  transformMat3: function(m) {
    var p1 = vec3.clone(this._p1);
    p1 = vec3.transformMat3(vec3.create(), p1, m);
    
    var p2 = vec3.clone(this._p2);
    vec3.transformMat3(p2, p2, m);
    
    return new TentaGL.Math.Line2D(p1, p2);
  },
  
  
  /** 
   * Transforms the points of this line segment using the provided transform 
   * matrix. 
   * @param {mat4} m
   */
  transformMat4: function(m) {
    var p1 = vec3.clone(this._p1);
    vec3.transformMat4(p1, p1, m);
    
    var p2 = vec3.clone(this._p2);
    vec3.transformMat4(p2, p2, m);
    
    return new TentaGL.Math.Line2D(p1, p2);
  },
  
  
  //////// Axis of separation
  
  /**  
   * Returns an indicator of where the specified point lies in relation to 
   * this line. 1 indicates that the segment must be rotated in the direction
   * from +X to -Y to point towards the point. -1 Indicates that the segment
   * must be rotated from +X to +Y. 0 Indicates that the point lies exactly
   * on the line, if it were projected infinitely in both of its directions.
   * 0 is rare, however and likely will involve rounding errors. So it is
   * not recommended for testing collinearness.
   * @param {vec3} pt
   * @return {int}
   */
  relativeCCW: function(pt) {
    var u = this.getVec3();
    var v = vec3.sub(vec3.create(), pt, this._p1);
    var cross = vec3.cross(v, u, v);
    
    if(cross[2] > 0) {
      return -1;
    }
    else if(cross[2] < 0) {
      return 1;
    }
    else {
      return 0;
    }
  },
  
  
  /** 
   * Tests if this point lies "above" the vector of the line. This, of course,
   * depends upon the direction of the Y axis.
   * @param {vec3} pt
   * @param {boolean} yIsDown   Optional. If true, then Y increases downwards 
   *      in our coordinate system. Default false.
   * @return {boolean}
   */
  ptIsAbove: function(pt, yIsDown) {
    var rccw = this.relativeCCW(pt);
    
    if(yIsDown) {
      rccw *= -1;
    }
    
    return (rccw < 0);
  },
  
  /** 
   * Tests if this point lies "below" the vector of the line. This, of course,
   * depends upon the direction of the Y axis.
   * @param {vec3} pt
   * @param {boolean} yIsDown   Optional. If true, then Y increases downwards 
   *      in our coordinate system. Default false.
   * @return {boolean}
   */
  ptIsBelow: function(pt, yIsDown) {
    var rccw = this.relativeCCW(pt);
    
    if(yIsDown) {
      rccw *= -1;
    }
    
    return (rccw > 0);
  },
  
  //////// Rendering
  
  
  /** 
   * Renders this line into the scene. 
   * @param {WebGLRenderingContext} gl
   * @param {string} materialName   The name of the material used to color 
   *      the line.
   */
  render: function(gl, materialName) {
    var p1 = vec3.clone(this._p1);
    p1[2] = 0;
    
    var p2 = vec3.clone(this._p2);
    p2[2] = 0;
    
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    
    TentaGL.ViewTrans.push(gl);
    
    var m = mat4.create();
    mat4.translate(m, m, [p1[0], p1[1], 0]);
    mat4.scale(m, m, [dx, dy, 0]);
    
    TentaGL.ViewTrans.mul(gl, m);
    TentaGL.ViewTrans.updateMVPUniforms(gl);
    TentaGL.MaterialLib.use(gl, materialName);
    TentaGL.ModelLib.render(gl, "unitLine");
    
    TentaGL.ViewTrans.pop(gl);
  }
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/**
 * A finite line in 3D space.
 * @param {vec4} p1
 * @param {vec4} p2
 */
TentaGL.Math.Line3D = function(p1, p2) {
  this._p1 = vec4.clone(p1);
  this._p1[3] = 1;
  
  this._p2 = vec4.clone(p2);
  this._p2[3] = 1;
  
  this._length = vec3.dist(p1, p2);
};


TentaGL.Math.Line3D.prototype = {
  
  constructor: TentaGL.Math.Line3D,
  
  isaLine3D: true,
  
  
  /** 
   * Returns a clone of the line. 
   * @return {TentaGL.Math.Line3D}
   */
  clone: function() {
    return new TentaGL.Math.Line3D(this._p1, this._p2);
  },
  
  
  /** 
   * Returns the first point of the line.
   * @return {vec4}
   */
  getPt1: function() {
    return this._p1;
  },
  
  
  /** 
   * Returns the second point of the line. 
   * @return {vec4}
   */
  getPt2: function() {
    return this._p2;
  },
  
  
  /** 
   * Returns the length of the line.
   * @return {number}
   */
  getLength: function() {
    return this._length;
  },
  
  
  /** 
   * Returns the vector component of the line defined by v = p2 - p1.
   * @return {vec4}
   */
  getVec3: function() {
    return vec3.sub(vec3.create(), this._p2, this._p1);
  },
  
  
  /** 
   * Returns the quaternion for the line's orientation relative to vector 
   * of the positive X axis.
   * @return {quat}
   */
  getQuat: function() {
    var v = this.getVec3();
    var xHat = [1,0,0];
    
    return TentaGL.Math.getQuatFromTo(xHat, v);
  },
  
  
  //////// Distance
  
  /** 
   * Returns the distance of a point to this line.
   * @param {vec4} pt
   * @return {number}
   */
  distToPt: function(pt) {
    var u = this.getVec3();
    var v = vec3.sub(vec3.create(), pt, this._p1);
    var w = vec3.sub(vec3.create(), pt, this._p2);
    
    if(vec3.dot(u, v) <= 0) {
      return vec3.len(v);
    }
    else if(vec3.dot(u, w) >= 0) {
      return vec3.len(w);
    }
    else {
      var uHat = vec3.normalize(vec3.create(), u);
      var vHat = vec3.normalize(vec3.create(), v);
      var cross = vec3.cross(vec3.create(), uHat, vHat);
      
      return vec3.len(v)*vec3.len(cross);
    }
  },
  
  
  /** 
   * Returns the distance between this line and another line. 
   * // TODO: account for segment distance. Currently, it assumes each line is infinite in length.
   * @param {TentaGL.Math.Line3D} line
   * @return {number}
   */
  distToLine: function(line) {
    var p = vec4.clone(this._p1); // p' = p + r*u
    var u = this.getVec3();
    
    var q = vec4.clone(line._p1); // q' = q + s*v
    q[3] = 1;
    var v = line.getVec3();
    
    // To make this problem easier to solve, we will transform our system such 
    // that p is at the origin and u = [1, 0, 0].
    var rotateQ = TentaGL.Math.getQuatFromTo(u, [1,0,0]);
    var rotate = mat4.fromQuat(mat4.create(), rotateQ);
    
    var trans = mat4.create();
    mat4.translate(trans, trans, [-p[0], -p[1], -p[2]]);
    
    var scale = mat4.create();
    mat4.scale(scale, scale, 1/vec3.length(u));
    
    var m = mat4.mul(mat4.create(), rotate, trans);
    mat4.mul(m, scale, m);
    
    var qq = vec4.transformMat4(vec4.create(), q, m); // qq' = qq + s*vv
    var vv = vec3.transformMat4(vec3.create(), v, m);
    
    // Next, we apply some calculus and linear algebra to solve a system of 
    // differential equations...
    // We'll figure out the parametric values for the two closest points in the 
    // transformed system. Which we can then use to calculate the distance back
    // in our original system.
    // How I figured this out is left as an excercise for other math nerds.
    var m = mat2.create();
    m[0] = vv[0]*vv[0] + vv[1]*vv[1] + vv[2]*vv[2];
    m[1] = vv[0];
    m[2] = vv[0];
    m[3] = 1;
    
    var t = vec2.fromValues(-vec3.dot(qq, vv), -qq[0]);
    var sr = vec2.transformMat2(vec2.create(), mat2.invert(m,m), t);
    
    var ppp = vec3.add(vec3.create(), p, vec3.scale(vec3.create(), u, sr[1]));
    var qqq = vec3.add(vec3.create(), q, vec3.scale(vec3.create(), v, sr[0]));
    
    return vec3.dist(ppp, qqq);
  },
  
  
  // Rendering
  
  render: function(gl, materialName) {
    var p1 = vec3.clone(this._p1);
    var p2 = vec3.clone(this._p2);
    var v = this.getVec3();
    
    TentaGL.ViewTrans.push(gl);
    
    TentaGL.ViewTrans.translate(gl, p1);
    TentaGL.ViewTrans.scale(gl, v);
    
    TentaGL.ViewTrans.updateMVPUniforms(gl);
    
    if(materialName) {
      TentaGL.MaterialLib.use(gl, materialName);
    }
    TentaGL.ModelLib.render(gl, "unitLine");
    
    TentaGL.ViewTrans.pop(gl);
  }
  
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A mathematical 3D infinite plane object.
 * @param {vec3} normal   The non-zero vector normal to the plane.
 * @param {vec3} pt      Optional. The anchor point the plane passes through. 
 *      Default: [0,0,0]
 */
TentaGL.Math.Plane = function(normal, pt) {
  if(!pt) {
    pt = [0,0,0];
  }
  
  this._normal = vec3.clone(normal);
  this._nHat = vec3.normalize(vec3.create(), this._normal);
  this._pt = vec3.clone(pt);
};


TentaGL.Math.Plane.prototype = {
  constructor: TentaGL.Math.Plane,
  
  isaInfinitePlane: true,
  
  /** 
   * Returns the plane's normal vector. 
   * @return {vec3}
   */
  getNormal: function() {
    return this._normal;
  },
  
  
  /** 
   * Returns the plane's unit normal vector. 
   * @return {vec3}
   */
  getUnitNormal: function() {
    return this._nHat;
  },
  
  
  /** 
   * Returns the anchor point the plane passes through. 
   * @return {vec3}
   */
  getPoint: function() {
    return this._pt;
  },
  
  
  /** 
   * Returns the distance of a point to this plane. 
   * @param {vec3} pt
   * @return number
   */
  distToPt: function(pt) {
    var w = vec3.sub(vec3.create(), pt, this._pt);
    var wLen = vec3.len(w);
    if(wLen == 0) {
      return 0;
    }
    
    var wHat = vec3.normalize(vec3.create(), w);
    var dot = vec3.dot(wHat, this._nHat);
    
    return Math.abs(wLen*dot);
  },
  
  
  /** 
   * Returns the coefficients a, b, c, and d that describe this plane in the 
   * standard equation for a plane: ax + by + cz + d = 0.
   * @return {array: [number, number, number, number]}
   */
  getCoefficients: function() {
    var a = this._normal[0];
    var b = this._normal[1];
    var c = this._normal[2];
    
    var x = this._pt[0];
    var y = this._pt[1];
    var z = this._pt[2];
    
    var d = -a*x - b*y - c*z;
    
    return [a, b, c, d];
  },
  
  
  /** 
   * Returns a vector that is parallel to the plane. 
   * @return {vec3}
   */
  getParallelVector: function() {
    var p1 = this._pt;
    var p2;
    if(this._normal[0] == 0) {
      p2 = [p1[0] + 1, p1[1], p1[2]];
    }
    else if(this._normal[1] == 0) {
      p2 = [p1[0], p1[1] + 1, p1[2]];
    }
    else if(this._normal[2] == 0) {
      p2 = [p1[0], p1[1], p1[2] + 1];
    }
    else {
      var coeffs = this.getCoefficients();
      
      var x = p1[0]+1;
      var y = 0;
      var z = (-coeffs[0]*x-coeffs[3])/coeffs[2];
      
      p2 = [x, y, z];
    }
    
    return vec3.sub(vec3.create(), p2, p1);
  },
  
  
  /** 
   * Determines if this plane contains the specified point.
   * A point is contained by the plane if its distance to the plane is within
   * some tolerance close to 0.
   * @param {vec3} pt
   * @param {ufloat) tolerance  Optional. Default 0.
   * @return {boolean}
   */
  containsPt: function(pt, tolerance) {
    if(!tolerance) {
      tolerance = 0;
    }
    
    var c = this.getCoefficients();
    var result = c[0]*pt[0] + c[1]*pt[1] + c[2]*pt[2] + c[3];
    
    return (Math.abs(result) < tolerance);
  },
  
  
  
  /** 
   * Returns an indicator for the position of a point relative to this plane.  
   * 1 indicates that the point lies above the plane in the direction of its
   * normal vector. -1 indicates that the point lies below the plane in the 
   * direction of its inverse normal vector. 0 indicates that the 
   * point lies on the plane, but is prone to rounding error.
   * @param {vec3} pt
   * @return {int}
   */
  ptRelative: function(pt) {
    var u = vec3.sub(vec3.create(), pt, this._pt);
    vec3.normalize(u, u);
    
    var dot = vec3.dot(this._nHat, u);
    
    if(dot > 0) {
      return 1;
    }
    else if(dot < 0) {
      return -1;
    }
    else {
      return 0;
    }
  },
  
  /** 
   * Tests if a point lies above the plane in the direction 
   * of its normal vector.
   * @param {vec3} pt
   * @return {boolean}
   */
  ptIsAbove: function(pt) {
    return (ptRelative(pt) == 1);
  },
  
  /** 
   * Tests if a point lies below the plane in the direction 
   * of its inverse normal vector.
   * @param {vec3} pt
   * @return {boolean}
   */
  ptIsBelow: function(pt) {
    return (ptRelative(pt) == -1);
  },
  
  
  /** 
   * Determines the intersection of a line with this plane. There are 3 possible
   * returned values: A point (vec3} if the line intersects the plane at a
   * single point (the most common case), the line if the line lies in the
   * plane, or undefined if the line is parallel to the plane but not in it.
   * See http://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection
   * @param {TentaGL.Math.Line3D} line
   * @return {vec3, TentaGL.Math.Line3D, or undefined}
   */
  lineIntersection: function(line) {
    var q = this.getPoint();
    var p = line.getPt1();
    
    var n = this.getNormal();
    var u = line.getVec3();
    
    var numer = vec3.dot(n, vec3.sub(vec3.create(), q, p));
    var denom = vec3.dot(n, u);
    
    if(denom == 0) {
      if(numer == 0) {
        return line;
      }
      else {
        return undefined;
      }
    }
    else {
      var s = numer/denom;
      
      var x = p[0] + s*u[0];
      var y = p[1] + s*u[1];
      var z = p[2] + s*u[2];
      
      return vec4.fromValues(x, y, z, 1);
    }
  }
  
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A mathematical sphere object.
 * @param {ufloat} radius   The sphere's radius
 * @param {vec3} pt         Optional. The point of the sphere's center.
 *      Default: [0,0,0]
 */
TentaGL.Math.Sphere = function(radius, pt) {
  if(!pt) {
    pt = [0,0,0];
  }

  this._pt = vec3.clone(pt);
  this._radius = radius;
};

TentaGL.Math.Sphere.prototype = {
  
  constructor: TentaGL.Math.Sphere,
  
  isaSphere: true,
  
  
  /** 
   * Creates a clone of this sphere.
   * @return {TentaGL.Math.Sphere}
   */
  clone: function() {
    return new TentaGL.Math.Sphere(this._radius, this._pt);
  },
  
  
  
  /** 
   * Returns the radius of the sphere. 
   * @return {ufloat}
   */
  getRadius: function() {
    return this._radius;
  },
  
  /** 
   * Returns the sphere's central point. 
   * @return {vec3}
   */
  getPoint: function() {
    return this._pt;
  },
  
  
  //////// Distance
  
  /** 
   * Returns the distance from the sphere's surface to some point. 
   * @param {vec3} pt
   * @return {number}
   */
  distToPt: function(pt) {
    var v = vec3.sub(vec3.create(), pt, this._pt);
    return Math.abs(vec3.len(v) - this._radius);
  },
  
  
  
  //////// Intersection
  
  
  /** 
   * Determines if a point lies within this sphere's volume.
   * @param {vec3} pt
   * @return {boolean}
   */
  containsPt: function(pt) {
    var v = vec3.sub(vec3.create(), pt, this._pt);
    return (vec3.len(v) <= this._radius);
  },
  
  
  /** 
   * Determines if the surface area of the sphere contains a point within some 
   * tolerance for distance, close to 0.
   * @param {vec3} pt
   * @param {ufloat} tolerance  Optional. Default 0.
   * @return {boolean}
   */
  surfaceContainsPt: function(pt, tolerance) {
    if(!tolerance) {
      tolerance = 0;
    }
    
    var v = vec3.sub(vec3.create(), pt, this._pt);
    var dist = Math.abs(vec3.len(v) - this._radius);
    return (dist <= tolerance);
  },
  
  
  /** 
   * Determines whether the volume of this sphere intersects with the volume 
   * of another sphere. 
   * @param {TentaGL.Math.Sphere} sphere
   * @return {boolean}
   */
  intersectsSphere: function(sphere) {
    var sqDist = vec3.sqrDist(this._pt, sphere._pt);
    var sqSum = this._radius + sphere._radius;
    sqSum *= sqSum;
    return (sqDist <= sqSum);
  },
  
  
  /** 
   * Determines whether the volume of this sphere intersects with an infinite 
   * plane. 
   * @param {TentaGL.Math.Plane} plane
   * @return {boolean}
   */
  intersectsPlane: function(plane) {
    var centerDist = plane.distToPt(this._pt);
    return (centerDist <= this._radius);
  },
  
  
  ////// Rendering
  
  
  /** 
   * Renders this sphere into the scene. 
   * @param {WebGLRenderingContext} gl
   * @param {string} materialName
   */
  render: function(gl, materialName) {
    var pt = vec3.clone(this._pt);
    var r = this._radius;
    
    TentaGL.ViewTrans.push(gl);
    
    var m = mat4.create();
    mat4.translate(m, m, pt);
    mat4.scale(m, m, [r, r, r]);
    
    TentaGL.ViewTrans.mul(gl, m);
    TentaGL.ViewTrans.updateMVPUniforms(gl);
    
    if(materialName) {
      TentaGL.MaterialLib.use(gl, materialName);
    }
    TentaGL.ModelLib.render(gl, "unitSphere");
    
    TentaGL.ViewTrans.pop(gl);
  }
  
  
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A TentaGL application. This helps set up many things expected from 
 * applications produced with TentaGL so that the user only needs to implement
 * their own application logic for the functions that initialize their 
 * app's data and run an iteration of its update loop.
 * @constructor
 * @param {DOM div element} container   An empty div element to contain the
 *      application and its Canvas.
 */
TentaGL.Application = function(container, attrs) {
  console.log("TentaGL version " + TentaGL.versionMajor + "." + TentaGL.versionMinor);
  
  this._container = container;
  var canvas = TentaGL.createCanvas(container);
  this._gl = TentaGL.createGL(canvas, attrs);
  this._canvas = this._gl.canvas;
  
  this._keyboard = new TentaGL.Keyboard(container);
  this._mouse = new TentaGL.Mouse(canvas);
  this._picker = new TentaGL.Picker(this);
  
  container.onresize = function() {
    console.log(container.offsetWidth, container.offsetHeight);
  };
  
  this._resizeListeners = [];
};


TentaGL.Application.prototype = {
  
  construct:TentaGL.Application, 
  
  /** Starts the application loop. */
  start:function() {
    this.initResources();
    this.run(0);
  },
  
  /** Cleans and initializes the application's shaders, materials, and models. */
  initResources:function() {
    var gl = this.getGL();
    
    TentaGL.ShaderLib.reset(gl);
    TentaGL.ModelLib.reset(gl);
    TentaGL.MaterialLib.reset(gl);
    
    this.initShaders();
    this.initMaterials();
    this.initModels();
    
    this.reset();
  },
  
  
  /** 
   * Runs an iteration of the application loop and then schedules the next 
   * iteration so that the application tries to run at 60 frames per second. 
   */
  run:function(timestamp) {
    this._isRunning = true;
    
    // Check for any scheduled conditions that would exit the update loop.
    if(this._tryEndApp() || this._tryResetApp() || this.isPaused()) {
      return;
    }
    
    
    // Initialize timing on the first frame.
    if(!this._lastTimestamp) {
      this._lastTimestamp = timestamp;
      this._lastFPSTimestamp = timestamp;
      this._fpsCount = 0;
    }
    
    // FPS counter
    if(timestamp - this._lastFPSTimestamp > 1000) {
      console.log("running. FPS: " + this._fpsCount);
      this._lastFPSTimestamp = timestamp;
      this._fpsCount = 0;
    }
    
    // Reset the GL states for this iteration.
    var gl = this.getGL();
    TentaGL.ViewTrans.reset(gl);
    TentaGL.SceneNode.resetRenderFilter();
    
    // Poll the input devices.
    this._keyboard.poll();
    this._mouse.poll();
    
    // Run an iteration of the application logic.
    this.update();
    
    this._lastTimestamp = timestamp;
    this._fpsCount++;
    
    this._nextFrameID = requestAnimationFrame(this.run.bind(this));
  },
  
  
  /** 
   * Checks if the application is scheduled to end. 
   * @return {boolean} true iff it is scheduled to end.
   */
  _tryEndApp: function() {
    if(this._endFlag) {
      console.log("Ending application");
      
      this._endFlag = false;
      this._isRunning = false;
      
      return true;
    }
    else {
      return false;
    }
  },
  
  /** 
   * Checks if the application is scheduled to hard-reset. 
   * @return {boolean} true iff it is scheduled to hard-reset.
   */
  _tryResetApp: function() {
    if(this._hardResetFlag) {
      console.log("Reseting application");
      
      this._hardResetFlag = false;
      this.start();
      
      return true;
    }
    else {
      return false;
    }
  },
  
  /** 
   * Checks if the application is hard-paused.
   * @return {boolean} true iff it is hard-paused.
   */
  isPaused: function() {
    return this._isPaused;
  },
  
  
  
  /** Returns true if the application is currently running. */
  isRunning:function() {
    return this._isRunning;
  },
  
  
  
  /** 
   * Schedules this application to end at the start of the next frame. 
   */
  end:function() {
    this._endFlag = true;
  },
  
  
  /**
   * Schedules this application to end and then restart at the start of the next frame.
   */
  hardReset:function() {
    this._hardResetFlag = true;
  },
  
  
  /** 
   * Sets whether the application is hard-paused. While the application is 
   * hard-paused, it will not execute any iterations of the update loop until 
   * it is unpaused.
   * @param {boolean} paused
   */
  setPaused:function(paused) {
    if(paused) {
      this._isPaused = true;
    }
    else if(this._isPaused) {
      this._isPaused = false;
      
      if(this._isRunning) {
        this.run(0);
      }
    }
  },
  
  //////// DOM and context
  
  /** 
   * Returns the div element containing the application.
   * @return {DOM div element}
   */
  getContainer:function() {
    return this._container;
  },
  
    
  /** 
   * Returns the Canvas for this applicaiton.
   * @return {DOM Canvas element}
   */
  getCanvas:function() {
    return this._canvas;
  },
  
  
  /** 
   * Returns the WebGLContext for this application. 
   * @return {WebGLContext}
   */
  getGL:function() {
    return this._gl;
  },
  
  //////// Picker
  
  
  /** 
   * Returns the applicaiton's picker.
   * @return {TentaGL.Picker}
   */
  getPicker:function() {
    return this._picker;
  },
  
  
  
  //////// Dimensions
  
  
  /** 
   * Returns the width of the application container.
   * @return {Number}
   */
  getWidth:function() {
    return this._canvas.offsetWidth;
  },
  
  /**
   * Returns the height of the application container.  
   * @return {Number}
   */
  getHeight:function() {
    return this._canvas.offsetHeight;
  },
  
  /**
   * Returns the aspect ratio of the application containter.
   * @return {Number}
   */
  getAspectRatio:function() {
    return this.getWidth()/this.getHeight();
  },
  
  
  /** 
   * Resizes the TentaGL application. 
   * This changes the size of the canvas and div elements containing it.
   * When the application is resized, it fires an AppResizeEvent to any 
   * AppResizeListeners subscribed to it.
   * @param {uint} w  The new width.
   * @param {uint} h  The new height.
   */
  resize:function(w, h) {
    var canvas = this.getCanvas();
    var container = this.getContainer();
    
    var oldWidth = this.getWidth();
    var oldHeight = this.getHeight();
    
    canvas.width = w;
    canvas.height = h;
    TentaGL.Viewport.set(this.getGL(), [0,0,w,h]);
    
    container.style.width = w;
    container.style.height = h;
    
    var event = new TentaGL.AppResizeEvent(this, w, h, oldWidth, oldHeight);
    for(var i in this._resizeListeners) {
      this._resizeListeners[i].handleAppResizeEvent(event);
    }
  },
  
  
  /** 
   * Subscribes an AppResizeListener to this application.
   * @param {AppResizeListener} listener
   */
  addAppResizeListener:function(listener) {
    this._resizeListeners.push(listener);
  },
  
  
  /** 
   * Unsubscribes an AppResizeListener from this application.
   * @param {AppResizeListener} listener
   */
  removeAppResizeListener:function(listener) {
    var index = this._resizeListeners.indexOf(listener);
    if(index == -1) {
      throw new Error("Failed to unsubscribe AppResizeListener.");
    }
    else {
      this._resizeListeners.splice(index, 1);
    }
  },
  
  
  //////// Access to input device interfaces.
  
  /** 
   * Returns the keyboard input object for the application.
   * @return {TentaGL.Keyboard}
   */
  keyboard:function() {
    return this._keyboard;
  },
  
  
  /**
   * Returns the mouse input object for the application.
   * @return {TentaGL.Mouse}
   */
  mouse:function() {
    return this._mouse;
  },
  
  
  //////// Things the user is expected to override.
  
  /** 
   * Initializes shaders for the application. 
   * Override this. 
   */
  initShaders:function() {},
  
  /** 
   * Initializes materials for the application. 
   * Override this. 
   */
  initMaterials:function() {},
  
  /** 
   * Initializes models for the application. 
   * Override this. 
   */
  initModels:function() {},
  
  /** 
   * Sets any other initial state of the application after other resources 
   * have been initialized. 
   * Override this.
   */
  reset:function() {},
  
  /** 
   * Runs an iteration of the application loop and renders the application. 
   * Override this. 
   */
  update:function() {}
  
  
  
};



/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Abstraction for a layer of model-control update and view rendering logic 
 * for an Application. This can be thought of as a "level" in the computer 
 * game sense of the word, or as some logical interface in a more serious
 * application. It is also possible to nest levels within levels.
 * @constructor
 * @param {TentaGL.Application} app   The application this level is running in.
 *      Through the app, the developer can access various parts of the 
 *      application state, such as the GL context and mouse and keyboard input.
 */
TentaGL.Level = function(app) {
  this._app = app;
};

TentaGL.Level.prototype = {
  
  constructor:TentaGL.Level, 
  
  isaLevel: true,
  
  //////// Application state access
  
  /** 
   * Returns the Application this level is part of. 
   * @return {TentaGL.Application}
   */
  getApp:function() {
    return this._app;
  },
  
  /** 
   * Returns the app's Keyboard input object. 
   * @return {TentaGL.Keyboard}
   */
  keyboard:function() {
    return this._app.keyboard();
  },
  
  /** 
   * Returns the app's Mouse input object.
   * @return {TentaGL.Mouse}
   */
  mouse:function() {
    return this._app.mouse();
  },
  
  
  //////// Abstract level methods
  
  /** 
   * Cleans up the level's state when we are done with it. 
   * If GL memory resources were created only for this level, they should also
   * be freed here.
   * Override this.
   * @param {WebGLRenderingContext} gl
   */
  clean:function(gl) {},
  
  
  /** 
   * Resets the level's state and loads any special resources used only by this
   * level. 
   * Override this.
   * @param {WebGLRenderingContext} gl
   */
  reset:function(gl) {},
  
  
  
  /** 
   * Performs an iteration through the level's update loop. 
   * Override this.
   * @param {WebGLRenderingContext} gl
   */
  update:function(gl) {},
  
  
  /** 
   * Performs an iteration through the level's render loop. 
   * Override this.
   * @param {WebGLRenderingContext} gl
   */
  render:function(gl) {}
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An API for fetching and loading audios. 
 * TODO: There are sometimes issues with loading the audio due to browser 
 * compatibility. I'm still looking for some way to universally call the 
 * success callback once its loaded.
 */
TentaGL.AudioLoader = {
  
  _numLoading: 0,
  
  
  /** 
   * Fetches and loads an audio from a URL.
   * @param {string} url    The URL path to the audio file.
   * @param {function(audio: Audio) : undefined} successCB    Callback for when the audio is successfully loaded.
   * @param {function() : undefined} errorCB    Optional. Callback for when there is an error loading the audio.
   */
  load: function(url, successCB, errorCB) {
    var self = this;
    this._numLoading++;
    
    if(!errorCB) {
      errorCB = function() {
        self._numLoading--;
        throw new Error("Could not load image at " + url + ".");
      }
    }
    
    var audio = new Audio();
    audio.oncanplaythrough = function() {
      successCB(audio);
      self._numLoading--;
    };
    audio.src = url;
    audio.load();
  },
  
  
  /** 
   * Returns true iff the AudioLoader is still loading 1 or more audios. 
   * @return {boolean}
   */
  isLoading: function() {
    return (this._numLoading > 0);
  }
  
  
  
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A camera for providing a view and perspective transform to a scene.
 * @constructor
 */
TentaGL.Camera = function() {};



TentaGL.Camera.prototype = {
  constructor:TentaGL.Camera,
  
  
  //////// Camera transforms
  
  /** 
   * Returns the projection-view matrix for this camera. 
   * @param {Number} aspect   The aspect ratio of our viewport.
   * @return {mat4} The projection-view transform matrix.
   */
  getTransform:function(aspect) {
    return mat4.mul(mat4.create(), this.getProjectionTransform(aspect), this.getViewTransform());
  },
  
  
  /** 
   * Returns the view matrix for this camera. 
   * Override this.
   * @return {mat4}
   */
  getViewTransform:function() {
    return mat4.create();
  },
  
  /** 
   * Returns the projection matrix for this camera.
   * Override this.
   * @param {Number} aspect   The aspect ratio of our viewport.
   * @return {mat4}
   */
  getProjectionTransform:function(aspect) {
    return mat4.create();
  }
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A camera for rendering in a classic 2D space, where the upper-left corner is
 * at (0,0), positive X is right, and positive Y is down.
 * Because this camera is meant for 2D rendering, there is no transform for
 * perspective. However, it does have the ability to pan in the XY plane, 
 * zoom in and out of the scene, and rotate the scene around the Z axis.
 * @constructor
 * @param {vec2} eye  The position of the camera's eye in world coordinates. 
 *      By default, the eye's screen location is in the center of the viewport.
 * @param {uint} width    The pixel width of the camera's resolution.
 * @param {uint} height   The pixel height of the camera's resolution.
 * @param {boolean} yFlipped  Whether the positive y-axis is in the down direction. Default true.
 */
TentaGL.Camera2D = function(eye, width, height, yFlipped) {
  if(yFlipped == undefined) {
    yFlipped = true;
  }
  this._yFlipped = yFlipped;
  
  var ex = eye[0];
  var ey = eye[1];
  this._eye = vec2.fromValues(ex, ey);
  
  this._width = width;
  this._height = height;
  
  // By default, the anchor is located in the center of the viewport.
  this._anchor = vec2.fromValues(Math.floor(this._width/2), Math.floor(this._height/2));
  
  this._angle = 0.0;
  this._zoom = 1.0;
};


TentaGL.Camera2D.prototype = {
  
  constructor: TentaGL.Camera2D,
  
  
  //////// Eye position
  
  /** 
   * Returns the position of the camera's eye. This is camera's position in world space.
   * @return {vec2}
   */
  getEye:function() {
    return vec2.clone(this._eye);
  },
  
  
  /** 
   * Returns the X coordinate of the camera's eye. 
   * @return {Number}
   */
  getX:function() {
    return this._eye[0];
  },
  
  /** 
   * Returns the Y coordinate of the camera's eye. 
   * @return {Number}
   */
  getY:function() {
    return this._eye[1];
  },
  
  
  /**
   * Sets the position of the camera's eye in world space.
   * @param {vec2} eye
   */
  setEye:function(eye) {
    this._eye = vec2.fromValues(eye[0], eye[1]);
  },
  
  
  //////// View resolution
  
  /** 
   * Returns the width (in pixels) of the camera's resolution. 
   * @return {uint}
   */
  getWidth:function() {
    return this._width;
  },
  
  
  /** 
   * Returns the height (in pixels of the camera's resolution.
   * @return {uint}
   */
  getHeight:function() {
    return this._height;
  },
  
  //////// Anchor position
  
  /** 
   * Returns the camera's anchor position - the position of its eye in 
   * viewport coordinates. 
   * @return {vec2}
   */
  getAnchor:function() {
    return this._anchor;
  },
  
  
  /** 
   * Sets the camera's anchor position. 
   * @param {vec2} anchor
   */
  setAnchor:function(anchor) {
    this._anchor = vec2.fromValues(anchor[0], anchor[1]);
  },
  
  
  /** 
   * Sets the camera's anchor position such that the camera's transform is 
   * unchanged. I.E., the camera appears to be at the same position.
   * @param {vec2} anchor
   */
  moveAnchor: function(anchor) {
    var df = [anchor[0] - this._anchor[0], anchor[1] - this._anchor[1]];
    
    var rsTransInv = mat4.invert(mat4.create(), this._getRotateScaleTransform());
    dfWorld = vec2.transformMat4(vec2.create(), df, rsTransInv);
    
    this._eye[0] += dfWorld[0];
    this._eye[1] += dfWorld[1];
    
    this._anchor[0] = anchor[0];
    this._anchor[1] = anchor[1];
  },
  
  
  //////// Angle
  
  
  /** 
   * Returns the clockwise rotation angle of the camera, in radians. 
   * @return {Number}
   */
  getAngle:function() {
    return this._angle;
  },
  
  
  /** 
   * Sets the camera's clockwise rotation angle, in radians.
   * @param {Number} rads
   */
  setAngle:function(rads) {
    this._angle = rads;
  },
  
  
  
  //////// Zoom
  
  /** 
   * Returns the zoom of the camera.
   * @return {Number}
   */
  getZoom:function() {
    return this._zoom;
  },
  
  /** 
   * Sets the zoom of the camera. 
   * The default zoom level is 1.0.
   * The scene zooms in as zoom approaches positive infinity.
   * The scene zooms out as zoom approaches 0.
   * @param {Number} zoom
   */
  setZoom:function(zoom) {
    this._zoom = zoom;
  },
  
  
  //////// controls
  
  
  
  controlWithMouse:function(mouse, viewWidth, viewHeight) {
    var mouseX = mouse.getX()*this.getWidth()/viewWidth;
    var mouseY = mouse.getY()*this.getHeight()/viewHeight;
    if(!this._yFlipped) {
      mouseY = this.getHeight() - mouseY;
    }
    
    // Zoom in by scrolling the mouse wheel up.
    if(mouse.scrollUpAmount() > 0) {
      this.moveAnchor([mouseX, mouseY]);
      for(var i = 0; i < mouse.scrollUpAmount(); i++) {
        this.setZoom(this.getZoom() * 10/9);
      }
    }
    
    // Zoom out by scrolling the mouse wheel down.
    if(mouse.scrollDownAmount() > 0) {
      this.moveAnchor([mouseX, mouseY]);
      for(var i = 0; i < mouse.scrollDownAmount(); i++) {
        this.setZoom(this.getZoom() * 9/10);
      }
    }
    
    // Pan the camera by left-dragging the mouse.
    if(mouse.isLeftPressed()) {
      this.drag(mouse.getXY(), viewWidth, viewHeight);
    }
    if(mouse.justLeftReleased()) {
      this.endDrag();
    }
  },
  
  
  /** 
   * Pans the camera with a dragging motion. 
   * @param {vec2} screenPt   The point of the thing dragging the camera, in 
   *      screen coordinates. Most likely the mouse.
   * @param {int} viewWidth   The width of the viewport.
   * @param {int} viewHeight  The height of the viewport.
   */
  drag: function(screenPt, viewWidth, viewHeight) {
    if(!this._yFlipped) {
      screenPt[1] = viewHeight - screenPt[1];
    }
    
    if(!this._dragPrev) {
      this._updatePrevDragPt(screenPt, viewWidth, viewHeight);
    }
    
    var worldPt = this.screenToWorld(screenPt, viewWidth, viewHeight);
    var dragX = this._dragPrev[0] - worldPt[0];
    var dragY = this._dragPrev[1] - worldPt[1];
    
    this._eye[0] = this._dragEyeStart[0] + dragX;
    this._eye[1] = this._dragEyeStart[1] + dragY;
    
    var anchorX = screenPt[0]*this.getWidth()/viewWidth;
    var anchorY = screenPt[1]*this.getHeight()/viewHeight;
    this.moveAnchor([anchorX, anchorY]);
    
    this._updatePrevDragPt(screenPt, viewWidth, viewHeight);
  },
  
  
  /** 
   * Updates the previous drag state. 
   * @param {vec2} screenPt   The point of the thing dragging the camera, in 
   *      screen coordinates. Most likely the mouse.
   * @param {int} viewWidth   The width of the viewport.
   * @param {int} viewHeight  The height of the viewport.
   */
  _updatePrevDragPt: function(screenPt, viewWidth, viewHeight) {
    var worldPt = this.screenToWorld(screenPt, viewWidth, viewHeight);
    this._dragPrev = worldPt;
    this._dragEyeStart = vec2.clone(this._eye);
  },
  
  
  /** 
   * Causes the camera drag to end.
   */
  endDrag: function() {
    this._dragPrev = undefined;
    this._dragEyeStart = undefined;
  },
  
  //////// Transforms
  
  
  /** 
   * Returns only the Rotate x Scale part of the view transform matrix.
   * @return {mat4}
   */
  _getRotateScaleTransform: function() {
    var m = mat4.create();
    
    var rotT = mat4.create();
    mat4.rotateZ(rotT, rotT, this._angle);
    mat4.mul(m, rotT, m);
    
    var zoomT = mat4.create();
    mat4.scale(zoomT, zoomT, [this._zoom, this._zoom, 1]);
    mat4.mul(m, zoomT, m);
    
    return m;
  },
  
  
  /** 
   * Returns the view matrix for this camera. 
   * @return {mat4}
   */
  getViewTransform:function() {
    var m = mat4.create();
    
    var eyeT = mat4.create();
    mat4.translate(eyeT, eyeT, [-this._eye[0], -this._eye[1], 0]);
    mat4.mul(m, eyeT, m);
    
    var rsT = this._getRotateScaleTransform();
    mat4.mul(m, rsT, m);
    
    var anchorT = mat4.create();
    mat4.translate(anchorT, anchorT, [this._anchor[0], this._anchor[1], 0]);
    mat4.mul(m, anchorT, m);
    
    return m;
  },
  
  
  
  /** 
   * Returns the projection matrix for this camera.
   * @return {mat4}
   */
  getProjectionTransform:function() {
    var m = mat4.create();
    m[0] = 2/this.getWidth();
    m[5] = 2/this.getHeight();
    m[12] = -1;
    
    if(this._yFlipped) {
      m[5] *= -1;
      m[13] = 1;
    }
    else {
      m[13] = -1;
    }
    return m;
  },
  
  
  
  
  /** 
   * Transforms a point from screen coordinates to world coordinates.
   * @param {vec2} screenPt   The point in view coordinates.
   * @param {int} viewWidth   The width of the viewport.
   * @param {int} viewHeight  The height of the viewport.
   * @return {vec2}
   */
  screenToWorld: function(screenPt, viewWidth, viewHeight) {
    var result = [screenPt[0], screenPt[1]];
    
    result[0] *= this.getWidth()/viewWidth;
    result[1] *= this.getHeight()/viewHeight;
    
    var viewInv = this.getViewTransform();
    mat4.invert(viewInv, viewInv);
    
    vec2.transformMat4(result, result, viewInv);
    return result;
  },
  
  
  /** 
   * Transform a point from world coordinates to screen coordinates.
   * @param {vec2} worldPt    The point in world coordinates.
   * @param {int} viewWidth   The width of the viewport.
   * @param {int} viewHeight  The height of the viewport.
   * @return {vec2}
   */
  worldToScreen: function(worldPt, viewWidth, viewHeight) {
    result = [worldPt[0], worldPt[1]];
    
    var viewTrans = this.getViewTransform();
    vec2.transformMat4(result, result, viewTrans);
    
    result[0] *= viewWidth/this.getWidth();
    result[1] *= viewHeight/this.getHeight();
    
    return result;
  }
};


Util.Inheritance.inherit(TentaGL.Camera2D, TentaGL.Camera);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs the camera, given the position of its eye, the center point 
 * (the point it is looking at), and the vector for which direction is "up". 
 * @constructor
 * @param {vec3} eye
 * @param {vec3} center   Optional. Default [0, 0, 0].
 * @param {vec3} up       Optional. Default [0, 1, 0].
 */
TentaGL.Camera3D = function(eye, center, up) {
  var ex = eye[0];
  var ey = eye[1];
  var ez = eye[2];
  this._eye = vec3.fromValues(ex, ey, ez);
  
  if(center === undefined) {
    center = [];
  }
  var cx = center[0] || 0;
  var cy = center[1] || 0;
  var cz = center[2] || 0;
  this._center = vec3.fromValues(cx, cy, cz);
  
  if(up === undefined) {
    up = [];
  }
  var ux = up[0] || 0;
  var uy = up[1] || 1;
  var uz = up[2] || 0;
  this._up = vec3.fromValues(ux, uy, uz);
  this._correctUpVector();
  
  this._mode = TentaGL.Camera3D.PERSP;
  this._fovBase = TentaGL.TAU/8;
  this._zoom = 1;
  this._znear = 1;
  this._zfar = 1000;
};


TentaGL.Camera3D.PERSP = 1; // Perspective
TentaGL.Camera3D.ORTHO = 2; // Orthographic


TentaGL.Camera3D.prototype = {
  constructor:TentaGL.Camera3D,
  
  
  /** 
   * Corrects the up vector so that it forms a right angle with the look vector
   * and so that it is a unit vector.
   */
  _correctUpVector:function() {
    var look = this.getLookVector();
    var right = vec3.cross(vec3.create(), look, this._up);
    vec3.cross(this._up, right, look);
    vec3.normalize(this._up, this._up);
  },
  
  
  ////// Eye location
  
  /** 
   * Returns a copy of the camera's eye position. 
   * @return {vec3}
   */
  getEye:function() {
    return vec3.clone(this._eye);
  },
  
  /** 
   * Sets the position of the camera's eye. 
   * @param {vec3} 
   */
  setEye:function(eye) {
    this._eye = vec3.fromValues(eye[0], eye[1], eye[2]);
    this._correctUpVector();
  },
  
  /** 
   * Returns the X position of the camera's eye. 
   * @return {Number}
   */
  getEyeX:function() {
    return this._eye[0];
  },
  
  /** 
   * Returns the Y position of the camera's eye. 
   * @return {Number}
   */
  getEyeY:function() {
    return this._eye[1];
  },
  
  /** 
   * Returns the Z position of the camera's eye. 
   * @return {Number}
   */
  getEyeZ:function() {
    return this._eye[2];
  },
  
  
  
  //////// Center location
  
  
  /**
   * Returns a copy of the camera's center position.
   * @return {vec3}
   */
  getCenter:function() {
    return vec3.clone(this._center);
  },
  
  /** 
   * Sets the position of the camera's center. 
   * @param {vec3} center
   */
  setCenter:function(center) {
    this._center = vec3.fromValues(center[0], center[1], center[2]);
    this._correctUpVector();
  },
  
  /**
   * Returns the X position of the camera's center.
   * @return {Number}
   */
  getCenterX:function() {
    return this._center[0];
  },
  
  /**
   * Returns the Y position of the camera's center.
   * @return {Number}
   */
  getCenterY:function() {
    return this._center[1];
  },
  
  /**
   * Returns the Z position of the camera's center.
   * @return {Number}
   */
  getCenterZ:function() {
    return this._center[2];
  },
  
  //////// "Look" vector
  
  
  /** 
   * Returns the unit vector pointing in the "look" direction of the view.
   * @return {vec3}
   */
  getLook:function() {
    var look = this.getLookVector();
    return vec3.normalize(look, look);
  },
  
  
  /** 
   * Gets the unnormalized vector from eye to center. 
   * @return {vec3}
   */
  getLookVector:function() {
    return vec3.sub(vec3.create(), this._center, this._eye);
  },
  
  
  /** 
   * Returns the distance of the eye from the center.
   * @return {Number}
   */
  getDist:function() {
    return vec3.length(this.getLookVector());
  },
  
  
  /** 
   * Sets the distance from the eye to the center by changing the eye's position
   * relative to the center. This does not change the orientation of the camera. 
   */
  setDist:function(dist) {
    var lookInv = this.getLookVector();
    vec3.negate(lookInv, lookInv);
    vec3.scale(lookInv, lookInv, dist/vec3.length(lookInv));
    
    vec3.add(this._eye, this._center, lookInv);
  },
  
  
  
  
  
  
  
  //////// "Up" vector
  
  /** 
   * Returns a copy of the camera's unit "up" vector.
   * @return {vec3}
   */
  getUp:function() {
    return vec3.clone(this._up);
  },
  
  /** 
   * Sets the camera's "up" vector. 
   * @param {vec3} up
   */
  setUp:function(up) {
    this._up = vec3.fromValues(up[0], up[1], up[2]);
    this._correctUpVector();
  },
  
  /**
   * Returns the X component of the camera's "up" vector.
   * @return {vec3}
   */
  getUpX:function() {
    return this._up[0];
  },
  
  /**
   * Returns the Y component of the camera's "up" vector.
   * @return {vec3}
   */
  getUpY:function() {
    return this._up[1];
  },
  
  /**
   * Returns the Z component of the camera's "up" vector.
   * @return {vec3}
   */
  getUpZ:function() {
    return this._up[2];
  },
  
  
  
  
  //////// "Right" vector
  
  
  /** 
   * Returns the unit vector pointing in the "right" direction of the view.
   * @return {vec3}
   */
  getRight:function() {
    var right = vec3.cross(vec3.create(), this.getLook(), this.getUp());
    vec3.normalize(right, right);
    return right;
  },
  
  
  
  //////// Perspective properties
  
  /**
   * Returns the camera's perspective mode.
   * @return {int} Either TentaGL.Camera3D.PERSP or TentaGL.Camera3D.ORTHO.
   */
  getMode:function() {
    return this._mode;
  },
  
  /** 
   * Sets the camera's perspective mode.
   * @param {int} mode  Either TentaGL.Camera3D.PERSP or TentaGL.Camera3D.ORTHO.
   */
  setMode:function(mode) {
    if(mode != TentaGL.Camera3D.PERSP && mode != TentaGL.Camera3D.ORTHO) {
      throw new Error("Mode " + mode + " not supported.");
    }
    this._mode = mode;
  },
  
  /** 
   * Gets the base field of view angle for the camera in radians. 
   * This is the camera's field of view angle when it is not zoomed in at all.
   */
  getFOVY:function() {
    return this._fovBase;
  },
  
  /** 
   * Sets the base field of view angle for the camera in radians.
   * @param {Number} angle
   */
  setFOVY:function(angle) {
    this._fovBase = angle;
  },
  
  /** 
   * Returns the zoomed field of view angle for the camera in radians. 
   * @return {Number}
   */
  getZoomedFOVY:function() {
    return this._fovBase*this._zoom;
  },
  
  /** 
   * Returns the camera's zoom level.
   * @return {Number}
   */
  getZoom:function() {
    return this._zoom;
  },
  
  /** 
   * Sets the camera's zoom level. The default level is 1.0. The camera becomes
   * more zoomed in as its zoom level approaches 0.
   * The new value must be in the range (0,1]. 
   */
  setZoom:function(zoom) {
    if(zoom <= 0 || zoom >1) {
      throw new Error("Invalid zoom value: " + zoom);
    }
    
    this._zoom = zoom;
  },
  
  /**
   * Returns the distance of the znear clipping plane to the camera.
   * @return {Number}
   */
  getZNear:function() {
    return this._znear;
  },
  
  /**
   * Returns the distance of the zfar clipping plane to the camera.
   * @return {Number}
   */
  getZFar:function() {
    return this._zfar;
  },
  
  /**
   * Sets the distances of the znear and zfar clipping planes to the camera.
   * znear must be > 0 and zfar must be > znear.
   */
  setClippingPlanes:function(znear, zfar) {
    if(znear <= 0 || zfar <= znear) {
      throw new Error("Invalid values for zNear and zFar planes: " + zNear + ", " + zFar);
    }
    this._znear = znear;
    this._zfar = zfar;
  },
  
  //////// Camera transforms
  
  /** 
   * Returns the projection-view matrix for this camera. 
   * @param {Number} aspect   The aspect ratio of our viewport.
   * @return {mat4} The projection-view transform matrix.
   */
  getTransform:function(aspect) {
    return mat4.mul(mat4.create(), this.getProjectionTransform(aspect), this.getViewTransform());
  },
  
  
  /** 
   * Returns the view matrix for this camera. 
   * @return {mat4}
   */
  getViewTransform:function() {
    return mat4.lookAt(mat4.create(), this._eye, this._center, this._up);
  },
  
  /** 
   * Returns the projection matrix for this camera.
   * @param {Number} aspect   The aspect ratio of our viewport.
   * @return {mat4}
   */
  getProjectionTransform:function(aspect) {
    if(this._mode == TentaGL.Camera3D.PERSP) {
      return mat4.perspective(mat4.create(), this.getZoomedFOVY(), aspect, 
                              this.getZNear(), this.getZFar());
    }
    else {
      return mat4.create();
    }
  },
  
  

  
  //////// Misc.
  
  
  /** 
   * Projects the mouse's XY coordinates (relative to its viewport) to the  
   * plane in world coordinates facing the camera's eye and intersecting the 
   * camera's center.
   * @param {length 2 int array} mouseXY  The XY coordinates of the mouse relative to 
   *      its viewport's upper-left corner.
   * @param {int} viewWidth   The width of the mouse's viewport.
   * @param {int} viewHeight  The height of the mouse's viewport.
   * @return {vec3} The XYZ coordinates of the mouse projected onto the panning plane.
   */
  projectMouseToPanningPlane:function(mouseXY, viewWidth, viewHeight) {
    
    // We need to transform our mouse coordinates to a normalized viewport 
    // coordinates system, also taking into account the aspect ratio and
    // inverting the Y axis.
    var aspect = viewWidth/viewHeight;
    var x = (mouseXY[0] - viewWidth/2)/aspect;
    var y = -1*(mouseXY[1] - viewHeight/2);
    var xy = vec3.fromValues(x,y,0);
    vec3.scale(xy, xy, 2/viewHeight);
    
    // Convert our transformed mouse coordinates to model-view coordinates by 
    // cancelling the perspective transform.
    xy[2] = 0-this._dist
    var projMat = this.getProjectionTransform(viewWidth/viewHeight);
    vec3.transformMat4(xy, xy, mat4.invert(mat4.create(), projMat));
    
    // Determine the position of the transformed mouse's model coordinates, 
    // relative to the camera's center, using our oriented up and right vectors.
    var up = this.getUp();
    var right = this.getRight();
    
    var tx = (xy[0]*right[0] + xy[1]*up[0])*this._dist + this._center[0];
    var ty = (xy[0]*right[1] + xy[1]*up[1])*this._dist + this._center[1];
    var tz = (xy[0]*right[2] + xy[1]*up[2])*this._dist + this._center[2];
    
    var planeCoords = vec3.fromValues(tx, ty, tz);
    return planeCoords;
  },
  
  
  /** 
   * Projects some point in viewport coordinates (Y axis is down) to a point on
   * some plane. 
   * @param {vec2} pt   The point in viewport coordinates.
   * @param {TentaGL.Math.Plane} plane    The plane we are projecting pt onto, 
   *      in world coordinates.
   * @param {uint} viewWidth    The width of the viewport.
   * @param {uint} viewHeight   The height of the viewport.
   * @return {vec3}
   */
  projectToPlane: function(pt, plane, viewWidth, viewHeight) {
    // First we need to convert pt to device projection coordinates.
    var aspect = viewWidth/viewHeight;
    var x = (pt[0] - viewWidth/2)/aspect;
    var y = -1*(pt[1] - viewHeight/2);
    var xy = vec3.fromValues(x,y,0);
    vec3.scale(xy, xy, 2/viewHeight);
    
    var pt = vec4.fromValues(xy[0], xy[1], -1, 1);
    
    // Convert our near and far points to world coordinates.
    var m = this.getTransform(aspect);
    mat4.invert(m, m);
    
    vec4.transformMat4(pt, pt, m);

    // Create a line between our transformed near and far points, then
    // find the intersection between the line and the plane.
    var line = new TentaGL.Math.Line3D(this._eye, pt);
    var intersection = plane.lineIntersection(line);
    
    if(intersection && !intersection.isaLine3D) {
      return intersection;
    }
    else {
      return undefined;
    }
  }
  
};


Util.Inheritance.inherit(TentaGL.Camera3D, TentaGL.Camera);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs an arcball camera. 
 * This implementation provides some very powerful features for exploring a
 * scene with the mouse. The scene can be rotated around in an arcball movement
 * by left-dragging, The scene can be panned by right-dragging, and the scene
 * can be zoomed in and out by scrolling the mouse wheel.
 */
TentaGL.ArcballCamera = function(eye, center, up) {
  TentaGL.Camera3D.call(this, eye, center, up);
  
  // Save initial distance.
  var look = this.getLookVector();
  this._origDist = vec3.length(look);
  this._dist = this._origDist;
  
  // Save our initial rotational transform with our eye at distance = 1 from the center.
  this._origLook = vec3.normalize(vec3.create(), look);
//  this._eye = vec3.sub(vec3.create(), this._center, this._origLook);
  
  // Save the initial center.
  this._origCenter = vec3.clone(this._center);
  
  // Save our orientation, as well as the initial up and right vectors of the camera.
  this._origUp = vec3.clone(this._up);
  this._origRight = vec3.cross(vec3.create(), this._origLook, this._origUp);
  
  this._orientation = TentaGL.Math.getOrientation([0,0,-1], [0,1,0], this._origLook, this._origUp);
  this._origOrientation = quat.clone(this._orientation);
};

TentaGL.ArcballCamera.prototype = {
  
  constructor:TentaGL.ArcballCamera,
  
  
  //////// Arcball sphere projection

  /** 
   * Converts mouse viewport coordinates to unit sphere coordinates. 
   * @param {length 2 int array} mouseXY  The XY coordinates of the mouse relative to 
   *      its viewport's upper-left corner.
   * @param {int} viewWidth   The width of the mouse's viewport.
   * @param {int} viewHeight  The height of the mouse's viewport.
   * @return {vec3} The XYZ coordinates of the mouse projected onto the unit 
   *      sphere's surface.
   */
  projectMouseToUnitSphere:function(mouseXY, viewWidth, viewHeight) {
    var r = Math.max(viewHeight, viewWidth)/2;
    var ir = 1/r;
    
    // Translate model so the origin is in the middle of the view. Also, flip the Y axis.
    var x = mouseXY[0] - viewWidth/2;
    var y = -1*(mouseXY[1] - viewHeight/2);
    
    // Scale our system to be projected on a unit sphere.
    var sphereCoords = vec3.fromValues(x, y, 0);
    sphereCoords = vec3.scale(sphereCoords, sphereCoords, ir);
    
    // If our transformed point is outside the sphere, normalize it so that it is
    // on the edge of the sphere.
    if(vec3.length(sphereCoords) > 1) {
      sphereCoords = vec3.normalize(sphereCoords, sphereCoords);
    }
    
    // Find the Z component of the sphere coords.
    var zSquare = 1-(sphereCoords[0]*sphereCoords[0] + sphereCoords[1]*sphereCoords[1]);
    if(zSquare < 0) {
      sphereCoords[2] = 0;
    }
    else {
      sphereCoords[2] = Math.sqrt(zSquare);
    }
    
    return sphereCoords;
  },



  //////// Eye position


  getEye:function() {
    var lookInv = this.getLook();
    vec3.negate(lookInv, lookInv);
    vec3.scale(lookInv, lookInv, this._dist);
    
    return vec3.add(this._eye, this._center, lookInv);
  },


  //////// Look, Up, Right vectors

  /** 
   * Returns the unit vector currently pointing in the "look" direction of the view.
   * For our arcball camera, this is calculated from the original look vector
   * and the orientation quaternion.
   * @return {vec3}
   */
  getLook:function() {
    var qMatInv = mat4.invert(mat4.create(), mat4.fromQuat(mat4.create(), quat.invert(quat.create(), this._orientation)));
    var look = vec3.transformMat4(vec3.create(), [0,0,-1], qMatInv);
    return vec3.normalize(look, look);
  },


  /** 
   * Returns the unit vector currently pointing in the "up" direction of the view.
   * For our arcball camera, this is calculated from the original up vector
   * and the orientation quaternion.
   * @return {vec3}
   */
  getUp:function() {
    var qMatInv = mat4.invert(mat4.create(), mat4.fromQuat(mat4.create(), quat.invert(quat.create(), this._orientation)));
    var up = vec3.transformMat4(vec3.create(), [0,1,0], qMatInv);
    vec3.normalize(up, up);
    return up;
  },

  /** 
   * Returns the unit vector currently pointing in the "right" direction of the view.
   * For our arcball camera, this is calculated from the original right vector
   * and the orientation quaternion.
   * @return {vec3}
   */
  getRight:function() {
    var qMatInv = mat4.invert(mat4.create(), mat4.fromQuat(mat4.create(), quat.invert(quat.create(), this._orientation)));
    var right = vec3.transformMat4(vec3.create(), [1,0,0], qMatInv);
    return vec3.normalize(right, right);
  },


  //////// Orientation


  /** 
   * Returns the quaternion for orienting the camera's look vector relative to the 
   * negative Z axis (the natural look direction of the camera).
   * @return {quat}
   */
  getOrientation:function() {
    return quat.clone(this._orientation);
  },


  /** 
   * Sets the quaternion for orienting the camera's look vector relative to the
   * negative Z axis (the natural look direction of the camera).
   */
  setOrientation:function(orientation) {
    this._orientation = orientation;
  },



  //////// Distance

  /** 
   * Returns the distance of the eye from the center.
   * @return {Number}
   */
  getDist:function() {
    return this._dist;
  },


  /** 
   * Sets the distance from the eye to the center without changing the 
   * orientation. 
   * @param {Number} dist
   */
  setDist:function(dist) {
    this._dist = dist;
  },





  //////// Controller

  /** 
   * Controls the arcball camera with the mouse using dragging gestures. 
   * Left-dragging rotates the scene around the center point.
   * Right-dragging pans the scene around the center point.
   * The mouse wheel zooms in and out of the scene.
   * @param {TentaGL.Mouse} mouse
   * @param {int} viewWidth   The width of the mouse's viewport.
   * @param {int} viewHeight  The height of the mouse's viewport.
   */
  controlWithMouse:function(mouse, viewWidth, viewHeight) {
    
    // Zoom in by scrolling the mouse wheel up.
    if(mouse.scrollUpAmount() > 0) {
      for(var i = 0; i < mouse.scrollUpAmount(); i++) {
        this.setDist(this.getDist() * 9/10);
      }
    }
    
    // Zoom out by scrolling the mouse wheel down.
    if(mouse.scrollDownAmount() > 0) {
      for(var i = 0; i < mouse.scrollDownAmount(); i++) {
        this.setDist(this.getDist() * 10/9);
      }
    }
    
    
    // Start arcball drag by saving starting arcball state.
    if(mouse.justLeftPressed()) {
      this._preVec = this.projectMouseToUnitSphere(mouse.getXY(), viewWidth, viewHeight);
      this._preOrientation = quat.clone(quat.invert(quat.create(), this._orientation));
    }
    
    // Rotate the arcball while the left mouse button is dragged.
    if(mouse.isLeftPressed() || mouse.justLeftReleased()) {
      var curVec = this.projectMouseToUnitSphere(mouse.getXY(), viewWidth, viewHeight);
      var q = TentaGL.Math.getQuatFromTo(this._preVec, curVec);
      
      quat.mul(this._orientation, q, this._preOrientation);
      quat.invert(this._orientation, this._orientation);
    }
    
    
    // Start panning by saving center state.
    if(mouse.justRightPressed()) {
      this._prePan = this.projectMouseToPanningPlane(mouse.getXY(), viewWidth, viewHeight);
      this._preCenter = vec3.clone(this._center);
    }
    
    // Pan the camera while the right mouse button is dragged.
    if(mouse.isRightPressed()) {
      this._center = vec3.clone(this._preCenter);
      this._curPan = this.projectMouseToPanningPlane(mouse.getXY(), viewWidth, viewHeight);
      
      var dPan = vec3.sub(vec3.create(), this._prePan, this._curPan);
      var tCenter = mat4.create();
      mat4.translate(tCenter, tCenter, dPan);
      
      vec3.transformMat4(this._center, this._preCenter, tCenter);
    }
  },



  /** 
   * Resets the camera to its original state. 
   */
  resetOrientation:function() {
    this._center = vec3.clone(this._origCenter);
    this._dist = this._origDist;
    this._orientation = quat.clone(this._origOrientation);
  },



  //////// Camera transforms


  /** 
   * Returns the view transform for the arcball camera. This accounts for 
   * rotation of the arcball, distance from the center point, and translation of
   * the center point from panning.
   */
  getViewTransform:function() {
    
    // Zoom translation (Z)
    var translate = mat4.create();
    mat4.translate(translate, translate, [0, 0, 0-this._dist]);
    
    // Arcball rotation (R)
    var m = mat4.mul(mat4.create(), translate, mat4.fromQuat(mat4.create(), quat.invert(quat.create(), this._orientation)));
    
    // Center point panning. (P)
    var centerTrans = mat4.create();
    mat4.translate(centerTrans, centerTrans, vec3.negate(vec3.create(), this._center));
    
    // M = Z*R*P
    m = mat4.mul(m, m, centerTrans);
    return m;
  }
};


Util.Inheritance.inherit(TentaGL.ArcballCamera, TentaGL.Camera3D);







/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a 3D picker for doing pixel-perfect mouse-over detections in
 * a scene.
 * @constructor
 * @param {TentaGL.Application} app   The application this picker is being used in.
 */
TentaGL.Picker = function(app) {
  this._app = app;
  this._bytes = new Uint8Array(4);
};

/** The ID of the picker's shader program in the ShaderLib. */
TentaGL.Picker.SHADER_ID = "pickShader";


TentaGL.Picker.prototype = {
  
  constructor:TentaGL.Picker,
  
  
  
  /** 
   * Updates the internal raster of mouse-over information of a scene for this picker.
   * @param {WebGLRenderingContext} gl
   * @param {function(WebGLRenderingContext)} renderFunc   
   *      The function used to render the scene.
   * @param {Boolean} renderToView  Optional. If true, the picker will render 
   *      to to the canvas as well as its offscreen buffer. This may be useful
   *      for debugging purposes. Default is false.
   */
  update:function(gl, renderFunc, renderToView) {
    var self = this;
    
    this._pixels = undefined;
    this._origFilter = TentaGL.SceneNode.getRenderFilter();
    var origShader = TentaGL.ShaderLib.currentName(gl);
    
    // Set up the GL state for picker rendering. 
    TentaGL.Blend.setEnabled(gl, false);
    TentaGL.Blend.lock(gl);
    
    TentaGL.ColorBuffer.setClearColor(gl, TentaGL.Color.RGBA(0, 0, 0, 0));
    TentaGL.ColorBuffer.lock(gl);
    
    TentaGL.MaterialLib.useNone(gl);
    
    TentaGL.ShaderLib.use(gl, TentaGL.Picker.SHADER_ID);
    TentaGL.ShaderLib.lock(gl);
    
    this._nextID = 1;
    this._sprites = [];
    
    this._gl = gl;
    TentaGL.SceneNode.setRenderFilter(this._filterFunction.bind(this));
    
    if(renderToView) {
      renderFunc(gl);
      TentaGL.MaterialLib.useNone(gl);
      this._nextID = 1;
    }
    
    // Update the size of the buffer used for picking, if necessary.
    var w = this._app.getWidth();
    var h = this._app.getHeight();
    var minSize = w*h*4;
    if(minSize > this._bytes.length) {
      this._bytes = new Uint8Array(minSize);
    }
    
    // Render to the offscreen raster, cache the pixel data, 
    // and then delete the offscreen raster.
    var raster = new TentaGL.BufferTexture(gl, w, h);
    raster.renderToMe(gl, renderFunc);
    this._pixels = raster.getPixelData(gl, 0, 0, w, h, this._bytes);
    raster.clean(gl);
    
    
    // Restore the previous state.
    TentaGL.ShaderLib.unlock(gl);
    TentaGL.Blend.unlock(gl);
    TentaGL.ColorBuffer.unlock(gl);
    TentaGL.ShaderLib.use(gl, origShader);
    TentaGL.SceneNode.setRenderFilter(this._origFilter);
  },
  
  
  
  /** 
   * The sprite filtering function used by the Picker. 
   * @param {TentaGL.Sprite} sprite
   * @return {Boolean}
   */
  _filterFunction: function(sprite) {
    if(this._origFilter(sprite)) {
      var id = this._nextID; //(0xFF000000 | this._nextID);
      this._nextID++;
      
      var pickColor = new TentaGL.Color.Hex(id);
      this._sprites[id] = sprite;
      var rgba = pickColor.getRGBA();
      TentaGL.ShaderLib.current(this._gl).setPickID(this._gl, rgba);
      
      return true;
    }
    else {
      return false;
    }
  },
  
  
  
  
  /** 
   * Extracts the RGBA values of the pixel at the specified coordinates in the 
   * picker raster. 
   * @param {int} x
   * @param {int} y
   * @param {int} flipY   Optional. If true, y increases downward. 
   *      Default to false.
   * @return {length-4 array}   An array containing the RGBA byte values for 
   *      the pixel.
   */
  _getPixelAt:function(x, y, flipY) {
    return this._pixels.getPixelAt(x, y, flipY);
  },
  
  
  /** 
   * Returns the sprite whose picking ID is stored at the specified location in
   * the picker raster.
   * @param {int} x
   * @param {int} y
   * @param {boolean} ignoreComposite   Optional. Whether to ignore composited sprites.
   *      Default to true, meaning that for composited sprites, this will return the top level
   *      sprite the composite hierarchy for the sprite that was clicked.
   * @return {TentaGL.Sprite}
   */
  getSpriteAt:function(x, y, ignoreComposite) {
    if(this._pixels) {
      var pixel = this._getPixelAt(x, y);
      var id = TentaGL.Color.rgba2Hex(pixel[0], pixel[1], pixel[2], pixel[3]);
      var sprite = this._sprites[id];
      if(ignoreComposite || !sprite) {
        return sprite;
      }
      else {
        var path = sprite.getCompositePath();
        return path[path.length-1];
      }
    }
    else {
      return undefined;
    }
  },
  
  
  /** 
   * Returns the sprite whose picking ID is stored at the mouse's location.
   * @param {TentaGL.Mouse} mouse
   * @param {boolean} ignoreComposite   Optional. Whether to ignore composited sprites.
   *      Default to true, meaning that for composited sprites, this will return the top level
   *      sprite the composite hierarchy for the sprite that was clicked.
   * @return {TentaGL.Sprite}
   */
  getSpriteAtMouse: function(mouse, ignoreComposite) {
    var mx = mouse.getX();
    var my = this._app.getHeight() - mouse.getY();
    return this.getSpriteAt(mx, my, ignoreComposite);
  }
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

TentaGL.AppResizeListener = function() {};

TentaGL.AppResizeListener.prototype = {
  
  constructor:TentaGL.AppResizeListener,
  
  isaAppResizeListener:true,
  
  /** 
   * Handler for AppResizeEvents. 
   * Override this.
   * @param {TentaGL.AppResizeEvent}
   */
  handleAppResizeEvent:function(event) {}
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Superclass for events in Subscriber patterns.
 * @constructor
 * @param {Object} source   The object that fired the event.
 * @param {enum} type       The type of event fired.
 */
TentaGL.Event = function(source, type) {
  this._source = source;
  this._type = type;
};

TentaGL.Event.prototype = {
  
  constructor:TentaGL.Event,
  
  /**
   * Returns the event's source object.
   * @return {Object}
   */
  getSource:function() {
    return this._source;
  },
  
  
  /** 
   * Returns the event's type.
   * @return {enum}
   */
  getType:function() {
    return this._type;
  }
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * An event associated with a TentaGL Application being resized. 
 * @constructor
 * @param {Object} source
 * @param {uint} w  The new width
 * @param {uint} h  The new height
 * @param {uint} oldW   The old width.
 * @param {uint} oldH   The old height.
 */
TentaGL.AppResizeEvent = function(source, w, h, oldW, oldH) {
  TentaGL.Event.call(this, source, 0);
  
  this._width = w;
  this._height = h;
  
  this._oldWidth = oldW;
  this._oldHeight = oldH;
};

TentaGL.AppResizeEvent.prototype = {
  
  constructor:TentaGL.AppResizeEvent,
  
  /** 
   * Returns the new width of the application. 
   * @return {uint}
   */
  getWidth:function() {
    return this._width;
  },
  
  /** 
   * Returns the new height of the application. 
   * @return {uint}
   */
  getHeight:function() {
    return this._height;
  },
  
  
  /** 
   * Returns the old width of the application. 
   * @return {uint}
   */
  getOldWidth:function() {
    return this._oldWidth;
  },
  
  
  /** 
   * Returns the old height of the application. 
   * @return {uint}
   */
  getOldHeight:function() {
    return this._oldHeight;
  }
};

Util.Inheritance.inherit(TentaGL.AppResizeEvent, TentaGL.Event);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/**  
 * An event for a Sprite being picked by the Picker 
 * in some context.
 * @constructor
 * @param {TentaGL.Sprite} source  The Sprite that was picked and generated this event.
 * @param {Object} context    The context in which event was generated. (e.g. the mouse)
 */
TentaGL.PickEvent = function(source, context) {
  TentaGL.Event.call(this, source, undefined);
  this._context = context;
};

TentaGL.PickEvent.prototype = {
  
  constructor:TentaGL.PickEvent,
  
  
  /** Returns the context in which the event was generated. */
  getContext:function() {
    return this._context;
  }
};


Util.Inheritance.inherit(TentaGL.PickEvent, TentaGL.Event);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Mix-in for an object type that can listen for PickEvents. 
 */
TentaGL.PickEventListener = function() {};

TentaGL.PickEventListener.prototype = {
  
  constructor:TentaGL.PickEventListener,
  
  
  /** 
   * Handler for PickEvents. 
   * Override this.
   * @param {TentaGL.PickEvent} event
   */
  handlePickEvent:function(event) {}
  
};



/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Constructs a model with empty vertex and face index arrays.
 * @constructor
 * @param {GLenum} drawMode   Optional. Either GL_LINES or GL_TRIANGLES. 
 *      Default GL_TRIANGLES.
 * @param {GLenum} cullMode    Optional. Either GL_NONE, GL_FRONT, GL_BACK, 
 *      or GL_FRONT_AND_BACK. Default GL_NONE.
 */
TentaGL.Model = function(drawMode, cullMode) {
  if(!drawMode) {
    drawMode = GL_TRIANGLES;
  }
  if(!cullMode) {
    cullMode = GL_NONE;
  }
  
  
  this._mode = drawMode;
  this._cull = cullMode;
  this._vertices = [];
  this._indices = [];
};


TentaGL.Model.prototype = {

  constructor:TentaGL.Model,
  
  //////// ID data
  
  /** 
   * Gets the unique ID for caching this model in a map. 
   * If the model didn't have an Id already assigned to it, a unique anonymous
   * ID is created.
   * @return {string}
   */
  getID:function() {
    if(this._id === undefined) {
      this._id = TentaGL.Model.createID();
    }
    return this._id;
  },
  
  /** 
   * Sets the unique ID for caching this model in a map. 
   * @param {string} id
   * @return {TentaGL.Model} this
   */
  setID:function(id) {
    this._id = id;
    return this;
  },
  
  
  //////// Mode
  
  /** 
   * Returns the mode used to draw this model by the VBORenderer. If undefined,
   * then the VBORenderer will use its default drawing mode.
   * @return {GLenum}
   */
  getDrawMode:function() {
    return this._mode;
  },
  
  
  /** 
   * Sets the drawing mode for this model. 
   * @param {GLenum} mode   Either GL_LINES or GL_TRIANGLES
   */
  setDrawMode: function(mode) {
    this._mode = mode;
  },
  
  
  /** 
   * Returns the face culling mode used to draw this model. 
   * @return {GLenum}
   */
  getCullMode:function() {
    return this._cull;
  },
  
  
  /** 
   * Sets the face culling mode for this model. 
   * @param {GLenum} mode   Either GL_NONE, GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. 
   */
  setCullMode: function(mode) {
    this._cull = mode;
  },
  
  
  //////// Element index data
  
  /** 
   * Returns the number of vertex indices defining the faces of this model. 
   * @return {int}
   */
  numIndices:function() {
    return this._indices.length;
  },
  
  /** Returns a copy of this model's element index array. */
  getIndices:function() {
    return this._indices.slice(0, this._indices.length);
  },
  
  //////// Vertex operations
  
  /**
   * Adds a vertex to the model at the end of its internal vertex array.
   * @param {TentaGL.Vertex} vertex
   * @return this
   */
  addVertex:function(vertex) {
    this._vertices.push(vertex);
    return this;
  },
  
  /**
   * Returns the number of vertices in this model.
   * @return {Number}
   */
  numVertices:function() {
    return this._vertices.length;
  },
  
  /** 
   * Obtains the vertex at the specified index in the model's internal 
   * vertex array. 
   * @param (int} index
   * @return {TentaGL.Vertex}
   */
  getVertex:function(index) {
    if(index < 0 || index >= this._vertices.length) {
      var msg = "Index " + index + " out of bounds.";
      throw new Error(msg);
    }
    return this._vertices[index];
  },
  
  /** 
   * Returns a shallow copy of the model's vertices array.
   * @return {Array: TentaGL.Vertex}
   */
  getVertices:function() {
    return this._vertices.slice(0, this._vertices.length);
  },
  
  
  /** 
   * Returns the index of a vertex in this model. If not found, -1 is returned.
   * @param {TentaGL.Vertex} vertex
   * @return {uint}
   */
  indexOfVertex: function(vertex) {
    for(var i=0; i < this._vertices.length; i++) {
      if(this._vertices[i] == vertex) {
        return i;
      }
    }
    
    return -1;
  },
  
  
  //////// Line index operations
  
  /** Returns the number of lines defining this model. */
  numLines:function() {
    return Math.floor(this._indices.length/2);
  },
  
  
  /** 
   * Adds indices to the model to define a line.
   * @param {int} v1  The index of the line's start vertex.
   * @param {int} v2  The index of the line's end vertex.
   */
  addLine:function(v1, v2) {
    if(v1 < 0 || v1 >= this._vertices.length) {
      throw new Error("Index " + v1 + " out of bounds.");
    }
    if(v2 < 0 || v2 >= this._vertices.length) {
      throw new Error("Index " + v2 + " out of bounds.");
    }
    
    this._indices.push(v1);
    this._indices.push(v2);
    
    var vert1 = this._vertices[v1];
    var vert2 = this._vertices[v2];
    
    if(vert1.hasTexST() && vert2.hasTexST()) {
      vert1.setTangental(vert1.computeTangental(vert2, vert2));
      vert2.setTangental(vert2.computeTangental(vert1, vert1));
    }
  },
  
  
  /** 
   * Adds indices to the model to define a line strip. Internally though, the 
   * line strip is composed of a series of individual lines.
   * @param {Array of ints} An array of line strip indices to vertices.
   */
  addLineStrip:function(v) {
    if(v.length < 2) {
      throw new Error("Not enough indices in line strip array.");
    }
    
    var prev = v[0];
    for(var i=1; i<v.length; i++) {
      var cur = v[i];
      
      this.addLine(prev, cur);
    }
  },
  
  
  /** 
   * Adds indices to the model to define a line loop. Internally though, the 
   * line loop is composed of a series of individual lines.
   * @param {Array of ints} An array of line strip indices to vertices.
   */
  addLineLoop:function(v) {
    if(v.length < 2) {
      throw new Error("Not enough indices in line strip array.");
    }
    
    var prev = v[0];
    for(var i=1; i<v.length; i++) {
      var cur = v[i];
      
      this.addLine(prev, cur);
    }
    this.addLine(v[v.length-1], v[0]);
  },
  
  
  /** 
   * Returns an array of lines for this model. 
   * Each element is a length-2 array containing the start and end vertex 
   * indices for a line.
   * @return {Array{Array{int}}}
   */
  getLines:function() {
    var result = [];
    
    for(var i=1; i<v.length; i+=2) {
      var v1 = this._indices[i-1];
      var v2 = this._indices[i];
      result.push([v1, v2]);
    }
    
    return result;
  },
  
  
  
  //////// Face index operations
  
  
  /**
   * Returns the number of faces defined in this model.
   * @return {int}
   */
  numFaces:function() {
    return Math.floor(this._indices.length/3);
  },
  
  /** 
   * Adds 3 indices to the model's list of indices to describe a triangular 
   * face. 
   * Generally, the vertex indices specified should be in CCW order.
   * @param {int} v1  The index of the first vertex making up the face.
   * @param {int} v2  The second
   * @param {int} v3  The third
   */
  addFace:function(v1, v2, v3) {
    if(v1 < 0 || v1 >= this._vertices.length) {
      throw new Error("Index " + v1 + " out of bounds.");
    }
    if(v2 < 0 || v2 >= this._vertices.length) {
      throw new Error("Index " + v2 + " out of bounds.");
    }
    if(v3 < 0 || v3 >= this._vertices.length) {
      throw new Error("Index " + v3 + " out of bounds.");
    }
    
    this._indices.push(v1);
    this._indices.push(v2);
    this._indices.push(v3);
    
    // compute the tangentals for each vertex in this face.
    var vert1 = this._vertices[v1];
    var vert2 = this._vertices[v2];
    var vert3 = this._vertices[v3];
    
    if(vert1.hasTexST() && vert2.hasTexST() && vert3.hasTexST()) {
        vert1.setTangental(vert1.computeTangental(vert2, vert3));
        vert2.setTangental(vert2.computeTangental(vert3, vert1));
        vert3.setTangental(vert3.computeTangental(vert1, vert2));
    }
  },
  
  
  /** 
   * Adds 4 indices to the model's list of indices to describe a 
   * quadrilateral face. The vertices are expected in be provided in CCW order.
   * @param {int} v1  The index of the first vertex making up the face.
   * @param {int} v2  The second
   * @param {int} v3  The third
   * @param {int} v4  The fourth
   */
  addFaceQuad:function(v1, v2, v3, v4) {
    this.addFace(v1, v2, v3);
    this.addFace(v1, v3, v4);
  },
  
  
  /** 
   * Adds indices to the model as if we are specifying a triangle strip.
   * Internally though, they are added as though they are describing 
   * individual triangle faces. 
   * @param {Array: int} v  An array of indices specifying vertices 
   *      comprising a triangle strip.
   */
  addFaceStrip:function(v) {
    if(v.length < 3) {
      throw new Error("Not enough indices in triangle strip array.");
    }
    
    var inorder = true;
    for(var i = 2; i < v.length; i++) {
      if(inorder) {
        this.addFace(v[i-2], v[i-1], v[i]);
      }
      else {
        this.addFace(v[i-1], v[i-2], v[i]);
      }
      inorder = !inorder;
    }
  },
  
  
  /**
   * Adds indices to the model as if we are specifying a triangle fan strip.
   * Internally though, they are added as though they are describing 
   * individual triangle faces. 
   * @param {Array: int} v  An array of indices specifying vertices 
   *      comprising a triangle strip.
   */
  addFaceFan:function(v) {
    if(v.length < 3) {
      throw new Error("Not enough indices in triangle strip array.");
    }
    
    for(var i = 2; i < v.length; i++) {
      this.addFace(v[0], v[i-1], v[i]);
    }
  },
  
  
  /** 
   * Returns the array of triangular faces for this model.
   * @return {Array: Array: int} An array of length-3 arrays each describing
   *      the vertex indices describing a face in the model.
   */
  getFaces:function() {
    if(this._faces === undefined) {
      this._faces = [];
      
      for(var i = 2; i < this._indices.length; i+= 3) {
        var v1 = this._indices[i-2];
        var v2 = this._indices[i-1];
        var v3 = this._indices[i];
        
        this._faces.push([v1, v2, v3]);
      }
    }
    return this._faces;
  },
  
  
  /** 
   * Returns the array of triangular faces that use the nth vertex in this 
   * model. 
   * @param {uint} n  The index of the vertex.
   * @return {array: uint}
   */
  getFacesContainingVertex: function(n) {
    var result = [];
    
    var faces = this.getFaces();
    
    for(var i=0; i<faces.length; i++) {
      var face = faces[i];
      
      if(face[0] == n || face[1] == n || face[2] == n) {
        result.push(i);
      }
    }
    
    return result;
  },
  
  
  /** 
   * Automatically generates the normal vector for each vertex by normalizing
   * the sum of the normals of adjacent faces.
   */
  generateVertexNormals: function() {
    var faceNormals = this.getFaceNormals();
    
    for(var i=0; i<this._vertices.length; i++) {
      var vertex = this._vertices[i];
      var adjFaces = this.getFacesContainingVertex(i);
      
      var n = [0,0,0];
      
      for(var j=0; j<adjFaces.length; j++) {
        var faceIndex = adjFaces[j];
        vec3.add(n, n, faceNormals[faceIndex])
      }
      
      vec3.normalize(n, n);
      vertex.setNormal(n[0], n[1], n[2]);
    }
  },
  
  
  /** 
   * Automatically generates the 2D texture coordinates for each vertex in 
   * the model. 
   */
  generate2DTexCoordsSpherical: function() {
    
    for(var i=0; i< this._vertices.length; i++) {
      var vertex = this._vertices[i];
      var polarCoords = TentaGL.Math.toPolar(vertex.getXYZ());
      
      var thetaY = TentaGL.Math.wrap(polarCoords[1], 0, TentaGL.TAU);
      
      var s = TentaGL.Math.linearMap(thetaY, [0, TentaGL.TAU], [0, 1]);
      var t = TentaGL.Math.linearMap(polarCoords[2], [-Math.PI/2, Math.PI/2], [0, 1]);
      
      vertex.setTexST(s, t);
    }
    
  },
  
  
  
  /** 
   * Computes the surface tangentals for each vertex in this model. 
   */
  generateSurfaceTangentals: function() {
    if(this._mode == GL_LINES) {
      for(var i=0; i<this._indices.length; i+= 2) {
        var v1 = this._indices[i];
        var v2 = this._indices[i+1];
        
        var vert1 = this._vertices[v1];
        var vert2 = this._vertices[v2];
        
        if(vert1.hasTexST() && vert2.hasTexST()) {
          vert1.setTangental(vert1.computeTangental(vert2, vert2));
          vert2.setTangental(vert2.computeTangental(vert1, vert1));
        }
      }
    }
    else {
      for(var i=0; i<this._indices.length; i+= 3) {
        var v1 = this._indices[i];
        var v2 = this._indices[i+1];
        var v3 = this._indices[i+2];
        
        var vert1 = this._vertices[v1];
        var vert2 = this._vertices[v2];
        var vert3 = this._vertices[v3];
        
        if(vert1.hasTexST() && vert2.hasTexST() && vert3.hasTexST()) {
          vert1.setTangental(vert1.computeTangental(vert2, vert3));
          vert2.setTangental(vert2.computeTangental(vert3, vert1));
          vert3.setTangental(vert3.computeTangental(vert1, vert2));
        }
      }
    }
  },
  
  
  
  //////// Properties computations
  
  
  /** 
   * Returns an array containing all the unit surface normal vectors for this
   * model's triangle faces, computing them the first time this is called.
   * @return {Array: vec3}
   */
  getFaceNormals:function() {
    if(this._faceNormals === undefined) {
      this._faceNormals = [];
      
      for(var i = 2; i < this._indices.length; i+= 3) {
        var v1 = this._vertices[this._indices[i-2]];
        var v2 = this._vertices[this._indices[i-1]];
        var v3 = this._vertices[this._indices[i]];
        
        var u = vec3.fromValues(v2.getX() - v1.getX(),
                                v2.getY() - v1.getY(),
                                v2.getZ() - v1.getZ());
        var v = vec3.fromValues(v3.getX() - v1.getX(),
                                v3.getY() - v1.getY(),
                                v3.getZ() - v1.getZ());
        var n = vec3.cross(vec3.create(), u, v);
        this._faceNormals.push(n);
      }
    }
    
    return this._faceNormals;
  },
  
  
  /** 
   * Gets the surface normal vector for the specified face in the model.
   * @param {int} index   The index for the face in the model.
   * @return {vec3} 
   */
  getFaceNormal:function(index) {
    if(index < 0 || index >= this.numFaces()) {
      throw new Error("Face index out of bounds: " + index);
    }
    
    return this.getFaceNormals()[index];
  },
  
  
  
  /**
   * Returns the model's centroid point. This is simply the average of all the 
   * model's vertex points' xyz coordinates, and may not necessarily also be
   * its center of volume.
   * @return {vec4} The centroid point, with the 4th coordinate being 1 to
   *      allow it to be transformed by affine translation transformations.
   */
  getModelCentroid:function() {
    if(this._centroid === undefined) {
      var x = 0;
      var y = 0;
      var z = 0;
      
      for(var i = 0; i < this._vertices.length; i++) {
        var v = this._vertices[i];
        x += v.getX();
        y += v.getY();
        z += v.getZ();
      }
      
      x /= this._vertices.length;
      y /= this._vertices.length;
      z /= this._vertices.length;
      
      this._centroid = vec4.fromValues(x, y, z, 1);
    }
    return this._centroid;
  },
  
  
  /** 
   * Returns the centroid points for each face in the model.
   * @return {Array: vec4} The centroid points, in xyz coordinates with a fourth
   *    coordinate set to 1 to allow translation affine transformations.
   */
  getFaceCentroids:function() {
    if(this._faceCentroids === undefined) {
      this._faceCentroids = [];
      
      for(var i = 2; i < this._indices.length; i+= 3) {
        var v1 = this._vertices[this._indices[i-2]];
        var v2 = this._vertices[this._indices[i-1]];
        var v3 = this._vertices[this._indices[i]];
        
        var x = (v1.getX() + v2.getX() + v3.getX())/3;
        var y = (v1.getY() + v2.getY() + v3.getY())/3;
        var z = (v1.getZ() + v2.getZ() + v3.getZ())/3;
        
        this._faceCentroids.push(vec4.fromValues(x, y, z, 1));
      }
    }
    return this._faceCentroids;
  },
  
  /** 
   * Returns the centroid point for the specified face in the model. 
   * @param {int} index   The index of the face in the model.
   * @return {vec4} The centroid point, with the 4th coordinate being 1 to
   *      allow it to be transformed by affine translation transformations.
   */
  getFaceCentroid:function(index) {
    if(index < 0 || index >= this.numFaces()) {
      throw new Error("Face index out of bounds: " + index);
    }
    
    return this.getFaceCentroids()[index];
  },
  
  
  //////// Instance operations
  
  /** 
   * Returns a clone of this model. 
   * @return {TentaGL.Model}
   */
  clone:function() {
    return this.transform(mat4.create());
  },
  
  
  /** 
   * Returns a clone of this model transformed by some affine 
   * transformation matrix. 
   * @param {mat4} transform
   * @return {TentaGL.Model}
   */
  transform:function(transform) {
    var model = new TentaGL.Model();
    
    // transform-clone vertices
    for(var i=0; i<this._vertices.length; i++) {
      model.addVertex(this._vertices[i].transform(transform));
    }
    
    // clone faces
    for(var i=0; i<this._indices.length; i+=3) {
      model.addFace(this._indices[i], this._indices[i+1], this._indices[i+2]);
    }
    
    return model;
  },
  
  
  /** 
   * Returns a clone of this model with its origin at the original model's 
   * centroid.
   * @return {TentaGL.Model}
   */
  cloneCentered:function() {
    var xyz = this.getModelCentroid();
    return this.transform(mat4.translate(mat4.create(), mat4.create(), [-xyz[0], -xyz[1], -xyz[2]]));
  },
  
  
  
  /**  
   * Returns a clone of this model with all the vertices translated.
   * @param {vec3} xyz
   * @return {TentaGL.Model}
   */
  translate:function(xyz) {
    var t = mat4.create();
    mat4.translate(t, t, xyz);
    return this.transform(t);
  },
  
  
  /** 
   * Returns a clone of this model with all the vertices scaled relative 
   * to the origin.
   * @param {vec3} xyz  The amount to scale the model by on the 3 axes.
   * @return {TentaGL.Model}
   */
  scale:function(xyz) {
    var t = mat4.create();
    mat4.scale(t, t, xyz);
    return this.transform(t);
  },
  
  
  /**
   * Returns a clone of this model with all the vertices rotated around 
   * some axis.
   * @param {vec3} axis
   * @param (number} radians
   * @return {TentaGL.Model}
   */
  rotate:function(axis, radians) {
    var q = quat.setAxisAngle(quat.create(), axis, radians);
    return this.transform(mat4.fromQuat(mat4.create(), q));
  },
  
  
  /** 
   * Returns a clone of this model whose texture coordinates are scaled.
   * @return {TentaGL.Model}
   */
  scaleTexST:function(s, t) {
    var result = this.clone();
    for(var i in result._vertices) {
      var v = result._vertices[i];
      var st = v.getTexST();
      v.setTexST(st[0]*s, st[1]*t);
    }
    return result;
  },
  
  
  /** 
   * Returns a clone of this model where all T tex coordinates are 1 minus
   * their original value. This will make the textures for the model become
   * upside down. 
   * @return {TentaGL.Model}
   */
  flipTexT:function() {
    var result = this.clone();
    for(var i in result._vertices) {
      var v = result._vertices[i];
      var st = v.getTexST();
      v.setTexST(st[0], 1-st[1]);
    }
    return result;
  },
  
  
  
  /** 
   * Returns a clone of this model merged with another model. 
   * @param {TentaGL.Model} model
   * @return {TentaGL.Model}
   */
  merge:function(model) {
    var result = this.clone();
    
    var indexOffset = result.numVertices();
    
    for(var i=0; i<model._vertices.length; i++) {
      result.addVertex(model._vertices[i]);
    }
    
    for(var i=0; i<model._indices.length; i+=3) {
      var i1 = indexOffset + model._indices[i];
      var i2 = indexOffset + model._indices[i+1];
      var i3 = indexOffset + model._indices[i+2];
      
      result.addFace(i1, i2, i3);
    }
    
    return result;
  }
};

TentaGL.Model._nextID = 0;

/**
 * Creates a unique string ID that can be assigned to a model 
 * via Model.setID({string}).
 * @return {string}
 */
TentaGL.Model.createID = function() {
  var id = "anonID" + TentaGL.Model._nextID;
  TentaGL.Model._nextID++;
  return id;
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A simple model for a cone. The center of its base is located at the origin.
 * @constructor
 * @param {number} r    The radius of the cone's base.
 * @param {number} h    The cone's height
 * @param {uint} lonInc   Optional. The angle increment for the longitude, 
 *      in radians. Default to TentaGL.TAU/20.
 */
TentaGL.Model.Cone = function(r, h, lonInc) {
  var model = new TentaGL.Model();
  
  if(!lonInc) {
    lonInc = TentaGL.TAU/20;
  }
  
  var numLonVerts = Math.floor(TentaGL.TAU/lonInc) + 1;
  
  // Create the bottom circle vertices.
  for(var i=0; i < numLonVerts; i++) {
    var lon = i*lonInc;
  
    var xyz = TentaGL.Math.toCartesian([r, lon, 0]);
    var x = xyz[0];
    var z = xyz[2];
    var s = (x/r+1)/2; //lon/TentaGL.TAU;
    var t = (z/r+1)/2;
    
    var v = new TentaGL.Vertex(x, 0, z);
    v.setNormal(0, -1, 0);
    v.setTexST(s, t);
    model.addVertex(v);
  }
  
  // Side vertices
  for(var i=0; i < numLonVerts; i++) {
    var lon1 = i*lonInc;
    var xyz1 = TentaGL.Math.toCartesian([r, lon1, 0]);
    var x1 = xyz1[0];
    var z1 = xyz1[2];
    
    var lon2 = (i+0.5)*lonInc;
    var xyz2 = TentaGL.Math.toCartesian([r, lon2, 0]);
    var x2 = xyz2[0];
    var z2 = xyz2[2];
    
    // Compute the normals for the side.
    var uVec1 = vec3.sub(vec3.create(), [0, h, 0], xyz1);
    var rVec1 = vec3.fromValues(x1, 0, z1);
    var vVec1 = vec3.cross(vec3.create(), rVec1, uVec1);
    var nVec1 = vec3.cross(vec3.create(), uVec1, vVec1);
    vec3.normalize(nVec1, nVec1);
    
    var uVec2 = vec3.sub(vec3.create(), [0, h, 0], xyz2);
    var rVec2 = vec3.fromValues(x2, 0, z2);
    var vVec2 = vec3.cross(vec3.create(), rVec2, uVec2);
    var nVec2 = vec3.cross(vec3.create(), uVec2, vVec2);
    vec3.normalize(nVec2, nVec2);
    
    // Create the vertices and add them to the model
    var vBase = new TentaGL.Vertex(x1, 0, z1);
    vBase.setTexST(lon1/TentaGL.TAU, 0);
    vBase.setNormal(nVec1[0], nVec1[1], nVec1[2]);
    
    var vTop = new TentaGL.Vertex(0, h, 0);
    vTop.setTexST(lon2/TentaGL.TAU, 1);
    vTop.setNormal(nVec2[0], nVec2[1], nVec2[2]);
    
    model.addVertex(vBase);
    model.addVertex(vTop);
  }
  
  // We need 1 more base vertex for everything to match up.
  var xyz1 = TentaGL.Math.toCartesian([r, 0, 0]);
  var x1 = xyz1[0];
  var z1 = xyz1[2];
  
  var uVec1 = vec3.sub(vec3.create(), [0, h, 0], xyz1);
  var rVec1 = vec3.fromValues(x1, 0, z1);
  var vVec1 = vec3.cross(vec3.create(), rVec1, uVec1);
  var nVec1 = vec3.cross(vec3.create(), uVec1, vVec1);
  vec3.normalize(nVec1, nVec1);
  
  var vBase = new TentaGL.Vertex(x1, 0, z1);
  vBase.setTexST(TentaGL.TAU, 0);
  vBase.setNormal(nVec1[0], nVec1[1], nVec1[2]);
  model.addVertex(vBase);
  
  // Bottom circle faces
  for(var j=2; j < numLonVerts; j++) {
    var index1 = 0;
    var index2 = j-1;
    var index3 = j;
    
    model.addFace(index1, index3, index2);
  }
  
  // Side faces
  for(var j=0; j < numLonVerts*2; j+=2) {
    var index1 = numLonVerts + (j+0);
    var index2 = numLonVerts + (j+2);
    var index3 = numLonVerts + (j+1);
    
    model.addFace(index1, index2, index3);
  }
  
  
  return model;
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Creates a cube model with the specified width, height, and depth. 
 * The cube's lower-left-back corner is located at the origin of its 
 * model space. 
 * @param {Number} w  The width of the cube.
 * @param {Number} h  The height of the cube.
 * @param {Number} d  The depth of the cube.
 */
TentaGL.Model.Cube = function(w, h, d) {
  var model = new TentaGL.Model();
  var indexOffset = 0;
  
  var makeSide = function(lowerLeft, u, v) {
    var n = vec3.cross(vec3.create(), u, v);
    
    var v0 = new TentaGL.Vertex(lowerLeft[0], 
                                lowerLeft[1], 
                                lowerLeft[2]);
    v0.setNormal(n[0], n[1], n[2]);
    v0.setTexST(0,0);
    model.addVertex(v0);
    
    var v1 = new TentaGL.Vertex(lowerLeft[0] + u[0], 
                                lowerLeft[1] + u[1], 
                                lowerLeft[2] + u[2]);
    v1.setNormal(n[0], n[1], n[2]);
    v1.setTexST(1,0);
    model.addVertex(v1);
    
    var v2 = new TentaGL.Vertex(lowerLeft[0] + u[0] + v[0], 
                                lowerLeft[1] + u[1] + v[1], 
                                lowerLeft[2] + u[2] + v[2]);
    v2.setNormal(n[0], n[1], n[2]);
    v2.setTexST(1,1);
    model.addVertex(v2);
    
    var v3 = new TentaGL.Vertex(lowerLeft[0] + v[0], 
                                lowerLeft[1] + v[1], 
                                lowerLeft[2] + v[2]);
    v3.setNormal(n[0], n[1], n[2]);
    v3.setTexST(0,1);
    model.addVertex(v3);
    
    model.addFaceQuad(indexOffset,
                      indexOffset+1,
                      indexOffset+2,
                      indexOffset+3);
    
    indexOffset += 4;
  };
  
  makeSide([0,h,d], [w,0,0], [0,0,-d]); // top
  makeSide([0,0,0], [w,0,0], [0,0,d]); // bottom
  makeSide([0,0,d], [w,0,0], [0,h,0]); // front
  makeSide([w,0,0], [-w,0,0], [0,h,0]); // back
  makeSide([w,0,d], [0,0,-d], [0,h,0]); // right
  makeSide([0,0,0], [0,0,d], [0,h,0]); // left
  
  return model;
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a model for a cylinder of a specified height and radius. 
 * The bottom center point of the cylinder is at the origin of its model space.
 * @param {Number} r        The radius of the cylinder.
 * @param {Number} h        The height of the cylinder.
 * @param {Number} lonInc   Optional. The angle increment for the longitude, 
 *      in radians. Default to TentaGL.TAU/20.
 * @return {TentaGL.Model}
 */
TentaGL.Model.Cylinder = function(r, h, lonInc) {
  var model = new TentaGL.Model(false);
  
  if(!lonInc) {
    lonInc = TentaGL.TAU/20;
  }
  
  
  var numLonVerts = Math.floor(TentaGL.TAU/lonInc) + 1;
  
  // Create the bottom circle vertices.
  for(var i=0; i < numLonVerts; i++) {
    var lon = i*lonInc;
  
    var xyz = TentaGL.Math.toCartesian([r, lon, 0]);
    var x = xyz[0];
    var z = xyz[2];
    var s = (x/r+1)/2; //lon/TentaGL.TAU;
    var t = (z/r+1)/2;
    
    var v = new TentaGL.Vertex(x, 0, z);
    v.setNormal(0, -1, 0);
    v.setTexST(s, t);
    model.addVertex(v);
  }
  
  // In-between vertices
  for(var i=0; i < numLonVerts; i++) {
    var lon = i*lonInc;
  
    var xyz = TentaGL.Math.toCartesian([r, lon, 0]);
    var x = xyz[0];
    var z = xyz[2];
    var s = lon/TentaGL.TAU;
    
    var v = new TentaGL.Vertex(x, 0, z);
    v.setNormal(x, 0, z);
    v.setTexST(s, 0);
    model.addVertex(v);
  }
  for(var i=0; i < numLonVerts; i++) {
    var lon = i*lonInc;
  
    var xyz = TentaGL.Math.toCartesian([r, lon, 0]);
    var x = xyz[0];
    var z = xyz[2];
    var s = lon/TentaGL.TAU;
    
    var v = new TentaGL.Vertex(x, h, z);
    v.setNormal(x, 0, z);
    v.setTexST(s, 1);
    model.addVertex(v);
  }
  
  // Top circle vertices
  for(var i=0; i < numLonVerts; i++) {
    var lon = i*lonInc;
  
    var xyz = TentaGL.Math.toCartesian([r, lon, 0]);
    var x = xyz[0];
    var z = xyz[2];
    var s = (x/r+1)/2; //lon/TentaGL.TAU;
    var t = (z/r+1)/2;
    
    var v = new TentaGL.Vertex(x, h, z);
    v.setNormal(0, 1, 0);
    v.setTexST(s, t);
    model.addVertex(v);
  }
  
  
  // Create the faces.
  
  // Bottom circle faces
  for(var j=2; j < numLonVerts; j++) {
    var index1 = 0;
    var index2 = j-1;
    var index3 = j;
    
    model.addFace(index1, index3, index2);
  }
  
  // In-between faces
  for(var j=0; j < numLonVerts-1; j++) {
    var index1 = 1*numLonVerts + (j+0);
    var index2 = 1*numLonVerts + (j+1);
    var index3 = 2*numLonVerts + (j+1);
    var index4 = 2*numLonVerts + (j+0);
    
    model.addFaceQuad(index1, index2, index3, index4);
  }
  
  // Top faces
  for(var j=2; j < numLonVerts; j++) {
    var index1 = 3*numLonVerts;
    var index2 = 3*numLonVerts + j-1;
    var index3 = 3*numLonVerts + j;
    
    model.addFace(index1, index2, index3);
  }
  
  return model;
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


TentaGL.Model.Line = function(xyz1, xyz2) {
  var model = new TentaGL.Model(GL_LINES);
  
  var v1 = new TentaGL.Vertex(xyz1[0], xyz1[1], xyz1[2]);
  v1.setNormal(0, 0, 1);
  v1.setTexST(0,0);
  model.addVertex(v1);
  
  var v2 = new TentaGL.Vertex(xyz2[0], xyz2[1], xyz2[2]);
  v2.setNormal(0, 0, 1);
  v2.setTexST(1,0);
  model.addVertex(v2);
  
  model.addLine(0, 1);
  
  return model;
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a model for a rectangular plane with the specified width and 
 * height. The plane is created with its lower-left corner at the origin of its 
 * model space. Its width is in the direction of its x axis and its height 
 * is in the direction of its y axis.
 * @param {Number} w  The width of the plane.
 * @param {Number} h  The height of the plane.
 * @param {Boolean} flipY   If true, the upper-left corner will be at the 
 *      origin instead.
 */
TentaGL.Model.Plane = function(w, h, flipY) {
  var model = new TentaGL.Model(GL_TRIANGLES, GL_NONE);
  
  flipY = flipY || false;
  
  // compute surface normal vector.
  var u = vec3.fromValues(w, 0, 0);
  var v = vec3.fromValues(0, h, 0);
  var n = vec3.cross(vec3.create(), u, v);
  
  if(flipY) {
    // Create vertices
    var v0 = new TentaGL.Vertex(0, 0, 0);
    v0.setNormal(n[0], n[1], n[2]);
    v0.setTexST(0,1);
    model.addVertex(v0);
    
    var v1 = new TentaGL.Vertex(0, -h, 0);
    v1.setNormal(n[0], n[1], n[2]);
    v1.setTexST(0,0);
    model.addVertex(v1);
    
    var v2 = new TentaGL.Vertex(w, -h, 0);
    v2.setNormal(n[0], n[1], n[2]);
    v2.setTexST(1,0);
    model.addVertex(v2);
    
    var v3 = new TentaGL.Vertex(w, 0, 0);
    v3.setNormal(n[0], n[1], n[2]);
    v3.setTexST(1,1);
    model.addVertex(v3);
    
    
  }
  else {
    // Create vertices
    var v0 = new TentaGL.Vertex(0, 0, 0);
    v0.setNormal(n[0], n[1], n[2]);
    v0.setTexST(0,0);
    model.addVertex(v0);
    
    var v1 = new TentaGL.Vertex(w, 0, 0);
    v1.setNormal(n[0], n[1], n[2]);
    v1.setTexST(1,0);
    model.addVertex(v1);
    
    var v2 = new TentaGL.Vertex(w, h, 0);
    v2.setNormal(n[0], n[1], n[2]);
    v2.setTexST(1,1);
    model.addVertex(v2);
    
    var v3 = new TentaGL.Vertex(0, h, 0);
    v3.setNormal(n[0], n[1], n[2]);
    v3.setTexST(0,1);
    model.addVertex(v3);
  }
  
  // Create faces.
  model.addFaceQuad(0, 1, 2, 3);
  
  return model;
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a model for a series of inter-connected line segments. 
 * @param {Array{vec3}} xyzv  The xyz coordinates for each vertex, in order, 
 *      making up the polyline.
 * @param {Boolean} closed  Whether the polyline forms a closed polygon.
 * @return {TentaGL.Model}
 */
TentaGL.Model.PolyLine = function(xyzv, closed) {
  var model = new TentaGL.Model(GL_LINES);
  
  for(var i=0; i<xyzv.length; i++) {
    var xyz = xyzv[i];
    var vertex = new TentaGL.Vertex(xyz[0], xyz[1], xyz[2]);
    vertex.setNormal(0,0,1);
    vertex.setTexST(i,0);
    model.addVertex(vertex);
    
    if(i>0) {
      model.addLine(i-1, i);
    }
  }
  
  if(closed) {
    model.addLine(xyzv.length-1, 0);
  }
  
  return model;
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a model for a sphere of a specified radius. The center of the
 * sphere is at the origin of its model space.
 * @param {Number} r        The radius of the sphere.
 * @param {Number} latInc   Optional. The angle increment for the latitude, 
 *      in radians. Default to TentaGL.TAU/20.
 * @param {Number} lonInc   Optional. The angle increment for the longitude, 
 *      in radians. Default to TentaGL.TAU/20.
 * @return {TentaGL.Model}
 */
TentaGL.Model.Sphere = function(r, latInc, lonInc) {
  var model = new TentaGL.Model();
  
  if(!latInc) {
    latInc = TentaGL.TAU/20;
  }
  if(!lonInc) {
    lonInc = TentaGL.TAU/20;
  }
  
  var numLatVerts = Math.floor(TentaGL.TAU/2/latInc) + 1;
  var numLonVerts = Math.floor(TentaGL.TAU/lonInc) + 1;
  
  // Create the vertices.
  for(var i=0; i < numLatVerts; i++) {
    var lat = i*latInc - TentaGL.TAU/4;
    
    for(var j=0; j < numLonVerts; j++) {
      var lon = j*lonInc;
    
      var xyz = TentaGL.Math.toCartesian([r, lon, lat]);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var s = lon/TentaGL.TAU;
      var t = lat/(TentaGL.TAU/2) + 0.5;
      
      var v = new TentaGL.Vertex(x, y, z);
      v.setNormal(x, y, z);
      v.setTexST(s, t);
      model.addVertex(v);
    }
  }
  
  // Create the faces.
  for(var i=0; i < numLatVerts-1; i++) {
    for(var j=0; j < numLonVerts-1; j++) {
      var index1 = (i+0)*numLonVerts + (j+0);
      var index2 = (i+0)*numLonVerts + (j+1);
      var index3 = (i+1)*numLonVerts + (j+1);
      var index4 = (i+1)*numLonVerts + (j+0);
      
      model.addFaceQuad(index1, index2, index3, index4);
    }
  }
  
  return model;
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** Returns a simple Model for a single triangle. */
TentaGL.Model.Triangle = function(xyz1, xyz2, xyz3) {
  // Create the model and add its vertices.
  var model = new TentaGL.Model();
  
  var v1 = new TentaGL.Vertex(xyz1[0], xyz1[1], xyz1[2]);
  var v2 = new TentaGL.Vertex(xyz2[0], xyz2[1], xyz2[2]);
  var v3 = new TentaGL.Vertex(xyz3[0], xyz3[1], xyz3[2]);
  
  model.addVertex(v1);
  model.addVertex(v2);
  model.addVertex(v3);
  
  // Compute and set the normal vectors of the vertices to be the surface 
  // normal of the face they form.
  var u = vec3.subtract(vec3.create(), xyz2, xyz1);
  var v = vec3.subtract(vec3.create(), xyz3, xyz1);
  
  var n = vec3.cross(vec3.create(), u, v);
  
  v1.setNormal(n[0], n[1], n[2]);
  v2.setNormal(n[0], n[1], n[2]);
  v3.setNormal(n[0], n[1], n[2]);
  
  // Set the texture coordinates.
  v1.setTexST(0, 0);
  v2.setTexST(1, 0);
  v3.setTexST(1, 1);
  
  // Create a face from the 3 vertices.
  model.addFace(0,1,2);
  
  return model;
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An API for managing and rendering VBO data for 3D models loaded in a gl context.
 */
TentaGL.ModelLib = {
  
  /** 
   * Removes all the cached VBO data from GL memory and from this library. 
   * @return {WebGLRenderingContext} gl
   */
  clean:function(gl) {
    for(var id in gl._vboData) {
      gl._vboData[id].clean(gl);
    }
    gl._vboData = {};
  },
  
  
  /** 
   * Cleans the library and then preloads it with the following built-in 
   * common models:
   * "unitPlane" - a 1x1 square whose lower-left corner is at (0,0,0) and whose
   *               upper-right corner is at (1,1,0).
   * "unitLine" - a line extending from (0,0,0) to (1,1,1).
   * "unitCube" - a 1x1x1 cube whose origin is in its lower-left-back corner.
   * "unitSphere" - an approximated sphere with a radius of 1.
   * "unitSprite" - a unitPlane whose T texture axis is inverted. Intended for
   *                drawing images in 2D mode so that they won't appear upside-down.
   * "unitCone" - an approximated cone with a base radius of 1 and a height of 1.
   */
  reset:function(gl) {
    this.clean(gl);
    this.add(gl, "unitPlane", new TentaGL.Model.Plane(1,1));
    this.add(gl, "unitLine", new TentaGL.Model.Line([0,0,0], [1,1,1]));
    this.add(gl, "unitCube", new TentaGL.Model.Cube(1,1,1));
    this.add(gl, "unitSphere", new TentaGL.Model.Sphere(1));
    this.add(gl, "unitSprite", (new TentaGL.Model.Plane(1,1)).flipTexT());
    this.add(gl, "unitCone", new TentaGL.Model.Cone(1,1));
  },
  
  
  
  /** 
   * Creates and adds the VBO data for a model to the library.
   * @param {WebGLRenderingContext} gl
   * @param {string} modelID  The uniqueID that identifies the VBO data for the 
   *      model in this library.
   * @param {TentaGL.Model} model   The model that the VBO data will be 
   *      produced from.
   * @param {map: int -> TentaGL.AttrProfile} attrProfileSet    Optional.
   *      The set of attributes to be stored in the model's VBO data.
   *      A model's VBO data can be rendered by a shader program only
   *      by a shader program only if the program's AttrProfile is a subset 
   *      of the VBO data's AttrProfile.
   *      If this isn't provided, it will automatically use the default set from
   *      TentaGL.getDefaultAttrProfileSet().
   * @return {TentaGL.VBOData} The VBO data produced for the model.
   */
  add:function(gl, modelID, model, attrProfileSet) {
  //  console.log("Creating VBO for " + modelID + " with profiles set ");
  //  console.log(attrProfileSet);
  
    if(!attrProfileSet) {
      attrProfileSet = TentaGL.getDefaultAttrProfileSet();
    }
    
    var vbo = new TentaGL.VBOData(gl, model, attrProfileSet);
    gl._vboData[modelID] = vbo;
    
    return vbo;
  },
  
  
  /** 
   * Returns the VBOData for the specified model ID. 
   * @param {WebGLRenderingContext} gl
   * @param {string} modelID
   * @return {TentaGL.VBOData}
   */
  get:function(gl, modelID) {
    if(gl._vboData[modelID] === undefined) {
      throw new Error("ModelLib does not contain VBOData for " + modelID + ".");
    }
    return gl._vboData[modelID];
  },
  
  
  /** 
   * Removes the VBO data for the specified model from the 
   * ModelLib and GL memory. 
   * @param {WebGLRenderingContext} gl
   * @param {string} modelID
   */
  remove:function(gl, modelID) {
    var vbo = gl._vboData[modelID];
    vbo.clean(gl);
    delete gl._vboData[modelID];
  },
  
  
  /** 
   * Renders a model from this library. 
   * @param {WebGLRenderingContext} gl
   * @param {string} modelID
   */
  render:function(gl, modelID) {
    TentaGL.ViewTrans.updateMVPUniforms(gl);
    
    var vboData = this.get(gl, modelID);
    TentaGL.VBORenderer.render(gl, vboData);
  }
  
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An API for reading models from Wavefront .obj files.
 */
TentaGL.Model.ObjReader = {
  
  
  _numLoading: 0,
  
  
  /** 
   * Asynchronously produces a set of models from a .obj file at some URL. 
   * @param {string} path
   * @param {func( modelMap : {map: string -> TentaGL.Model})} 
   *      callback    This should process the models created from the file.
   *                  Each element in models is a name, model pair.
   */
  fromURL: function(path, callback) {
    var self = this;
    
    var req = new XMLHttpRequest();
    req.open("get", path);
    req.onerror = function(err) {
      console.log("AJAX error: ", err);
      self._numLoading--;
    };
    req.onreadystatechange = function(e) {
      if (this.readyState == 4 && this.status == 200) {
        self._processResponse(req.responseText, callback);
        self._numLoading--;
      }
    };
    req.send();
    
    this._numLoading++;
  },
  
  
  _processResponse: function(response, callback) {
    var modelMap = [];
    var curGroup = "";
    var curModel = new TentaGL.Model();
    
    var index = 0;
    var prevToken = "";
    
    var lines = response.split("\n");
    for(var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      
      // Remove excess whitespace.
      line = line.replace("\t", " ");
      while(line.indexOf("  ") != -1) {
        line = line.replace("  ", " ");
      }
      
      if(line != "" && line.charAt(0) != "#") {
        var toks = line.split(" ");
        
        if(toks[0] != prevToken) {
          index = 0;
        }
        
        // New model
        if(toks[0] == "g") {
          modelMap[curGroup] = curModel;
          curModel = new TentaGL.Model();
          curGroup = toks[1];
        }
        
        // New vertex
        else if(toks[0] == "v") {
          var x = parseFloat(toks[1]);
          var y = parseFloat(toks[2]);
          var z = parseFloat(toks[3]);
          curModel.addVertex(new TentaGL.Vertex(x, y, z));
        }
        
        // Vertex normal
        else if(toks[0] == "vn") {
          var vertex = curModel.getVertex(index);
          var x = parseFloat(toks[1]);
          var y = parseFloat(toks[2]);
          var z = parseFloat(toks[3]);
          vertex.setNormal(x, y, z);
        }
        
        // Vertex texture coordinates
        else if(toks[0] == "vt") {
          var vertex = curModel.getVertex(index);
          var s = parseFloat(toks[1]);
          var t = parseFloat(toks[2]);
          vertex.setTexST(s, t);
        }
        
        // New face
        else if(toks[0] == "f") {
          var v1 = parseInt(toks[1]) - 1;
          var v2 = parseInt(toks[2]) - 1;
          var v3 = parseInt(toks[3]) - 1;
          
          if(toks.length == 5) {
            var v4 = parseInt(toks[4]) - 1;
            curModel.addFaceQuad(v1, v2, v3, v4);
          }
          else {
            curModel.addFace(v1, v2, v3);
          }
        }
        
        // usemtl is ignored.
        else if(toks[0] == "usemtl") {
          // do nothing.
        }
        
        else {
          throw new Error("Could not read wavefront object. Error at line " + (i+1));
        }
        
        index++;
        prevToken = toks[0];
        
      }
    }
    modelMap[curGroup] = curModel;
    
    callback(modelMap);
  },
  
  
  /** 
   * Returns true if some models are still busy loading.
   */
  isLoading: function() {
    return (this._numLoading > 0);
  },
  
  
  getNumLoading: function() {
    return this._numLoading;
  }
  
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a Vertex given its XYZ coordinates. A fourth homogeneous
 * coordinate is also created, set to 1 to allow for translation affine
 * transformations on the vertex.
 * Most types of data for a vertex are stored as vec2s, vec3s, or vec4s from 
 * the gl-matrix.js framework. In essence though, these are just Float32Arrays.
 * When first constructed, the vertex only has a field for its xyz coordinates.
 * Other fields such as its normal vector and color get added on as they 
 * become used.
 * @constructor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
TentaGL.Vertex = function(x, y, z) {
  this._xyz = vec4.fromValues(x, y, z, 1);
}

TentaGL.Vertex.prototype = {
  
  constructor:TentaGL.Vertex, 
  
  /** 
   * Returns a copy of the vertex's homogeneous XYZW coordinates. 
   * @return {vec4}
   */
  getXYZ:function() {
    return vec4.clone(this._xyz);
  },
  
  /** 
   * Sets the vertex's XYZ coordinates.
   * @param {Number} x
   * @param {Number} y
   * @param {Number} z
   */
  setXYZ:function(x, y, z) {
    this._xyz[0] = x;
    this._xyz[1] = y;
    this._xyz[2] = z;
  },
  
  
  /**
   * Returns the vertex's X coordinate.
   * @return {Number}
   */
  getX:function() {
    return this._xyz[0];
  },
  
  /**
   * Returns the vertex's Y coordinate.
   * @return {Number}
   */
  getY:function() {
    return this._xyz[1];
  },
  
  /**
   * Returns the vertex's Z coordinate.
   * @return {Number}
   */
  getZ:function() {
    return this._xyz[2];
  },
  
  
  
  /** 
   * Sets the vertex's X coordinate. 
   * @param {Number} x
   */
  setX:function(x) {
    this._xyz[0] = x;
  },
  
  /** 
   * Sets the vertex's Y coordinate. 
   * @param {Number} y
   */
  setY:function(y) {
    this._xyz[1] = y;
  },
  
  /** 
   * Sets the vertex's Z coordinate. 
   * @param {Number} z
   */
  setZ:function(z) {
    this._xyz[2] = z;
  },
  
  
  /** 
   * Returns a copy of this vertex's 2D texture coordinates array.
   * If this vertex's 2D texture coordinates are undefined, an Error is thrown.
   * @return {vec2}
   */
  getTexST:function() {
    if(this._texST === undefined) {
      var msg = "Vertex 2D texture coordinates have not been defined.";
      throw new Error(msg);
    }
    else {
      return vec2.clone(this._texST);
    }
  },
  
  
  /** 
   * Returns true iff 2D texture coordsinates have been defined for this vertex. 
   * @return {boolean}
   */
  hasTexST: function() {
    return (this._texST != undefined);
  },
  
  
  /**
   * Sets the 2D texture coordinates for this vertex.
   * @param {Number} s
   * @param {Number} t
   */
  setTexST:function(s, t) {
    this._texST = vec2.fromValues(s, t);
  },
  
  /** 
   * Returns the vertex's 2D texture coordinate S. 
   * @return {Number}
   */
  getTexS:function() {
    return this._texST[0];
  },
  
  /** 
   * Returns the vertex's 2D texture coordinate T. 
   * @return {Number}
   */
  getTexT:function() {
    return this._texST[1];
  },
  
  
  /** 
   * Returns a copy of this vertex's surface normal vector. If this vertex's 
   * surface normal vector has not yet been defined, an Error is thrown.
   * @return {vec3}
   */
  getNormal:function() {
    if(this._normal === undefined) {
      var msg = "Vertex surface normal has not been defined.";
      throw new Error(msg);
    }
    else {
      return vec3.clone(this._normal);
    }
  },
  
  
  /** 
   * Returns true iff the surface normal vector has been defined for this vertex. 
   * @return {boolean}
   */
  hasNormal: function() {
    return (this._normal != undefined);
  },
  
  
  /** 
   * Sets the surface normal vector for this vertex. The stored vector becomes 
   * normalized.
   * @param {Number} x  Normalized x component.
   * @param {Number} y  Normalized y component.
   * @param {Number} z  Normalized z component.
   */
  setNormal:function(x, y, z) {
    this._normal = vec3.fromValues(x, y, z);
    this._normal = vec3.normalize(this._normal, this._normal);
  },
  
  
  
  
  /** 
   * Returns a copy of this vertex's surface tangental vector. If this vertex's
   * surface tangental vector has not yet been defined, an Error is thrown.
   * @return {vec3}
   */
  getTangental:function() {
    if(this._tangental === undefined) {
      var msg = "Vertex surface tangental has not been defined.";
      throw new Error(msg);
    }
    else {
      return vec3.clone(this._tangental);
    }
  },
  
  
  /** 
   * Returns true iff this vertex's tangental vector is undefined. 
   * @return {boolean}
   */
  hasTangental: function() {
    return (this._tangental !== undefined);
  },
  
  
  /** 
   * Computes (but doesn't set) the surface tangental vertex of this vertex, using the texture 
   * coordinates of this vertex and two vertices it shares a polygon with.
   * @param {TentaGL.Vertex} v2
   * @param {TentaGL.Vertex} v3
   * @return {vec3}
   */
  computeTangental:function(v2, v3) {
    var u = vec3.sub(vec3.create(), v2.getXYZ(), this.getXYZ());
    var v = vec3.sub(vec3.create(), v3.getXYZ(), this.getXYZ());
    
    var su = v2.getTexS() - this.getTexS();
    var sv = v3.getTexS() - this.getTexS();
    var tu = v2.getTexT() - this.getTexT();
    var tv = v3.getTexT() - this.getTexT();
    var dst = tv*su - tu*sv;
    if(dst == 0) {
      return vec3.fromValues(1, 0, 0);
    }
    else {
      var tang = vec3.create();
      vec3.scale(tang, u, tv);
      vec3.sub(tang, tang, vec3.scale(vec3.create(), v, tu));
      vec3.scale(tang, tang, 1/dst);
      
      var t = tang;
      if(vec3.length(tang) == 0) {
        return vec3.fromValues(1, 0, 0);
      }
      
      return tang;
    }
  },
  
  
  /** 
   * Sets the tangental vector for this vertex. It is advised to set this by 
   * using the result values from a call to computeTangental. The stored
   * vector becomes normalized.
   * @param {vec3} xyz
   */
  setTangental:function(xyz) {
    this._tangental = vec3.fromValues(xyz[0], xyz[1], xyz[2]);
    this._tangental = vec3.normalize(this._tangental, this._tangental);
  },
  
  
  /** 
   * Returns a deep clone of this Vertex. 
   * @return {TentaGL.Vertex}
   */
  clone:function() {
    return this.transform(mat4.create());
  },
  
  
  /**
   * Returns a new Vertex resulting from this Vertex being transformed by 
   * an affine transformation matrix. This is essentially a transformed deep 
   * clone.
   * @param {mat4} transform  The affine transformation matrix being applied to
   *      this vertex.
   * @return {TentaGL.Vertex} The transformed copy of this vertex.
   */
  transform:function(transform) {
  //  console.log("transform vertex!");
  //  console.log("  transform: " + Util.Debug.arrayString(transform));
  //  console.log("  old XYZ: " + this.getX() + ", " + this.getY() + ", " + this.getZ());
    
    var xyz = vec4.transformMat4(vec4.create(), this.getXYZ(), transform);
    var result = new TentaGL.Vertex(xyz[0], xyz[1], xyz[2]);
    
  //  console.log("  new XYZ: " + xyz[0] + ", " + xyz[1] + ", " + xyz[2]);
    
    if(this._normal !== undefined) {
      // We need to turn normal from a vec3 into a vec4 before it can be matrix-multiplied.
      var normal = this.getNormal();
      normal = vec4.fromValues(normal[0], normal[1], normal[2], 0);
      normal = vec4.transformMat4(normal, normal, transform);
      result.setNormal(normal[0], normal[1], normal[2]);
    }
    
    if(this._tangental !== undefined) {
      // We need to turn tangental from a vec3 into a vec4 before it can be matrix-multiplied.
      var tang = this.getTangental();
      tang = vec4.fromValues(tang[0], tang[1], tang[2], 0);
      tang = vec4.transformMat4(tang, tang, transform);
      result.setTangental(tang[0], tang[1], tang[2]);
    }
    
    if(this._texST !== undefined) {
      result.setTexST(this.getTexS(), this.getTexT());
    }
    
    return result;
  }


};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * An API for fetching and loading images. 
 */
TentaGL.ImageLoader = {
  
  
  _numLoading: 0,
  
  
  /** 
   * Fetches and loads an image from a URL. 
   * @param {string} url
   * @param {function(image : Image) : undefined} successCB    Callback for when the image is successfully loaded.
   * @param {function : undefined} errorCB      Optional. Callback for when there is an error loading the image.
   */
  load: function(url, successCB, errorCB) {
    var self = this;
    this._numLoading++;
    
    if(!errorCB) {
      errorCB = function() {
        self._numLoading--;
        throw new Error("Could not load image at " + url + ".");
      }
    }
    
    var image = new Image();
    image.onload = function() {
      successCB(image);
      self._numLoading--;
    };
    image.src = url;
  },
  
  
  /** 
   * Returns true if the ImageLoader is still loading 1 or more images. 
   * @return {boolean}
   */
  isLoading: function() {
    return (this._numLoading > 0);
  }
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Encapsulates a rectangular area of raw pixel data.
 * @constructor
 * @param {Uint8Array} rgbaByteArray   The array containing the pixel data.
 *      The size of the array should be width*height*4, each element should be 
 *      represented by 4 consecutive bytes in RGBA order, and the first 
 *      element should be the pixel in the lower-left corner of the image the 
 *      array represents. Each row in the array is read from bottom to top, 
 *      and left to right in each row.
 * @param {int} width
 * @param {int} height
 */
TentaGL.PixelData = function(rgbaByteArray, width, height) {
  this._pixels = rgbaByteArray;
  this._width = width;
  this._height = height;
};


TentaGL.PixelData.prototype = {
  
  constructor:TentaGL.PixelData,
  
  /** Produces a copy of this PixelData. */
  clone:function() {
    var pixels = new Uint8Array(this._pixels.length);
    for(var i=0; i < this._pixels.length; i++) {
      pixels[i] = this._pixels[i];
    }
    
    return new TentaGL.PixelData(pixels, this._width, this._height);
  },
  
  
  /** 
   * Returns the width of the pixel area. 
   * @return {int}
   */
  getWidth:function() {
    return this._width;
  },
  
  /** 
   * Returns the height of the pixel area. 
   * @return {int}
   */
  getHeight:function() {
    return this._height;
  },
  
  
  /**
   * Returns the array of pixel data wrapped by this object.
   * @return {Uint8Array}
   */
  getData:function() {
    return this._pixels;
  },
  
  
  /** 
   * Extracts the RGBA values of the pixel at the specified coordinates in the 
   * source data. 
   * @param {int} x
   * @param {int} y
   * @param {int} flipY   Optional. If true, y increases downward. 
   *      Default to false.
   * @return {length-4 array}   An array containing the RGBA byte values for 
   *      the pixel.
   */
  getPixelAt:function(x, y, flipY) {
    if(flipY) {
      y = this.height-1-y;
    }
    
    var index = (this._width*y + x)*4;
    var r = this._pixels[index];
    var g = this._pixels[index+1];
    var b = this._pixels[index+2];
    var a = this._pixels[index+3];
    return [r, g, b, a];
  },
  
  
  /** 
   * Sets the rgba value for the pixel at the specified coordinates in the
   * PixelData.
   * @param {int} x
   * @param {int} y
   * @param {vec4} rgba
   * @param {int} flipY   Optional. If true, y increases downward. 
   *      Default to false.
   */
  setPixelAt:function(x, y, rgba, flipY) {
    if(flipY) {
      y = this.height-1-y;
    }
    
    var index = (this._width*y + x)*4;
    this._pixels[index] = rgba[0];
    this._pixels[index+1] = rgba[1];
    this._pixels[index+2] = rgba[2];
    this._pixels[index+3] = rgba[3];
  },
  
  
  /** 
   * Returns a copy of this PixelData with some filter function applied to
   * all its pixels.
   * @param {TentaGL.RGBAFilter} filter
   * @return TentaGL.PixelData
   */
  filter:function(filter) {
    var result = this.clone();
    
    for(var i=0; i < this._pixels.length; i+=4) {
      filter.filter(result._pixels, this._pixels, i, this._width, this._height);
    }
    
    return result;
  },
  
  
  /** 
   * Returns a cropped copy of this PixelData. Remember, in WebGL, the (0,0)
   * is actually at the lower-left corner of the image and (w,h) is at the
   * upper-right corner.
   * @param {int} x
   * @param {int} y
   * @param {int} w
   * @param {int h}
   */
  crop:function(x, y, w, h) {
    
    var data = new Uint8Array(w*h*4);
    for(var dx=x; dx < x+w; dx++) {
      for(var dy=y; dy < y+h; dy++) {
        var si = (this._width*dy + dx)*4;
        var di = (w*(dy-y) + (dx-x))*4;
        
        data[di] = this._pixels[si];
        data[di+1] = this._pixels[si+1];
        data[di+2] = this._pixels[si+2];
        data[di+3] = this._pixels[si+3];
      }
    }
    
    return new TentaGL.PixelData(data, w, h);
  },
  
  
  /** 
   * Produces a canvas element from this pixel data. 
   * @return {canvas element}
   */
  toCanvas: function() {
    var canvas = document.createElement("canvas");
    var w = canvas.width = this.getWidth();
    var h = canvas.height = this.getHeight();
    
    var ctx = canvas.getContext("2d");
    var imgData = ctx.createImageData(w,h);
    
    for(var si=0; si < this._pixels.length; si+=4) {
      var xy = TentaGL.PixelData.indexToXY(si, w);
      var x = xy[0];
      var y = h-xy[1]-1;
      
      var di = TentaGL.PixelData.xyToIndex(x, y, w);
      
      imgData.data[di] = this._pixels[si];
      imgData.data[di+1] = this._pixels[si + 1];
      imgData.data[di+2] = this._pixels[si + 2];
      imgData.data[di+3] = this._pixels[si + 3];
    }
    
    ctx.putImageData(imgData, 0, 0);
    
    var container = document.getElementById("imgDebug");
    if(container) {
      container.appendChild(canvas);
    }
    
    return canvas;
  }
};


/** 
 * Extracts and returns the PixelData for a texture stored in GL memory. 
 * @param {WebGLRenderingContext} gl
 * @param {WebGLTexture} glTex
 * @param {int} x
 * @param {int} y
 * @param {int} w
 * @param {int} h
 * @param {Uint8Array} bytes      Optional. A pre-allocated byte array to store 
 *      the pixel data in. The size of this array should be at least 4*w*h. 
 */
TentaGL.PixelData.fromGLTexture = function(gl, glTex, x, y, w, h, bytes) {
  
  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(GL_FRAMEBUFFER, fb);
  gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, glTex, 0);
  
  if(!bytes) {
    bytes = new Uint8Array(w*h*4);
  }
  gl.readPixels(x, y, w, h, GL_RGBA, GL_UNSIGNED_BYTE, bytes);
  
  gl.bindFramebuffer(GL_FRAMEBUFFER, null);
  gl.deleteFramebuffer(fb);
  
  return new TentaGL.PixelData(bytes, w, h);
};



/** 
 * Produces PixelData from an image at the specifed url. 
 * Due to the asynchronous behavior of loading images, a callback function
 * must be provided to use the resulting PixelData.
 * @param {string} url
 * @param {function(data : TentaGL.PixelData) : undefined} callback   
 *      A callback for any post-processing of the PixelData for the image,  
 *      including application of RGBAFilters and loading it into a gl context's
 *      MaterialLib.
 */
TentaGL.PixelData.fromURL = function(url, callback) {
  TentaGL.ImageLoader.load(url, function(img) {
    // Produce a canvas that we can draw our image on and read pixels back from.
    var canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    canvas.getContext("2d").drawImage(img, 0, 0);
    
    // Extract the pixel data from the canvas with our image rendered to it,
    // then process it with our callback.
    var result = TentaGL.PixelData.fromCanvas(canvas);
    callback(result);
  });
};



/** 
 * Produces PixelData from a Canvas element. 
 * @param {Canvas} canvas
 * @return {TentaGL.PixelData}
 */
TentaGL.PixelData.fromCanvas = function(canvas) {
  var container = document.getElementById("imgDebug");
  if(container) {
    container.appendChild(canvas);
  }
  
  var width = canvas.width;
  var height = canvas.height;
  
  var srcData = canvas.getContext("2d").getImageData(0, 0, width, height).data;
  var dstData = new Uint8Array(width*height*4);
  
  for(var x=0; x < width; x++) {
    for(var y=0; y < height; y++) {
      var si = (y*width + x)*4;
      
      var dstY = height-1-y;
      var di = (dstY*width + x)*4;
      
      dstData[di] = srcData[si];
      dstData[di+1] = srcData[si+1];
      dstData[di+2] = srcData[si+2];
      dstData[di+3] = srcData[si+3];
    }
  }
  
  return new TentaGL.PixelData(dstData, width, height);
};


/** 
 * Converts a GL pixel array index to GL X, Y coordinates. 
 */
TentaGL.PixelData.indexToXY = function(index, width) {
  index /= 4;
  var y = Math.floor(index/width);
  var x = index - y*width;
  
  return [x, y];
};


/**
 * Converts GL X,Y coordinates to a GL pixel array index.
 */
TentaGL.PixelData.xyToIndex = function(x, y, width) {
  return 4*(width*y + x);
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/**  
 * Encapsulation of some RGBA pixel filtering function. This is an abstract
 * class that should be inherited to produce your own custom RGBAFilters.
 */
TentaGL.RGBAFilter = {};

TentaGL.RGBAFilter.prototype = {
  
  constructor:TentaGL.RGBAFilter,
  
  /**
   * Applies the filter on a pixel in the srcData and puts the result RGBA 
   * values for the pixel in dstData. SrcData is not modified.
   *
   * Implement this.
   * @param {Uint8Array} dstData  The array where the result pixel data is stored.
   * @param {Uint8Array} srcData  The array from which the source pixel data is read.
   * @param {int} index   The index of the pixel being filtered in the arrays.
   * @param {int} width   The width of the textures the arrays define.
   * @param {int} height  The height of the textures the arrays define.
   */
  filter:function(dstData, srcData, index, width, height) {},
  
  
  /** 
   * Sets the rgba data for a pixel in a destination pixel data array. 
   * @param {Uint8Array} dstData
   * @param {int} index   the start index of the pixel in dstData. Each pixel is
   *      assumed to be composed of 4 bytes for the RGBA values.
   * @param {uint8} r
   * @param {uint8} g
   * @param {uint8} b
   * @param {uint8} a
   */
  setPixel:function(dstData, index, r, g, b, a) {
    dstData[index] = r;
    dstData[index+1] = g;
    dstData[index+2] = b;
    dstData[index+3] = a;
  }
  
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that adds a color's RGB value to all pixels.
 * @constructor
 * @param {TentaGL.Color} color  The additive color.
 */
TentaGL.RGBAFilter.AddColor = function(color) {
  this._color = color;
};


TentaGL.RGBAFilter.AddColor.prototype = {
  
  constructor:TentaGL.RGBAFilter.AddColor,
  
  
  /**
   * Returns the color being used by this filter for transparency.
   * @return {TentaGL.Color}
   */
  getColor:function() {
    return this._color;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    r = TentaGL.Math.clamp(r + this._color.getRedByte(), 0, 255);
    g = TentaGL.Math.clamp(g + this._color.getGreenByte(), 0, 255);
    b = TentaGL.Math.clamp(b + this._color.getBlueByte(), 0, 255);
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


/** 
 * Creates a AddColor filter for a color defined by uint8 rgb values. 
 * @param {uint8} r
 * @param {uint8} g
 * @param {uint8} b
 * @return {TentaGL.RGBAFilter.AddColor}
 */
TentaGL.RGBAFilter.AddColor.RGBBytes = function(r, g, b) {
  var color = TentaGL.Color.RGBABytes(r, g, b);
  return new TentaGL.RGBAFilter.AddColor(color);
};



Util.Inheritance.inherit(TentaGL.RGBAFilter.AddColor, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that applies an alpha map over the pixels.
 * Images that this filter is applied to must have the same dimensions as the
 * alpha map image, or they will produce unexpected results.
 * @constructor
 * @param {TentaGL.PixelData} alphaMapPixelData  The PixelData to be used 
 *      as the alpha map.
 */
TentaGL.RGBAFilter.AlphaMap = function(alphaMapPixelData) {
  this._alphaData = alphaMapPixelData.getData();
};


TentaGL.RGBAFilter.AlphaMap.prototype = {
  
  constructor:TentaGL.RGBAFilter.AlphaMap,
  
  
  /** 
   * Returns the uint8 pixel array for the alpha map.
   * @return {Uint8Array}
   */
  getAlphaData:function() {
    return this._alphaData;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = this._alphaData[index];
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};




Util.Inheritance.inherit(TentaGL.RGBAFilter.AlphaMap, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A filter that sets any normalized alpha color values < 1 to 0. 
 * @constructor
 */
TentaGL.RGBAFilter.AlphaRemoval = function() {};

TentaGL.RGBAFilter.AlphaRemoval.prototype = {
  
  constructor:TentaGL.RGBAFilter.AlphaRemoval,
  
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    if(a < 255) {
      a = 0;
    }
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.AlphaRemoval, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that uses the pixels of one image as a clip region
 * for the pixels. The pixels in the clip map image whose alpha components 
 * are > 0 define the clipping region. 
 * Pixels outside the clipping region have their alpha components
 * set to 0.
 * @constructor
 * @param {TentaGL.PixelData} clipMapPixelData  The PixelData to be used 
 *      as the clip map.
 */
TentaGL.RGBAFilter.ClipMap = function(clipMapPixelData) {
  this._clipData = clipMapPixelData.getData();
};


TentaGL.RGBAFilter.ClipMap.prototype = {
  
  constructor:TentaGL.RGBAFilter.ClipMap,
  
  
  /** 
   * Returns the uint8 pixel array for the clip map.
   * @return {Uint8Array}
   */
  getClipData:function() {
    return this._clipData;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    if(this._clipData[index+3] == 0) {
      a = 0;
    }
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.ClipMap, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that applies a convolution matrix to the pixels.
 * @constructor
 * @param {Array{Array{Number}}} matrix   A square 2D matrix of pixel weights.
 *      The matrix is expected to be in row-major order.
 */
TentaGL.RGBAFilter.Convolution = function(matrix) {
  var sideLen = matrix[0].length
  this._sideLen = sideLen;
  
  // normalize the matrix.
  var sum = 0;
  for(var i=0; i < sideLen; i++) {
    for(var j=0; j < sideLen; j++) {
      sum += matrix[i][j];
    }
  }
  console.log(sum);
  
  if(sum > 0) {
    for(var i=0; i < sideLen; i++) {
      for(var j=0; j < sideLen; j++) {
        matrix[i][j] /= sum;
      }
    }
  }
  console.log(matrix);
  
  this._matrix = matrix;
};


TentaGL.RGBAFilter.Convolution.prototype = {
  
  constructor:TentaGL.RGBAFilter.Convolution,
  
  /** 
   * Returns the convolution matrix for this filter. 
   * @return {Array{Array{Number}}}
   */
  getMatrix:function() {
    return this._matrix;
  },
  
  
  
  /**
   * Returns the side length of the convolution matrix for this filter.
   * @return {int}
   */
  getSideLength:function() {
    return this._sideLen;
  },
  
  
  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = 0;
    var g = 0;
    var b = 0;
    var a = srcData[index+3];
    var sideLen = this._sideLen;
    
    var xy = TentaGL.PixelData.indexToXY(index, width);
    var x = xy[0];
    var y = xy[1];
    
    // Apply the filter.
    var offset = Math.floor(sideLen/2);
    for(var i=0;  i < sideLen; i++) {
      var y2 = y + i - offset;
      if(y2 >= height) {
          y2 = height-1;
        }
        if(y2 < 0) {
          y2 = 0;
        }
      
      for(var j=0; j < sideLen; j++) {
        var weight = this._matrix[i][j];
        
        var x2 = x + j - offset;
        if(x2 >= width) {
          x2 = width - 1;
        }
        if(x2 < 0) {
          x2 = 0;
        }
        
        var index2 = TentaGL.PixelData.xyToIndex(x2, y2, width);
        var a2 = srcData[index2+3]/255;
        
        r += srcData[index2]*weight*a2;
        g += srcData[index2+1]*weight*a2;
        b += srcData[index2+2]*weight*a2;
      }
    }
    
  //  console.log([r, g, b, a]);
    r = TentaGL.Math.clamp(r, -256, 255);
    if(r < 0) {
      r += 256;
    }
    
    g = TentaGL.Math.clamp(g, -256, 255);
    if(g < 0) {
      g += 256;
    }
    
    b = TentaGL.Math.clamp(b, -256, 255);
    if(b < 0) {
      b += 256;
    }
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.Convolution, TentaGL.RGBAFilter);


/** 
 * Produces a blur filter with the kernel:
 * [1,1,1]
 * [1,1,1]
 * [1,1,1]
 * @return {TentaGL.RGBAFilter.Convolution}
 */
TentaGL.RGBAFilter.Convolution.Blur3 = function() {
  return new TentaGL.RGBAFilter.Convolution([ [1,1,1],
                                              [1,1,1],
                                              [1,1,1]]);
};


/** 
 * Produces a blur filter with the kernel:
 * [1,2,1]
 * [2,4,2]
 * [1,2,1]
 * @return {TentaGL.RGBAFilter.Convolution}
 */
TentaGL.RGBAFilter.Convolution.GaussianBlur3 = function() {
  return new TentaGL.RGBAFilter.Convolution([ [1,2,1],
                                              [2,4,2],
                                              [1,2,1]]);
};


/** 
 * Produces a sharpen filter with the kernel:
 * [0,-1,0]
 * [-1,5,-1]
 * [0,-1,0]
 * @return {TentaGL.RGBAFilter.Convolution}
 */
TentaGL.RGBAFilter.Convolution.Sharpen3 = function() {
  return new TentaGL.RGBAFilter.Convolution([ [0,-1,0],
                                              [-1,5,-1],
                                              [0,-1,0]]);
};


/** 
 * Produces an edge detection filter with the kernel:
 * [1,0,-1]
 * [0,0,0]
 * [-1,0,1]
 * @return {TentaGL.RGBAFilter.Convolution}
 */
TentaGL.RGBAFilter.Convolution.EdgeDetect3 = function() {
  return new TentaGL.RGBAFilter.Convolution([ [1,0,-1],
                                              [0,0,0],
                                              [-1,0,1]]);
};


/** 
 * Produces a edge detection filter with the kernel:
 * [0,1,0]
 * [1,-4,1]
 * [0,1,0]
 * @return {TentaGL.RGBAFilter.Convolution}
 */
TentaGL.RGBAFilter.Convolution.EdgeDetect3_2 = function() {
  return new TentaGL.RGBAFilter.Convolution([ [0,1,0],
                                              [1,-4,1],
                                              [0,1,0]]);
};


/** 
 * Produces a edge detection filter with the kernel:
 * [-1,-1,-1]
 * [-1,8,-1]
 * [-1,-1,-1]
 * @return {TentaGL.RGBAFilter.Convolution}
 */
TentaGL.RGBAFilter.Convolution.EdgeDetect3_3 = function() {
  return new TentaGL.RGBAFilter.Convolution([ [-1,-1,-1],
                                              [-1,8,-1],
                                              [-1,-1,-1]]);
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that converts pixels to greyscale.
 * @constructor
 */
TentaGL.RGBAFilter.Grayscale = function() {
};


TentaGL.RGBAFilter.Grayscale.prototype = {
  
  constructor:TentaGL.RGBAFilter.Grayscale,
  
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index]/255;
    var g = srcData[index+1]/255;
    var b = srcData[index+2]/255;
    var a = srcData[index+3]/255;
    
    var y = 0.2126*r + 0.7152*g + 0.0722*b;
    
    var rgba = TentaGL.Color.HSBAtoRGBA(0, 0, y, a);
  //  console.log(rgba);
    r = (rgba[0]*255)&0xFF;
    g = (rgba[1]*255)&0xFF;
    b = (rgba[2]*255)&0xFF;
    a = (rgba[3]*255)&0xFF;
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.Grayscale, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that inverts the RGB values of the pixels.
 * @constructor
 */
TentaGL.RGBAFilter.Invert = function() {
};


TentaGL.RGBAFilter.Invert.prototype = {
  
  constructor:TentaGL.RGBAFilter.Invert,
  
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    r = 255 - r;
    g = 255 - g;
    b = 255 - b;
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.Invert, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that uses the pixels of one image as a mask region
 * for the pixels. The pixels in the mask map image whose alpha components 
 * are > 0 define the masking region. 
 * Pixels inside the masking region have their alpha components
 * set to 0.
 * @constructor
 * @param {TentaGL.PixelData} maskMapPixelData  The PixelData to be used 
 *      as the mask map.
 */
TentaGL.RGBAFilter.MaskMap = function(maskMapPixelData) {
  this._maskData = maskMapPixelData.getData();
};


TentaGL.RGBAFilter.MaskMap.prototype = {
  
  constructor:TentaGL.RGBAFilter.MaskMap,
  
  
  /** 
   * Returns the uint8 pixel array for the mask map.
   * @return {Uint8Array}
   */
  getMaskData:function() {
    return this._maskData;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    if(this._maskData[index+3] > 0) {
      a = 0;
    }
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.MaskMap, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that multiplies a color's normalized RGB values by all pixels.
 * @constructor
 * @param {TentaGL.Color} color  The multiplicative color.
 */
TentaGL.RGBAFilter.MulColor = function(color) {
  this._color = color;
};


TentaGL.RGBAFilter.MulColor.prototype = {
  
  constructor:TentaGL.RGBAFilter.MulColor,
  
  
  /**
   * Returns the color being used by this filter for transparency.
   * @return {TentaGL.Color}
   */
  getColor:function() {
    return this._color;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    r *= this._color.getRed();
    g *= this._color.getGreen();
    b *= this._color.getBlue();
    a *= this._color.getAlpha();
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


/** 
 * Creates a MulColor filter for a color defined by normalized rgb values. 
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a  Optional. Default 1.
 * @return {TentaGL.RGBAFilter.MulColor}
 */
TentaGL.RGBAFilter.MulColor.RGBA = function(r, g, b, a) {
  var color = TentaGL.Color.RGBA(r, g, b, a);
  return new TentaGL.RGBAFilter.MulColor(color);
};







Util.Inheritance.inherit(TentaGL.RGBAFilter.MulColor, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Clears all pixels whose RGB values do not match the specified color within some tolerance. 
 * Those pixels are set to RGBA = [0,0,0,0]. All matching pixels are kept and
 * have their alpha components set to 255.
 * @constructor
 * @param {TentaGL.Color} color
 * @param {Number} tolerance  Optional. A tolerance level in range [0, 1]. Default 0.
 */
TentaGL.RGBAFilter.OneColor = function(color, tolerance) {
  if(!tolerance) {
    tolerance = 0;
  }
  
  this._color = color;
  this._tolerance = tolerance;
};

TentaGL.RGBAFilter.OneColor.prototype = {
  
  constructor:TentaGL.RGBAFilter.OneColor,
  
  
  /** Returns the color for this filter. */
  getColor:function() {
    return this._color;
  },
  
  /** 
   * Returns the tolerance level for this filter.
   * @return {Number}
   */
  getTolerance:function() {
    return this._tolerance;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    var dr = Math.abs(r-this._color.getRedByte())/255;
    var dg = Math.abs(g-this._color.getGreenByte())/255;
    var db = Math.abs(b-this._color.getBlueByte())/255;
    
    if(dr*dr + dg*dg + db*db > this._tolerance*this._tolerance) {
      r = 0;
      g = 0;
      b = 0;
      a = 0;
    }
    else {
      r = this._color.getRedByte();
      g = this._color.getGreenByte();
      b = this._color.getBlueByte();
      a = 255;
    }
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


Util.Inheritance.inherit(TentaGL.RGBAFilter.OneColor, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that adds a colored outline around the opaque parts of an image.
 * @constructor
 * @param {TentaGL.Color} color  The color used for the outline.
 */
TentaGL.RGBAFilter.OutlineColor = function(color) {
  this._color = color;
};


TentaGL.RGBAFilter.OutlineColor.prototype = {
  
  constructor:TentaGL.RGBAFilter.OutlineColor,
  
  
  /**
   * Returns the color being used by this filter for transparency.
   * @return {TentaGL.Color}
   */
  getColor:function() {
    return this._color;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    // If at a translucent pixel, check for any surrounding opaque pixels.
    if(a != 255) {
      var xy = TentaGL.PixelData.indexToXY(index, width);
      var x = xy[0];
      var y = xy[1];
      
      for(var i=-1;  i <= 1; i++) {
        var y2 = y + i;
        if(y2 >= height || y2 < 0) {
          continue;
        }
        
        for(var j=-1; j <= 1; j++) {
          var x2 = x + j;
          if(x2 >= width || x2 < 0) {
            continue;
          }
          
          var index2 = TentaGL.PixelData.xyToIndex(x2, y2, width);
          var a2 = srcData[index2+3];
          
          // An adjacent pixel is opaque. Use the outline color.
          if(a2 == 255) {
            r = this._color.getRedByte();
            g = this._color.getGreenByte();
            b = this._color.getBlueByte();
            return this.setPixel(dstData, index, r, g, b, 255);
          }
        }
      }
    }
    
    // Not on the outline region. Use existing pixel color.
    this.setPixel(dstData, index, r, g, b, a);
  }
};


/** 
 * Creates a OutlineColor filter for a color defined by uint8 rgb values. 
 * @param {uint8} r
 * @param {uint8} g
 * @param {uint8} b
 * @return {TentaGL.RGBAFilter.OutlineColor}
 */
TentaGL.RGBAFilter.OutlineColor.RGBBytes = function(r, g, b) {
  var color = TentaGL.Color.RGBABytes(r, g, b);
  return new TentaGL.RGBAFilter.OutlineColor(color);
};



Util.Inheritance.inherit(TentaGL.RGBAFilter.OutlineColor, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that subtract a color's RGB value to all pixels.
 * @constructor
 * @param {TentaGL.Color} color  The subtractive color.
 */
TentaGL.RGBAFilter.SubColor = function(color) {
  this._color = color;
};


TentaGL.RGBAFilter.SubColor.prototype = {
  
  constructor:TentaGL.RGBAFilter.SubColor,
  
  
  /**
   * Returns the color being used by this filter for transparency.
   * @return {TentaGL.Color}
   */
  getColor:function() {
    return this._color;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    r = TentaGL.Math.clamp(r - this._color.getRedByte(), 0, 255);
    g = TentaGL.Math.clamp(g - this._color.getGreenByte(), 0, 255);
    b = TentaGL.Math.clamp(b - this._color.getBlueByte(), 0, 255);
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


/** 
 * Creates a SubColor filter for a color defined by uint8 rgb values. 
 * @param {uint8} r
 * @param {uint8} g
 * @param {uint8} b
 * @return {TentaGL.RGBAFilter.SubColor}
 */
TentaGL.RGBAFilter.SubColor.RGBBytes = function(r, g, b) {
  var color = TentaGL.Color.RGBABytes(r, g, b);
  return new TentaGL.RGBAFilter.SubColor(color);
};



Util.Inheritance.inherit(TentaGL.RGBAFilter.SubColor, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An RGBA filter that causes all pixels with some RGB value to become 
 * completely transparent.
 * @constructor
 * @param {TentaGL.Color} transparentColor  The color to be made transparent.
 */
TentaGL.RGBAFilter.TransparentColor = function(transparentColor) {
  this._tColor = transparentColor;
};


TentaGL.RGBAFilter.TransparentColor.prototype = {
  
  constructor:TentaGL.RGBAFilter.TransparentColor,
  
  
  /**
   * Returns the color being used by this filter for transparency.
   * @return {TentaGL.Color}
   */
  getTransparentColor:function() {
    return this._tColor;
  },
  

  /** See TentaGL.RGBAFilter.apply */
  filter:function(dstData, srcData, index, width, height) {
    var r = srcData[index];
    var g = srcData[index+1];
    var b = srcData[index+2];
    var a = srcData[index+3];
    
    var tr = this._tColor.getRedByte();
    var tg = this._tColor.getGreenByte();
    var tb = this._tColor.getBlueByte();
    
    if(r == tr && g == tg && b == tb) {
      a = 0;
    }
    
    this.setPixel(dstData, index, r, g, b, a);
  }
};


/** 
 * Creates a TransparentColor filter for a color defined by uint8 rgb values. 
 * @param {uint8} r
 * @param {uint8} g
 * @param {uint8} b
 * @return {TentaGL.RGBAFilter.TransparentColor}
 */
TentaGL.RGBAFilter.TransparentColor.RGBBytes = function(r, g, b) {
  var tColor = TentaGL.Color.RGBABytes(r, g, b);
  return new TentaGL.RGBAFilter.TransparentColor(tColor);
};



Util.Inheritance.inherit(TentaGL.RGBAFilter.TransparentColor, TentaGL.RGBAFilter);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a Keyboard input object for an Application.
 * @constructor
 * @param {DOM div element} container  The div element containing the WebGL Canvas. For 
 *      the div to be able to receive focus, set its "tabindex" attribute to 
 *      not -1.
 */
TentaGL.Keyboard = function(container) {
  this._isPressed = [];
  this._justPressed = [];
  this._justReleased = [];
  this._repPressed = [];
  
  this._pressedSinceLast = [];
  this._releasedSinceLast = [];
  
  var self = this; // Closure magic!
  
  var keyDownHandler = function(evt) {
  //  console.log("key down: " + evt.keyCode);
    self._pressedSinceLast[evt.keyCode] = true;
    evt.preventDefault();
  };
  
  var keyUpHandler = function(evt) {
  // console.log("key up: " + evt.keyCode);
    self._releasedSinceLast[evt.keyCode] = true;
    evt.preventDefault();
  };
  
  container.addEventListener("keydown", keyDownHandler, false);
  container.addEventListener("keyup", keyUpHandler, false);
};



TentaGL.Keyboard.prototype = {
  constructor:TentaGL.Keyboard,
  
  /** Polls for updated keyboard input state. */
  poll:function() {
    this._justPressed = [];
    this._justReleased = [];
    this._repPressed = [];
    
    // Check for keys pressed.
    for(var keyCode in this._pressedSinceLast) {
      if(!this._isPressed[keyCode]) {
        this._justPressed[keyCode] = true;
      }
      this._isPressed[keyCode] = true;
      this._repPressed[keyCode] = true;
    }
    
    // Check for keys released.
    for(var keyCode in this._releasedSinceLast) {
      this._justReleased[keyCode] = true;
      this._isPressed[keyCode] = false;
    }
    
    this._pressedSinceLast = [];
    this._releasedSinceLast = [];
  },
  
  
  
  /** Returns whether a key is currently pressed. */
  isPressed:function(keyCode) {
    return (this._isPressed[keyCode] || false);
  },
  
  /** Returns whether a key was just pressed. */
  justPressed:function(keyCode) {
    return (this._justPressed[keyCode] || false);
  },
  
  /** Returns whether a key was just released. */
  justReleased:function(keyCode) {
    return (this._justReleased[keyCode] || false);
  },
  
  /** Returns whether a key was just pressed or is repeat-pressing. */
  isPressedRepeating:function(keyCode) {
    return (this._repPressed[keyCode] || false);
  }
};



/** A global collection of constants for keyboard keycodes. */
var KeyCode = {
  BACK_SPACE : 8,
  TAB : 9,
  ENTER : 13,
  SHIFT : 16,
  CTRL : 17,
  ALT : 18,
  PAUSE: 19,
  CAPS_LOCK : 20,
  ESCAPE : 27,
  SPACE : 32,
  PAGE_UP : 33,
  PAGE_DOWN : 34,
  END : 35,
  HOME : 36,
  LEFT : 37,
  UP : 38,
  RIGHT : 39,
  DOWN : 40,
  INSERT : 45,
  DELETE : 46,
  NUM0 : 48,
  NUM1 : 49,
  NUM2 : 50,
  NUM3 : 51,
  NUM4 : 52,
  NUM5 : 53,
  NUM6 : 54,
  NUM7 : 55,
  NUM8 : 56,
  NUM9 : 57,
  A : 65,
  B : 66,
  C : 67,
  D : 68,
  E : 69,
  F : 70,
  G : 71,
  H : 72,
  I : 73,
  J : 74,
  K : 75,
  L : 76,
  M : 77,
  N : 78,
  O : 79,
  P : 80,
  Q : 81,
  R : 82,
  S : 83,
  T : 84,
  U : 85,
  V : 86,
  W : 87,
  X : 88,
  Y : 89,
  Z : 90,
  NUMPAD0 : 96,
  NUMPAD1 : 97,
  NUMPAD2 : 98,
  NUMPAD3 : 99,
  NUMPAD4 : 100,
  NUMPAD5 : 101,
  NUMPAD6 : 102,
  NUMPAD7 : 103,
  NUMPAD8 : 104,
  NUMPAD9 : 105,
  MULTIPLY : 106,
  ADD : 107,
  SUBTRACT : 109,
  DECIMAL : 110,
  DIVIDE : 111,
  F1 : 112,
  F2 : 113,
  F3 : 114,
  F4 : 115,
  F5 : 116,
  F6 : 117,
  F7 : 118,
  F8 : 119,
  F9 : 120,
  F10 : 121,
  F11 : 122,
  F12 : 123,
  NUM_LOCK: 144,
  SCROLL_LOCK : 145,
  SEMICOLON : 186,
  EQUALS : 187,
  COMMA : 188,
  MINUS : 189,
  PERIOD : 190,
  SLASH : 191,
  BACK_QUOTE : 192,
  BRACELEFT : 219,
  BACK_SLASH : 220,
  BRACERIGHT : 221,
  QUOTE : 222
};




/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a mouse input object for an Application. 
 * This keeps track of mouse detection, mouse presses and releases for the 
 * left, middle, and right buttons, and vertical and horizontal mouse wheel 
 * scroll detection.
 * @constructor
 * @param {DOM canvas element} canvas  The canvas element containing the application.
 */
TentaGL.Mouse = function(canvas) {
  
  this._canvas = canvas;
  
  this._xy = [0, 0];
  this._xyPage = [0, 0];
  this._mouseMovedSinceLast = false;
  this._mouseMoved = false;
  this._pressedSinceLast = [];
  this._releasedSinceLast = [];
  
  this._isPressed = [];
  this._justPressed = [];
  this._justReleased = [];
  
  this._clickCount = [];
  this._clickCount[TentaGL.Mouse.LEFT] = 0;
  this._clickCount[TentaGL.Mouse.MIDDLE] = 0;
  this._clickCount[TentaGL.Mouse.MIDDLE] = 0;
  this._lastClickTime = [];
  this._lastClickTime[TentaGL.Mouse.LEFT] = 0;
  this._lastClickTime[TentaGL.Mouse.MIDDLE] = 0;
  this._lastClickTime[TentaGL.Mouse.MIDDLE] = 0;
  this._multiClickTime = 400;
  
  this._wheelTicksXSinceLast = 0;
  this._wheelTicksYSinceLast = 0;
  this._wheelTicksX = 0;
  this._wheelTicksY = 0;
  
  var self = this; // closure magic!
  
  canvas.onmousemove = function(evt) {
    var xy = TentaGL.DOM.getAbsolutePosition(this);
    var rect = canvas.getBoundingClientRect();
    var left = TentaGL.Math.clamp(Math.floor(rect.left), 0, canvas.width);
    var top = TentaGL.Math.clamp(Math.floor(rect.top), 0, canvas.height);
    
    xy = [evt.clientX - left, evt.clientY - top];
    var xyPage = [evt.pageX, evt.pageY];
    
    self._xy = xy;
    self._xyPage = xyPage;
    self._mouseMovedSinceLast = true;
  };
  
  
  // Prevent right-click from opening the context menu.
  canvas.oncontextmenu = function(evt) {
    return false;
  };
  
  
  canvas.onmousedown = function(evt) {
  //  console.log(evt);
    self._pressedSinceLast[evt.which] = true;
    
    var now = Date.now();
    var dt = now - self._lastClickTime[evt.which];
    self._lastClickTime[evt.which] = now;
    
    if(dt < self._multiClickTime) {
      self._clickCount[evt.which]++;
    }
    else {
      self._clickCount[evt.which] = 1;
    }
  };
  
  canvas.onmouseup = function(evt) {
  //  console.log(evt);
    self._releasedSinceLast[evt.which] = true;
  };
  
  canvas.onmousewheel = function(evt) {
  //  console.log(evt);
    if(evt.wheelDeltaY < 0) {
      self._wheelTicksYSinceLast--;
    }
    else if(evt.wheelDeltaY > 0) {
      self._wheelTicksYSinceLast++;
    }
    
    if(evt.wheelDeltaX < 0) {
      self._wheelTicksXSinceLast--;
    }
    else if(evt.wheelDeltaX > 0) {
      self._wheelTicksXSinceLast++;
    }
    
    evt.preventDefault();
  };
};


// Mouse buttons constants for all browsers except IE.
TentaGL.Mouse.LEFT = 1;
TentaGL.Mouse.MIDDLE = 2;
TentaGL.Mouse.RIGHT = 3;


TentaGL.Mouse.prototype = {
  constructor:TentaGL.Mouse, 
  
  /**
   * Polls for the current mouse state since the last time this was called.
   */
  poll:function() {
    
    this._justPressed = [];
    this._justReleased = [];
    
    this._wheelTicksX = this._wheelTicksXSinceLast;
    this._wheelTicksY = this._wheelTicksYSinceLast;
    this._wheelTicksXSinceLast = 0;
    this._wheelTicksYSinceLast = 0;
    
    this._mouseMoved = this._mouseMovedSinceLast;
    this._mouseMovedSinceLast = false;
    
    // Check for presses.
    for(var i in this._pressedSinceLast) {
      if(!this._isPressed[i]) {
        this._justPressed[i] = true;
      }
      this._isPressed[i] = true;
    }
    
    // Check for releases.
    for(var i in this._releasedSinceLast) {
      this._isPressed[i] = false;
      this._justReleased[i] = true;
    }
    
    
    this._pressedSinceLast = [];
    this._releasedSinceLast = [];
  }, 
  
  
  /**
   * Returns the XY position of the mouse relative to its container.
   */
  getXY:function() {
    return [this._xy[0], this._xy[1]];
  },
  
  /**
   * Returns the X position of the mouse relative to its container.
   */
  getX:function() {
    return this._xy[0];
  },
  
  /** 
   * Returns the Y position of the mouse relative to its container.
   */
  getY:function() {
    return this._xy[1];
  },
  
  
  /** Returns the XY position of the mouse in page coordinates. */
  getPageXY:function() {
    return [this._xyPage[0], this._xyPage[1]];
  },
  
  
  /** Returns the X position of the mouse in page coordinates. */
  getPageX:function() {
    return this._xyPage[0];
  },
  
  
  /** Returns the Y position of the mouse in page coordinates. */
  getPageY:function() {
    return this._xyPage[1];
  },
  
  
  /** 
   * Returns true if the mouse has moved since the last poll. 
   */
  hasMoved:function() {
    return this._mouseMoved;
  },
  
  /** 
   * Returns true if the left mouse button is currently being pressed.
   */
  isLeftPressed:function() {
    return this._isPressed[TentaGL.Mouse.LEFT] || false;
  },
  
  /** 
   * Returns true if the left mouse button was just pressed.
   */
  justLeftPressed:function() {
    return this._justPressed[TentaGL.Mouse.LEFT] || false;
  },
  
  /**
   * Returns true if the left mouse button was just released.
   */
  justLeftReleased:function() {
    return this._justReleased[TentaGL.Mouse.LEFT] || false;
  },
  
  /** 
   * Returns the number of clicks associated with the last series of left mouse 
   * presses. 
   */
  leftClickCount:function() {
    return this._clickCount[TentaGL.Mouse.LEFT];
  },
  
  
  /** 
   * Returns true if the middle mouse button is currently being pressed.
   */
  isMiddlePressed:function() {
    return this._isPressed[TentaGL.Mouse.MIDDLE] || false;
  },
  
  /** 
   * Returns true if the middle mouse button was just pressed.
   */
  justMiddlePressed:function() {
    return this._justPressed[TentaGL.Mouse.MIDDLE] || false;
  },
  
  /**
   * Returns true if the middle mouse button was just released.
   */
  justMiddleReleased:function() {
    return this._justReleased[TentaGL.Mouse.MIDDLE] || false;
  },
  
  /** 
   * Returns the number of clicks associated with the last series of middle  
   * mouse presses. 
   */
  middleClickCount:function() {
    return this._clickCount[TentaGL.Mouse.MIDDLE];
  },
  
  
  
  
  /** 
   * Returns true if the right mouse button is currently being pressed.
   */
  isRightPressed:function() {
    return this._isPressed[TentaGL.Mouse.RIGHT] || false;
  },
  
  /** 
   * Returns true if the right mouse button was just pressed.
   */
  justRightPressed:function() {
    return this._justPressed[TentaGL.Mouse.RIGHT] || false;
  },
  
  /**
   * Returns true if the right mouse button was just released.
   */
  justRightReleased:function() {
    return this._justReleased[TentaGL.Mouse.RIGHT] || false;
  },
  
  /** 
   * Returns the number of clicks associated with the last series of right  
   * mouse presses. 
   */
  rightClickCount:function() {
    return this._clickCount[TentaGL.Mouse.RIGHT];
  },
  
  
  /**  
   * Returns the number of times the mouse wheel has scrolled up since the 
   * last poll.
   */
  scrollUpAmount:function() {
    return Math.abs(Math.max(this._wheelTicksY, 0));
  },
  
  /**  
   * Returns the number of times the mouse wheel has scrolled down since the 
   * last poll.
   */
  scrollDownAmount:function() {
    return Math.abs(Math.min(this._wheelTicksY, 0));
  },
  
  /**  
   * Returns the number of times the mouse wheel has scrolled left since the 
   * last poll.
   */
  scrollLeftAmount:function() {
    return Math.abs(Math.min(this._wheelTicksX, 0));
  },
  
  /**  
   * Returns the number of times the mouse wheel has scrolled right since the 
   * last poll.
   */
  scrollRightAmount:function() {
    return Math.abs(Math.max(this._wheelTicksX, 0));
  },
  
  
  
  /** 
   * Returns the width of the canvas the mouse is bound to.
   * @return {number}
   */
  getCanvasWidth: function() {
    return canvas.width;
  },
  
  
  /** 
   * Returns the height of the canvas the mouse is bound to.
   * @return {number}
   */
  getCanvasHeight: function() {
    return canvas.height;
  }
};




/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Base class for various types of lights. 
 * @constructor
 * @param {TentaGL.Color} diffuse   The color of reflected light being  
 *      scattered in all directions.
 * @param {TentaGL.Color} specular  The shiny color of the reflected light.
 * @param {TentaGL.Color} ambient   The color of uniform lighting contributed 
 *      to the scene, not dependent upon the angle of reflection. 
 */
TentaGL.Light = function(diffuse, specular, ambient) {
  if(!diffuse) {
    diffuse = TentaGL.Color.RGBA(1, 1, 1, 1);
  }
  if(!specular) {
    specular = TentaGL.Color.RGBA(1, 1, 1, 1);
  }
  if(!ambient) {
    ambient = TentaGL.Color.RGBA(0, 0, 0, 1);
  }
  
  this._diffuse = diffuse;
  this._specular = specular;
  this._ambient = ambient;
};


TentaGL.Light.prototype = {
  
  constructor: TentaGL.Light,
  
  isaLight: true,
  
  /** 
   * Returns the light's diffuse color.
   * @return {TentaGL.Color}
   */
  getDiffuse: function() {
    return this._diffuse;
  },
  
  
  /** 
   * Sets the light's diffuse color.
   * @param {TentaGL.Color} diffuse
   */
  setDiffuse: function(diffuse) {
    this._diffuse = diffuse;
  },
  
  
  /** 
   * Returns the light's specular color.
   * @return {TentaGL.Color}
   */
  getSpecular: function() {
    return this._specular;
  },
  
  
  /** 
   * Sets the light's specular color.
   * @param {TentaGL.Color} specular
   */
  setSpecular: function(specular) {
    this._specular = specular;
  },
  
  
  /** 
   * Return's the light's ambient color.
   */
  getAmbient: function() {
    return this._ambient;
  },
  
  
  /** 
   * Sets the light's ambient color.
   */
  setAmbient: function(ambient) {
    this._ambient = ambient;
  },
  
  
  /** 
   * Renders an object to represent the light, for debugging. 
   * @param {WebGLRenderingContext} gl
   */
  render: function(gl) {}
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * The most basic light, providing uniform lighting to the scene. 
 * This type of light doesn't contribute any diffuse or specular lighting.
 * @constructor
 * @param {TentaGL.Color} color   The ambient light color.
 */
TentaGL.AmbientLight = function(color) {
  TentaGL.Light.call(this, TentaGL.Color.RGBA(0,0,0,1), TentaGL.Color.RGBA(0,0,0,1), color);
};

TentaGL.AmbientLight.prototype = {
  
  constructor: TentaGL.AmbientLight,
  
  isaAmbientLight: true
  
};

Util.Inheritance.inherit(TentaGL.AmbientLight, TentaGL.Light);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * An effectively infinitely distant light source radiating light in a single 
 * direction. 
 * @param {vec3} direction    The direction toward the light source.
 * @param {TentaGL.Color} diffuse   Optional.
 * @param {TentaGL.Color} specular  Optional.
 * @param {TentaGL.Color} ambient   Optional.
 */
TentaGL.DirectionalLight = function(direction, diffuse, specular, ambient) {
  TentaGL.Light.call(this, diffuse, specular, ambient);
  
  this._direction = direction;
};

TentaGL.DirectionalLight.prototype = {
  
  constructor: TentaGL.DirectionalLight,
  
  isaDirectionalLight: true,
  
  
  /** 
   * Returns the direction of the light.
   * @return {vec3}
   */
  getDirection: function() {
    return this._direction;
  },
  
  
  /** 
   * Sets the direction of the light.
   * @param {vec3} direction
   */
  setDirection: function(direction) {
    this._direction[0] = direction[0];
    this._direction[1] = direction[1];
    this._direction[2] = direction[2];
  },
  
  
  /** 
   * Renders an object to represent the light, for debugging. 
   * @param {WebGLRenderingContext} gl
   */
  render: function(gl) {
    (new TentaGL.Math.Sphere(1, this._direction)).render(gl, "white");
  }
};

Util.Inheritance.inherit(TentaGL.DirectionalLight, TentaGL.Light);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A light radiating from a point in all directions. 
 * @constructor
 * @param {vec3} xyz    The position of the light source.
 * @param {TentaGL.Color} diffuse   Optional.
 * @param {TentaGL.Color} specular  Optional.
 * @param {TentaGL.Color} ambient   Optional.
 */
TentaGL.PointLight = function(xyz, diffuse, specular, ambient) {
  TentaGL.Light.call(this, diffuse, specular, ambient);
  
  this._xyz = vec4.clone(xyz);
  this._xyz[3] = 1;
  this._attenuation = [1, 0, 0];
}

TentaGL.PointLight.prototype = {
  
  constructor: TentaGL.PointLight,
  
  isaPointLight: true,
  
  /** 
   * Returns the position of the light.
   * @return {vec4}
   */
  getXYZ: function() {
    return this._xyz;
  },
  
  
  /** 
   * Sets the position of the light. 
   * @param {vec3} xyz
   */
  setXYZ: function(xyz) {
    this._xyz[0] = xyz[0];
    this._xyz[1] = xyz[1];
    this._xyz[2] = xyz[2];
  },
  
  
  /** 
   * Returns the attenuation coefficients for the light. Unless
   * the coefficients are set through the setAttenuation method, they are 
   * a=1, b=0, c=0. This causes the light to be the same intensity at all 
   * distances.
   * @return {array: [constant: number, linear: number, quadratic: number]}
   */
  getAttenuation: function() {
    var result = [];
    result[0] = this._attenuation[0];
    result[1] = this._attenuation[1];
    result[2] = this._attenuation[2];
    return result;
  },
  
  /** 
   * Sets the attenuation coefficients for the light. These
   * define how the intensity of the light degrades relative to distance.
   * @param {number} a    The constant coefficient. 
   * @param {number} b    The linear coefficient.
   * @param {number} c    The quadratic coefficient.
   */
  setAttenuation: function(a, b, c) {
    this._attenuation[0] = a;
    this._attenuation[1] = b;
    this._attenuation[2] = c;
  },
  
  /** 
   * Renders an object to represent the light, for debugging. 
   * @param {WebGLRenderingContext} gl
   */
  render: function(gl) {
    (new TentaGL.Math.Sphere(1, this._xyz)).render(gl);
  }
};

Util.Inheritance.inherit(TentaGL.PointLight, TentaGL.Light);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A point-light that projects light in some direction in a cone-shaped area.
 * @param {vec3} xyz
 * @param {vec3} direction
 * @param {number} cutOffAngle    The cut-off angle, in radians.
 * @param {number} spotExponent   The exponent defining the rate of decay for 
 *      light intensity towards the edge of the splotlight cone.
 * @param {TentaGL.Color} diffuse   Optional.
 * @param {TentaGL.Color} specular  Optional.
 * @param {TentaGL.Color} ambient   Optional.
 */
TentaGL.SpotLight = function(xyz, direction, cutOffAngle, spotExponent, diffuse, specular, ambient) {
  TentaGL.PointLight.call(this, xyz, diffuse, specular, ambient);
  TentaGL.DirectionalLight.call(this, direction, diffuse, specular, ambient);
  
  this._angle = cutOffAngle;
  this._spotExp = spotExponent;
};


TentaGL.SpotLight.prototype = {
  
  constructor: TentaGL.SpotLight,
  
  isaSpotLight: true,
  
  /** 
   * Returns the cut-off angle for the spotlight, in radians.
   * This is the angle between the spotlight's direction vector and the edge of
   * its cone.
   * @return {number}
   */
  getCutOffAngle: function() {
    return this._angle;
  },
  
  /** 
   * Sets the cut-off angle for the spotlight, in radians. 
   * @param {number} angle
   */
  setCutOffAngle: function(angle) {
    this._angle = angle;
  },
  
  
  /** 
   * Returns the spotlight's decay exponent.
   * @return {number}
   */
  getSpotExponent: function() {
    return this._spotExp;
  },
  
  
  /** 
   * Sets the spotlight's decay exponent.
   * @param {number} exp
   */
  setSpotExponent: function(exp) {
    this._spotExp = exp;
  }
  
};


Util.Inheritance.inherit(TentaGL.SpotLight, TentaGL.PointLight);
Util.Inheritance.inherit(TentaGL.SpotLight, TentaGL.DirectionalLight);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A structure for managing the lights in a scene.
 * @constructor
 * @param {uint} maxLights    The maximum number of lights allowed by shaders 
 *      using this manager. 
 */
TentaGL.LightManager = function(maxLights) {
  this._lights = [];
  this._maxLights = maxLights;
};


TentaGL.LightManager.prototype = {
  
  constructor: TentaGL.LightManager,
  
  isaLightManager: true, 
  
  
  /** 
   * Adds a Light to the manager. 
   * @param {TentaGL.Light} light
   */
  add: function(light) {
    if(this._lights.length == this._maxLights) {
      throw new Error("Too many lights.");
    }
    else {
      this._lights.push(light);
    }
  },
  
  
  /** 
   * Returns the nth light stored in this manager.
   * @param {uint} n
   * @return {TentaGL.Light}
   */
  get: function(n) {
    return this._lights[n];
  },
  
  
  /** 
   * Returns a list of all the lights in the manager.
   * @return {array: TentaGL.Light}
   */
  getAll: function() {
    var result = [];
    for(var i=0; i<this._lights.length; i++) {
      result.push(this._lights[i]);
    }
    return result;
  },
  
  
  /** 
   * Removes a light from the manager. 
   * @param {TentaGL.Light} light
   */
  remove: function(light) {
    var index = this._lights.indexOf(light);
    if(index < 0) {
      throw new Error("Could not remove light.");
    }
    else {
      this._lights.splice(index, 1);
    }
  },
  
  
  /** 
   * Clears all lights from the manager. 
   */
  removeAll: function() {
    this._lights = [];
  },
  
  
  /** 
   * Returns the number of lights stored in this manager.
   * @return {uint}
   */
  getCount: function() {
    return this._lights.length;
  },
  
  
  /** 
   * Returns the maximum number of lights allowed in this manager.
   * @return {uint}
   */
  getMaxCount: function() {
    return this._maxLights;
  },
  
  
  /** 
   * Sets the current shader program to use the lights from this manager.
   * @param {WebGLRenderingContext} gl
   */
  useMe: function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    if(program.setLights) {
      program.setLights(gl, this.getAll());
    }
  },
  
  
  render: function(gl) {
    for(var i=0; i<this._lights.length; i++) {
      this._lights[i].render(gl);
    }
  }
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** Interface for materials that can be used to color texels in a model. */
TentaGL.Material = function() {};

TentaGL.Material.prototype = {
  
  isaMaterial: true,
  
  /** 
   * Cleans up any GL resources associated with the Material. 
   * The resources are deleted from GL memory using the appropriate WebGL
   * context function calls.
   * @param {WebGLRenderingContext} gl
   */
  clean:function(gl) {},
  
  /**
   * Binds the GL context to use this material for rendering models.
   * @param {WebGLRenderingContext} gl
   */
  useMe:function(gl) {},
  
  /** 
   * Returns true if all resources for this material (such as external images)
   * have finished loading. Returns true by default.
   * @return Boolean
   */
  isLoaded:function() {}
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a texture that can have scenes rendered onto it with a GL context.
 * For a shader to be able to use a BufferedTexture as a material, it must have
 * its uniform variable for storing texture0 bound, using its bindTex0Uni
 * method when the program is initialized.
 * @constructor
 * @param {WebGLRenderingContext} gl
 * @param {int} width   The desired width of the texture.
 * @param {int} height  The desired height of the texture.
 * @param {TentaGL.Color} clearColor    Optional. The clear color for the buffer.
 */
TentaGL.BufferTexture = function(gl, width, height, clearColor) {
  this._width = width;
  this._height = height;
  this._clearColor = clearColor || TentaGL.Color.RGBA(0, 0, 0, 0);
  
  // Create the frame buffer.
  this._frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(GL_FRAMEBUFFER, this._frameBuffer);
  
  // Bind the texture to receive the colors.
  this._tex = TentaGL.Texture.create(gl, null, width, height);
  gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this._tex, 0);
  
  // Bind a RenderBuffer to store depth data.
  this._depth = TentaGL.DepthBuffer.createBuffer(gl, width, height);
  gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, this._depth);
  
  gl.bindTexture(GL_TEXTURE_2D, null);
  gl.bindRenderbuffer(GL_RENDERBUFFER, null);
  gl.bindFramebuffer(GL_FRAMEBUFFER, null);
};



TentaGL.BufferTexture.prototype = {
  
  constructor:TentaGL.BufferTexture,
  
  isaBufferTexture: true,
  
  
  /** Removes the Texture and the FrameBuffer from GL memory. */
  clean:function(gl) {
    gl.deleteFramebuffer(this._frameBuffer);
    gl.deleteTexture(this._tex);
    gl.deleteRenderbuffer(this._depth);
  },
  
  
  /** True. */
  isLoaded:function() {
    return true;
  },
  
  
  /** 
   * Renders a scene to this BufferTexture.
   * @param {WebGLRenderingContext} gl
   * @param {function} renderFunc   A function that accepts a single parameter 
   *      - a WebGLRenderingContext - which renders a scene.
   */
  renderToMe:function(gl, renderFunc) {
    var oldViewport = TentaGL.Viewport.get(gl);
    
    gl.bindFramebuffer(GL_FRAMEBUFFER, this._frameBuffer);
    TentaGL.Viewport.set(gl, [0, 0, this._width, this._height]);
    TentaGL.clear(gl, this._clearColor);
    renderFunc(gl);
    
    gl.bindFramebuffer(GL_FRAMEBUFFER, null);
    TentaGL.Viewport.set(gl, oldViewport);
  },
  
  
  /** 
   * Returns a PixelData object containing the current pixel data 
   * for this texture. 
   * @param {WebGLRenderingContext} gl
   * @param {int} x Optional. X position of lower-left corner of area containing 
   *      the pixel data. Defaults to 0, the extreme left of the texture.
   * @param {int} y Optional. Y position of lower-left corner of area containing
   *      the pixel data. Defaults to 0, the extreme bottom of the texture.
   * @param {int} w Optional. The width of the area containing the pixel data. 
   *      Defaults to the width of this texture.
   * @param {int} h Optional. The height of the area containing the pixel data.
   *      Defaults to the height of this texture.
   * @param {Uint8Array} bytes      Optional. A pre-allocated byte array to store 
   *      the pixel data in. The size of this array should be at least 4*w*h. 
   * @return {TentaGL.PixelData}
   */
  getPixelData:function(gl, x, y, w, h, bytes) {
      x = x || 0;
      y = y || 0;
      w = w || this._width - x;
      h = h || this._height - y;
      
      return TentaGL.PixelData.fromGLTexture(gl, this._tex, x, y, w, h, bytes);
  },
  
  
  /** 
   * Sets up the currently bound ShaderProgram so that its sampler2D uniform
   * variable "tex" will use this texture.
   * @param {WebGLRenderingContext} gl
   */
  useMe:function(gl) {
    gl.activeTexture(GL_TEXTURE0);
    gl.bindTexture(GL_TEXTURE_2D, this._tex);
    TentaGL.ShaderLib.current(gl).setTex(gl, 0);
  }
};


Util.Inheritance.inherit(TentaGL.BufferTexture, TentaGL.Material);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A material for a bump-mapped texture.
 * @constructor
 * @param {string} colorTexName    The name of the main texture, 
 *      used for pixel colors.
 * @param {string} bumpTexName     The name of the bump-map texture, 
 *      used for surface normal offsets.
 */
TentaGL.BumpMappedTexture = function(colorTexName, bumpTexName) {
  this._color = colorTexName;
  this._bump = bumpTexName;
};


TentaGL.BumpMappedTexture.prototype = {
  
  constructor: TentaGL.BumpMappedTexture,
  
  isaBumpMappedTexture: true,
  
  /** 
   * Returns the name of the texture used for pixel colors.
   * @return {string}
   */
  getColorTextureName: function() {
    return this._color;
  },
  
  
  /** 
   * Returns the texture used for pixel colors.
   * @param {WebGLRenderingContext} gl
   * @return {TentaGL.Texture}
   */
  getColorTexture: function(gl) {
    return TentaGL.MaterialLib.get(gl, this._color);
  },  
  
  
  /** 
   * Returns the name of the texture used for the bump-map.
   * @return {string}
   */
  getBumpTextureName: function() {
    return this._bump;
  },
  
  /** 
   * Returns the texture used for the bump-map.
   * @param {WebGLRenderingContext} gl
   * @return {TentaGL.Texture}
   */
  getBumpTexture: function(gl) {
    return TentaGL.MaterialLib.get(gl, this._bump);
  },
  
  /** 
   * Uses the bump-mapped shader in the shader currently being used. 
   * @param {WebGLRenderingContext} gl
   */
  useMe: function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    
    this.getColorTexture(gl).useMe(gl);
    
    if(program.setBump) {
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, this.getBumpTexture(gl).getLocation());
      program.setBump(gl, 1);
    }
  }
  
};


Util.Inheritance.inherit(TentaGL.BumpMappedTexture, TentaGL.Material);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs an opaque, black Color. See the auxillary constructor methods 
 * for creating other colors using various color models.
 * For a shader program to be able to use a color as a material, you must
 * bind its uniform variable used to store the color's RGBA values using 
 * its bindColorUni method when the program is initialized.
 * @constructor
 */
TentaGL.Color = function() {
  this._rgba = vec4.create();
  this.setRGBA(0, 0, 0, 1);
};


TentaGL.Color.prototype = {
  
  constructor:TentaGL.Color,
  
  isaColor: true,
  
  /** 
   * Materials are required to provide a clean({WebGLRenderingContext}) method. 
   * For Color, no GL resources are used though, so this does nothing.
   */
  clean:function(gl) {
    // No clean-up needed.
  },
  
  /** 
   * Returns true.
   * @return {Boolean}
   */
  isLoaded:function() {
    return true;
  },
  
  
  
  //////// RGBA color space
  
  /** 
   * Returns a copy of the color's normalized RGBA components. 
   * @return {vec4}
   */
  getRGBA:function() {
    return vec4.clone(this._rgba);
  },
  
  /** 
   * Returns a copy of the color's uint8 RGBA components. 
   * @return {vec4}
   */
  getRGBABytes:function() {
    return vec4.fromValues(this.getRedByte(), this.getGreenByte(), this.getBlueByte(), this.getAlphaByte());
  },
  
  /** 
   * Returns the color's normalized red component.
   * @return {Number}
   */
  getRed:function() {
    return this._rgba[0];
  },
  
  /** 
   * Returns the color's red component as a uint8 value.
   * @return {uint8}
   */
  getRedByte:function() {
    return (this._rgba[0]*255) & 0xFF;
  },
  
  /** 
   * Returns the color's normalized green component.
   * @return {Number}
   */
  getGreen:function() {
    return this._rgba[1];
  },
  
  /** 
   * Returns the color's green component as a uint8 value.
   * @return {uint8}
   */
  getGreenByte:function() {
    return (this._rgba[1]*255) & 0xFF;
  },
  
  
  /** 
   * Returns the color's normalized blue component.
   * @return {Number}
   */
  getBlue:function() {
    return this._rgba[2];
  },
  
  
  /** 
   * Returns the color's blue component as a uint8 value.
   * @return {uint8}
   */
  getBlueByte:function() {
    return (this._rgba[2]*255) & 0xFF;
  },
  
  /** 
   * Returns the color's normalized alpha component.
   * @return {Number}
   */
  getAlpha:function() {
    return this._rgba[3];
  },
  
  
  /** 
   * Returns the color's alpha component as a uint8 value.
   * @return {uint8}
   */
  getAlphaByte:function() {
    return (this._rgba[3]*255) & 0xFF;
  },
  
  /** 
   * Sets the RGBA color components for this color. 
   * @param {Number} r  red
   * @param {Number} g  green
   * @param {Number} b  blue
   * @param {Number} a  alpha (Optional, will keep previous value if not provided)
   * @return {TentaGL.Color} this
   */
  setRGBA:function(r, g, b, a) {
    this._rgba[0] = r;
    this._rgba[1] = g;
    this._rgba[2] = b;
    
    if(a !== undefined) {
      this._rgba[3] = a;
    }
    return this;
  },
  
  /** 
   * Sets the normalized red component of this color. 
   * @param {Number} red
   * @return {TentaGL.Color} this
   */
  setRed:function(red) {
    this._rgba[0] = red;
    return this;
  },
  
  /** 
   * Sets the normalized green component of this color. 
   * @param {Number} green
   * @return {TentaGL.Color} this
   */
  setGreen:function(green) {
    this._rgba[1] = green;
    return this;
  },
  
  /** 
   * Sets the normalized blue component of this color. 
   * @param {Number} blue
   * @return {TentaGL.Color} this
   */
  setBlue:function(blue) {
    this._rgba[2] = blue;
    return this;
  },
  
  /** 
   * Sets the normalized alpha component of this color. 
   * @param {Number} alpha
   * @return {TentaGL.Color} this
   */
  setAlpha:function(alpha) {
    this._rgba[3] = alpha;
    return this;
  },
  
  
  //////// Hex color conversion
  
  /**
   * Sets the RGBA components of this color, given a 32-bit unsigned integer 
   * representing them in ARGB (alpha, red, green, blue) form.
   * @param {int} argb  Bits 31-24 contain the color's alpha component. 
   *      Bits 23-16 contain the color's red component. Bits 15-8 contain
   *      the color's green component. Bits 7-0 contain the color's blue
   *      component. The alpha bits are NOT optional. Alpha will be 0 (transparent).
   * @return {TentaGL.Color} this
   */
  setHex:function(argb) {
    var a = ((argb >>> 24) & 0x000000FF)/255;
    var r = ((argb >>> 16) & 0x000000FF)/255;
    var g = ((argb >>> 8) & 0x000000FF)/255;
    var b = (argb & 0x000000FF)/255;
    
    return this.setRGBA(r, g, b, a);
  },
  
  
  /** Returns the ARGB hex representation of this color. */
  getHex:function() {
    return TentaGL.Color.nrgba2Hex(this.getRed(), this.getGreen(), this.getBlue(), this.getAlpha());
  },
  
  
  //////// HSBA color space
  
  /** 
   * Constructs a color from normalized HSBA (hue, saturation, brightness, alpha)
   * color components.
   * @param {Number} h  hue
   * @param {Number} s  saturation
   * @param {Number} b  brightness
   * @param {Number} a  alpha (Optional, will keep previous value if not provided)
   * @return {TentaGL.Color} this
   */
  setHSBA:function(h, s, b, a) {  
    if(a === undefined) {
      a = this.getAlpha();
    }
    var rgba = TentaGL.Color.HSBAtoRGBA(h, s, b, a);
    this.setRGBA(rgab[0], rgba[1], rgba[2], rgba[3]);
  },
  
  
  /**
   * Returns a representation of this color in the HSBA 
   * (Hue, Saturation, Brightness, Alpha) color model.
   * @return {Array} The normalized HSBA components.
   */
  getHSBA:function() {
    var r = this.getRed();
    var g = this.getGreen();
    var b = this.getBlue();
    var a = this.getAlpha();
    
    return TentaGL.Color.RGBAtoHSBA(r, g, b, a);
  },
  
  /** 
   * Returns the hue of this color in the HSBA color model. 
   * @return {Number}
   */
  getHue:function() {
    return this.getHSBA()[0];
  },
  
  
  /** Sets the hue of this color. */
  setHue:function(hue) {
    var hsba = this.getHSBA();
    this.setHSBA(hue, hsba[1], hsba[2], hsba[3]);
  },
  
  
  /** 
   * Returns the saturation of this color in the HSBA color model. 
   * @return {Number}
   */
  getSaturation:function() {
    return this.getHSBA()[1];
  },
  
  /** Sets the saturation of this color. */
  setSaturation:function(sat) {
    var hsba = this.getHSBA();
    this.setHSBA(hsba[0], sat, hsba[2], hsba[3]);
  },
  
  
  /** 
   * Returns the brightness of this color in the HSBA color model. 
   * @return {Number}
   */
  getBrightness:function() {
    return this.getHSBA()[2];
  },
  
  
  /** Sets the brightness of this color. */
  setBrightness:function(bright) {
    var hsba = this.getHSBA();
    this.setHSBA(hsba[0], hsba[1], bright, hsba[3]);
  },
  
  
  
  //////// GL state
  
  /** 
   * Sets up the currently bound ShaderProgram so that its bound vec4 color
   * uniform variable is set to this color's RGBA values.
   * @param {WebGLRenderingContext} gl
   */
  useMe:function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    if(program.setColor) {
      program.setColor(gl, this._rgba);
    }
  },
  
  
  
  //////// Misc.
  
  /** 
   * A color is equal to another color if their RGBA values are the same. 
   * @param {TentaGL.Color} other
   * @return {Boolean}
   */
  equals:function(other) {
    return (  this.getRed() == other.getRed() && 
              this.getGreen() == other.getGreen() &&
              this.getBlue() == other.getBlue() &&
              this.getAlpha() == other.getAlpha());
  },
  
  
  /** 
   * Returns a CSS string representation of this color. 
   * @return {string}
   */
  toCSS:function() {
    return "rgb(" + this.getRedByte() + "," + this.getGreenByte() + "," + this.getBlueByte() + ")";
  }

};


Util.Inheritance.inherit(TentaGL.Color, TentaGL.Material);


//////// Convenience constructors


/** 
 * Returns a new color from normalized RGBA (red, green, blue, alpha) 
 * color components.
 * @param {Number} r  red
 * @param {Number} g  green
 * @param {Number} b  blue
 * @param {Number} a  alpha (Optional, will be set to 1 if not provided)
 */
TentaGL.Color.RGBA = function(r, g, b, a) {
  return (new TentaGL.Color()).setRGBA(r, g, b, a);
};


/** 
 * Returns a new color from RGBA (red, green, blue, alpha) 
 * color component uint8 values.
 * @param {Number} r  red
 * @param {Number} g  green
 * @param {Number} b  blue
 * @param {Number} a  alpha (Optional, will be set to 255 if not provided)
 */
TentaGL.Color.RGBABytes = function(r, g, b, a) {
  if(a === undefined) {
    a = 255;
  }
  return (new TentaGL.Color()).setRGBA(r/255, g/255, b/255, a/255);
};


/**
 * Retuns a new Color, given a 32-bit unsigned integer representing its ARGB
 * (alpha, red, green, blue) color components.
 * @param {int} argb  Bits 31-24 contain the color's alpha component. 
 *      Bits 23-16 contain the color's red component. Bits 15-8 contain
 *      the color's green component. Bits 7-0 contain the color's blue
 *      component. The alpha component is NOT optional.
 */
TentaGL.Color.Hex = function(argb) {
  return (new TentaGL.Color()).setHex(argb);
};


/** 
 * Returns a new Color, given its normalized HSBA 
 * (hue, saturation, brightness, alpha) color components.
 * @param {Number} h  hue
 * @param {Number} s  saturation
 * @param {Number} b  brightness
 * @param {Number} a  alpha (Optional, will be set to 1 if not provided)
 */
TentaGL.Color.HSBA = function(h, s, b, a) {
  return (new TentaGL.Color()).setHSBA(h, s, b, a);
};


/** 
 * Returns a copy of an existing Color.
 * @param {TentaGL.Color} color
 */
TentaGL.Color.clone = function(color) {
  return (new TentaGL.Color()).setRGBA(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha());
};


//////// Color format conversions

/** 
 * Returns the ARGB hex representation of the color defined by the given 
 * normalized rgba color components. 
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a
 * @return {uint32}
 */
TentaGL.Color.nrgba2Hex = function(r, g, b, a) {
    var hex = Math.floor(a*255)<<24;
    hex += Math.floor(r*255)<<16;
    hex += Math.floor(g*255)<<8;
    hex += Math.floor(b*255);
    return hex>>>0;
};

/** 
 * Returns the ARGB hex representation of the color defined by the given 
 * uint8 rgba color components. 
 * @param {uint8} r
 * @param {uint8} g
 * @param {uint8} b
 * @param {uint8} a
 * @return {uint32}
 */
TentaGL.Color.rgba2Hex = function(r, g, b, a) {
    var hex = (a)<<24;
    hex += (r)<<16;
    hex += (g)<<8;
    hex += b;
    return hex>>>0;
};



/**
   * Returns a representation of this color in the HSBA 
   * (Hue, Saturation, Brightness, Alpha) color model.
   * @param {Number} r
   * @param {Number} g
   * @param {Number} b
   * @param {Number} a
   * @return {Array} The normalized HSBA components.
   */
TentaGL.Color.RGBAtoHSBA = function(r, g, b, a) {
  if(a === undefined) {
    a = 1;
  }
  
  var max = Math.max(r,g,b);
  var min = Math.min(r,g,b);
  var chroma = max-min;
  
  // compute the hue
  var hue = 0;
  if(chroma == 0) {
    hue = 0;
  }
  else if(max == r) {
    hue = ((g - b)/chroma) % 6;
  }
  else if(max = g) {
    hue = ((b-r)/chroma) + 2;
  }
  else {
    hue = ((r-g)/chroma) + 4;
  }
  hue /= 6.0;
  
  // compute the brightness/value
  var brightness = max;
  
  // compute the saturation
  var saturation = 0;
  if(chroma != 0) {
    saturation = chroma/brightness;
  }
      
  return [hue, saturation, brightness, a];
};



/** 
 * Constructs a color from normalized HSBA (hue, saturation, brightness, alpha)
 * color components.
 * @param {Number} h  hue
 * @param {Number} s  saturation
 * @param {Number} b  brightness
 * @param {Number} a  alpha
 * @return {Array{Number}} this
 */
TentaGL.Color.HSBAtoRGBA = function(h, s, b, a) { 
  if(a === undefined) {
    a = 1;
  }
  
  var hp = (h-Math.floor(h))*6.0;
  var chroma = s*b;
  var x = chroma*(1-Math.abs(hp % 2 - 1));
  var m = b-chroma;
  
  if(hp >= 0 && hp < 1) {
    return [chroma + m, x + m, m, a];
  }
  else if(hp >= 1 && hp < 2) {
    return [x + m, chroma + m, m, a];
  }
  else if(hp >= 2 && hp < 3) {
    return [m, chroma + m, x + m, a];
  }
  else if(hp >= 3 && hp < 4) {
    return [m, x + m, chroma + m, a];
  }
  else if(hp >= 4 && hp < 5) {
    return [x + m, m, chroma + m, a];
  }
  else if(hp >= 5 && hp < 6) {
    return [chroma + m, m, x + m, a];
  }
  else {
    return [m, m, m, a];
  }
};


/** 
 * Converts an ARGB hex value for a color to a vec4 containing the equivalent 
 * normalized RGBA components.
 * @param {uint32} hex    Bits 31-24 contain the color's alpha component. 
 *      Bits 23-16 contain the color's red component. Bits 15-8 contain
 *      the color's green component. Bits 7-0 contain the color's blue
 *      component. The alpha bits are NOT optional. Alpha will be 0 (transparent).
 * @return {vec4}
 */
TentaGL.Color.hexToRGBA = function(hex) {
  var a = ((hex >>> 24) & 0x000000FF)/255;
  var r = ((hex >>> 16) & 0x000000FF)/255;
  var g = ((hex >>> 8) & 0x000000FF)/255;
  var b = (hex & 0x000000FF)/255;
  
  return vec4.fromValues(r, g, b, a);
};



//////// Some commonly used colors

TentaGL.Color.BLACK = TentaGL.Color.Hex(0xFF000000);
TentaGL.Color.BLUE = TentaGL.Color.Hex(0xFF0000FF);
TentaGL.Color.CYAN = TentaGL.Color.Hex(0xFF00FFFF);
TentaGL.Color.GREEN = TentaGL.Color.Hex(0xFF00FF00);
TentaGL.Color.GREY = TentaGL.Color.Hex(0xFF888888);
TentaGL.Color.MAGENTA = TentaGL.Color.Hex(0xFFFF00FF);
TentaGL.Color.RED = TentaGL.Color.Hex(0xFFFF0000);
TentaGL.Color.WHITE = TentaGL.Color.Hex(0xFFFFFFFF);
TentaGL.Color.YELLOW = TentaGL.Color.Hex(0xFFFFFF00);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A material for gradients, both linear and radial. The graident initially has 
 * no break points. Add break points using the addBreakPt method.
 * @constructor
 * @param {vec2} startPt    The starting point for the gradient.
 * @param {vec2} vector     The vector giving the direction and length 
 *      (or radius) of the gradient.
 */
TentaGL.Gradient = function(startPt, vector) {
  this._pt = vec2.clone(startPt);
  this._vec = vec2.clone(vector);
  
  this._breakPts = [];
};

TentaGL.Gradient.prototype = {
  
  constructor: TentaGL.Gradient,
  
  isaGradient: true,
  
  
  /** 
   * Returns the gradient's start point. 
   * @return {vec2}
   */
  getStartPoint: function() {
    return this._pt;
  },
  
  
  /** 
   * Returns the gradient's vector.
   * @return {vec2}
   */
  getVector: function() {
    return this._vec;
  },
  
  
  /** 
   * For radial gradients, this returns the radius of the gradient.
   * @return {number}
   */
  getRadius: function() {
    return vec2.length(this._vec);
  },
  
  
  /** 
   * Adds a break point to the gradient. Break points can be added out of order.
   * They will be correctly inserted at the correct position in the list of 
   * breakpoints to maintain ascending order of break point values.
   * @param {float} breakPt   Should be in the range [0, 1].
   * @param {TentaGL.Color} color
   * @return {TentaGL.Gradient} this, for chaining.
   */
  addBreakPt: function(breakPt, color) {
    if(this._breakPts.length == 0) {
      this._breakPts[0] = [breakPt, color];
    }
    else {
      var insertIndex = 0;
      for(var i=0; i<this._breakPts.length; i++) {
        var curPt = this._breakPts[i];
        
        if(breakPt > curPt[0]) {
          insertIndex = i+1;
        }
      }
      
      this._breakPts.splice(insertIndex, 0, [breakPt, color]);
    }
    
    return this;
  },
  
  
  /** 
   * Returns the parametric value of the nth break point. 
   * @return {float}
   */
  getBreakPt: function(n) {
    return this._breakPts[n][0];
  },
  
  
  /** 
   * Returns a list of the parametric values for the break points. 
   * @return {array: float}
   */
  getBreakPts: function() {
    var result = [];
    for(var i=0; i < this._breakPts.length; i++) {
      result.push(this._breakPts[i][0]);
    }
    return result;
  },
  
  
  /** 
   * Returns the color of the nth break point.
   * @return {TentaGL.Color}
   */
  getColor: function(n) {
    return this._breakPts[n][1];
  },
  
  
  /** 
   * Returns a list of the colors for the break points.
   * @return {array: TentaGL.Color}
   */
  getColors: function() {
    var result = [];
    for(var i=0; i < this._breakPts.length; i++) {
      result.push(this._breakPts[i][1]);
    }
    return result;
  },
  
  
  
  /** 
   * Uses the gradient in the current shader.
   * @param {WebGLRenderingContext} gl
   */
  useMe: function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    
    if(program.setStartPoint) {
      program.setStartPoint(gl, this._pt);
      program.setGradVector(gl, this._vec);
      program.setColors(gl, this.getColors());
      program.setBreakPoints(gl, this.getBreakPts());
    }
  }
  
};

Util.Inheritance.inherit(TentaGL.Gradient, TentaGL.Material);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Constructs an initially empty texture. The texture's image data can be set
 * by constructing a PixelData object and loading it with the setPixelData 
 * method.
 * @constructor
 * @param {WebGLRenderingContext} gl
 */
TentaGL.Texture = function(gl) {
    this._tex = TentaGL.Texture.create(gl);
    this._width = 1;
    this._height = 1;
};


TentaGL.Texture.prototype = {
  
  constructor:TentaGL.Texture,
  
  isaTexture: true,
  
  /** 
   * Sets the contents of the texture to the data in a PixelData object.
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.PixelData} pixelData
   */
  setPixelData:function(gl, pixelData) {
    var data = pixelData.getData();
    var width = pixelData.getWidth();
    var height = pixelData.getHeight();
    
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    this._width = width;
    this._height = height;
    
    TentaGL.MaterialLib.useNone(gl);
  },
  
  
  
  /** 
   * Deletes this texture from GL memory.
   * @param {WebGLRenderingContext} gl
   */
  clean:function(gl) {
    gl.deleteTexture(this._tex);
  },
  
  /** 
   * Returns the location of this texture in GL memory.
   * @return {WebGLTexture}
   */
  getLocation:function() {
    return this._tex;
  },
  
  
  //////// Dimensions
  
  /** 
   * Returns the width of the texture if it is available.
   * @return {int}
   */
  getWidth:function() {
    return this._width;
  },
  
  
  /** 
   * Returns the height of the texture if it is available. 
   * @return {int}
   */
  getHeight:function() {
    return this._height;
  },
  
  
  
  //////// Min-mag
  
  /** 
   * Returns the constant for the current magnification filter being used.
   * Default gl.NEAREST
   * @param {WebGLRenderingContext} gl
   * @return {GLenum} Either gl.NEAREST or gl.LINEAR
   */
  getMagFilter:function(gl) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    return gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER);
  },
  
  /**
   * Sets the magnification filter to be used with this texture.
   * @param {WebGLRenderingContext} gl
   * @param {GLint} filter    Either gl.NEAREST or gl.LINEAR
   */
  setMagFilter:function(gl, filter) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
  },
  
  /** 
   * Returns the constant for the current minification filter being used.
   * Default gl.NEAREST
   * @param {WebGLRenderingContext} gl
   * @return {GLenum} Either gl.NEAREST, gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR,
   *       gl.NEAREST_MIPMAP_NEAREST, gl.NEARTEST_MIPMAP_LINEAR, or gl.LINEAR_MIPMAP_NEAREST.
   */
  getMinFilter:function(gl) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    return gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER);
  },
  
  /**
   * Sets the minification filter to be used with this texture.
   * @param {WebGLRenderingContext} gl
   * @param {GLint} filter    Either gl.NEAREST, gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR,
   *       gl.NEAREST_MIPMAP_NEAREST, gl.NEARTEST_MIPMAP_LINEAR, or gl.LINEAR_MIPMAP_NEAREST.
   */
  setMinFilter:function(gl, filter) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
  },
  
  
  
  //////// Wrapping
  
  /**
   * Gets the the wrapping method used for this texture on the S texture
   * coordinates axis.
   * Default gl.CLAMP_TO_EDGE
   * @param {WebGLRenderingContext} gl
   * @return {GLenum} Either gl.CLAMP_TO_EDGE, gl.REPEAR, or gl.MIRRORED_REPEAT.
   */
  getWrapS:function(gl) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    return gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S);
  },
  
  /**
   * Sets the wrapping method used for this texture on the 
   * S texture coordinates axis.
   * @param {WebGLRenderingContext} gl
   * @param {GLint} method
   */
  setWrapS:function(gl, method) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, method);
  },
  
  
  /**
   * Gets the the wrapping method used for this texture on the S texture
   * coordinates axis.
   * Default gl.CLAMP_TO_EDGE
   * @param {WebGLRenderingContext} gl
   * @return {GLenum} Either gl.CLAMP_TO_EDGE, gl.REPEAR, or gl.MIRRORED_REPEAT.
   */
  getWrapT:function(gl) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    return gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T);
  },
  
  /**
   * Sets the wrapping method used for this texture on the 
   * T texture coordinates axis.
   * @param {WebGLRenderingContext} gl
   * @param {GLint} method
   */
  setWrapT:function(gl, method) {
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, method);
  },
  
  
  //////// Pixel data
  
  /** 
   * Produces a PixelData object containing the raw pixel data of some 
   * rectangular area of this texture. Here, X and Y are the coordinates of the 
   * lower-left corner of the texture area.
   * @param {WebGLRenderingContext} gl
   * @param {int} x   Optional. Default 0.
   * @param {int} y   Optional. Default 0.
   * @param {int} w   Optional. Defaults to the width of the texture - x.
   * @param {int} h   Optional. Defaults to the height of the texture - y.
   * @param {Uint8Array} bytes      Optional. A pre-allocated byte array to store 
   *      the pixel data in. The size of this array should be at least 4*w*h. 
   * @return {TentaGL.PixelData}
   */
  getPixelData:function(gl, x, y, w, h, bytes) {
    x = x || 0;
    y = y || 0;
    w = w || this._width - x;
    h = h || this._height - y;
    
    return TentaGL.PixelData.fromGLTexture(gl, this._tex, x, y, w, h, bytes);
  },
  
  
  
  //////// GL state
  
  /** 
   * Sets up the currently bound ShaderProgram so that its bound sampler2D 
   * texture0 uniform variable will use this texture.
   * @param {WebGLRenderingContext} gl
   */
  useMe:function(gl) {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._tex);
    TentaGL.ShaderLib.current(gl).setTex(gl, 0);
  }
};

Util.Inheritance.inherit(TentaGL.Texture, TentaGL.Material);


/** 
 * Creates an initially empty texture in GL memory. By default, this texture 
 * Displays as solid red and has its min-mag filters set to gl.NEAREST.
 * @param {WebGLRenderingContext} gl
 * @param {Uint8Array} data   Optional. RGBA array of pixel data. This is
 *      allowed to be null, in which case the resulting appearance will be
 *      undefined (Displays white for me). Defaults to null.
 * @param {int} width   Optional. Width of the texture. Defaults to 1.
 * @param {int} height  Optional. Height of the texture. Defaults to 1.
 * @return {WebGLTexture}
 */
TentaGL.Texture.create = function(gl, data, width, height) {
  data = data || null;
  width = width || 1;
  height = height || 1;
  
  var tex = gl.createTexture();
  gl.bindTexture(GL_TEXTURE_2D, tex);
  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
  
  // Use gl.NEAREST by default for min-mag filters.
  gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  return tex;
};



/** 
 * Returns a new Texture constructed from an image at a specified URL. 
 * @param {WebGLRenderingContext} gl
 * @param {string} url  The filepath to the image.
 * @param {function(data: PixelData) : PixelData} pixelsCB    Optional. A 
 *      callback function for doing any processing on the image's pixel
 *      data BEFORE it is loaded into the texture. The resulting PixelData
 *      should be returned in the callback.
 * @param {function(tex: TentaGL.Texture) : undefined} texStateCB   Optional. 
 *      A callback function for setting up any gl properties for the texture 
 *      AFTER its pixel data has been loaded.
 * @return {TentaGL.Texture}
 */
TentaGL.Texture.fromURL = function(gl, url, pixelsCB, texStateCB) {  
  var result = new TentaGL.Texture(gl);
  TentaGL.PixelData.fromURL(url, function(pixelData) {
    if(pixelsCB) {
      pixelData = pixelsCB(pixelData);
    }
    result.setPixelData(gl, pixelData);
    if(texStateCB) {
      texStateCB(result);
    }
  });
  return result;
};


/** 
 * Returns a new Texture constructed from a Canvas element. 
 * @param {WebGLRenderingContext} gl
 * @param {Canvas} canvas
 * @param {function(data: PixelData) : PixelData} processCB    Optional. A 
 *      callback function for doing any processing on the canvas's pixel
 *      data BEFORE it is loaded into the texture. The resulting PixelData
 *      should be returned in the callback.
 * @param {function(tex: TentaGL.Texture) : undefined} texStateCB   Optional. 
 *      A callback function for setting up any gl properties for the texture 
 *      AFTER its pixel data has been loaded.
 * @return {TentaGL.Texture}
 */
TentaGL.Texture.fromCanvas = function(gl, canvas, pixelsCB, texStateCB) {
  var pixelData = TentaGL.PixelData.fromCanvas(canvas);
  return TentaGL.Texture.fromPixelData(gl, pixelData, pixelsCB, texStateCB);
};



/** 
 * Returns a new Texture constructed from a PixelData object.
 * @param {WebGLRenderingContext} gl
 * @param {TentaGL.PixelData} pixelData
 * @param {function(data: PixelData) : PixelData} pixelsCB    Optional. 
 *      A callback function for doing any processing on the pixel
 *      data BEFORE it is loaded into the texture. The resulting PixelData
 *      should be returned in the callback.
 * @param {function(tex: TentaGL.Texture) : undefined} texStateCB   Optional. 
 *      A callback function for setting up any gl properties for the texture 
 *      AFTER its pixel data has been loaded.
 * @return {TentaGL.Texture}
 */
TentaGL.Texture.fromPixelData = function(gl, pixelData, pixelsCB, texStateCB) {
  if(pixelsCB) {
    pixelData = pixelsCB(pixelData);
  }
  
  var result = new TentaGL.Texture(gl);
  result.setPixelData(gl, pixelData);
  
  if(texStateCB) {
    texStateCB(result);
  }
  return result;
};


/** 
 * Creates an 8x8 texture of a solid color.
 * @param {WebGLRenderingContext} gl
 * @param {TentaGL.Color} color
 * @param {function(data: PixelData) : PixelData} pixelsCB    Optional. 
 *      A callback function for doing any processing on the pixel
 *      data BEFORE it is loaded into the texture. The resulting PixelData
 *      should be returned in the callback.
 * @param {function(tex: TentaGL.Texture) : undefined} texStateCB   Optional. 
 *      A callback function for setting up any gl properties for the texture 
 *      AFTER its pixel data has been loaded.
 * @return {TentaGL.Texture}
 */
TentaGL.Texture.fromColor = function(gl, color, pixelsCB, texStateCB) {
  var canvas = TentaGL.Canvas2D.createRect(8, 8, false, 0, color);
  return TentaGL.Texture.fromCanvas(gl, canvas, pixelsCB, texStateCB);
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/**
 * A library of loaded Materials.
 * All materials stored in the library must implement the Material interface.
 */
TentaGL.MaterialLib = {
  
  /** Dictionary of Materials, each keyed by a unique string name. */
  _materials:{},
  
  
  /** 
   * Removes all Materials from the library and the GL context.
   * @param {WebGLRenderingContext} gl
   */
  clean:function(gl) {
    for(var i in gl._materialLib) {
      gl._materialLib[i].clean(gl);
    }
    gl._materialLib = {};
  },
  
  
  reset:function(gl) {
    this.clean(gl);
  },
  
  
  
  /** 
   * Retrieves a Material by name. An Error is thrown if the material doesn't 
   * exist in the library. 
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   * @return {TentaGL.Material}
   */
  get:function(gl, name) {
    var material = gl._materialLib[name];
    if(material === undefined) {
      throw new Error("Material " + name + " doesn't exist.");
    }
    
    return material;
  },
  
  
  /** 
   * Returns true iff this library contains a Material with the specified name. 
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   * @return {Boolean}
   */
  has:function(gl, name) {
    return (gl._materialLib[name] !== undefined);
  },
  
  
  /** 
   * Adds a new Material to the library, keyed with the specified name.
   * @param {string} name
   * @param {TentaGL.Material} material
   * @return {TentaGL.Material} The material added to the library.
   */
  add:function(gl, name, material) {
    if(gl._materialLib[name] !== undefined) {
      throw new Error("Material " + name + " already exists.");
    }
    if(!material.isaMaterial) {
      throw new Error("Object for " + name + " isn't a material!");
    }
    
    gl._materialLib[name] = material;
  //  console.log("Added material " + name);
    
    return material;
  },
  
  /** 
   * Removes the specified Material from the library and cleans up any GL 
   * resources associated with it.
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   */
  remove:function(gl, name) {
    var material = gl._materialLib[name];
    if(material === undefined) {
      throw new Error("Material " + name + " doesn't exist.");
    }
    
    material.clean(gl);
    delete gl._materialLib[name];
  },
  
  
  /** 
   * Sets the current shader program to use the specified material.
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   */
  use:function(gl, name) {
    if(gl._materialLibCurrentName === name) {
      return;
    }
    
    var material = gl._materialLib[name];
    if(material === undefined) {
      throw new Error("Material " + name + " doesn't exist.");
    }
    
    material.useMe(gl);
    gl._materialLibCurrentName = name;
  },
  
  
  /** Sets the library to not currently be using a material. */
  useNone:function(gl) {
    gl._materialLibCurrentName = undefined;
  }
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * An encapsulation of material lighting properties. 
 * This doesn't really define the color for the material so much as it defines
 * how the material will react with the different components of lights in the 
 * scene.
 * @constructor
 * @param {TentaGL.Color} diffuse   Optional. Default: RGBA(1,1,1,1).
 * @param {TentaGL.Color} specular  Optional. Default: RGBA(1,1,1,1).
 * @param {number} shininess        Optional. Default: 0.
 * @param {TentaGL.Color} ambient   Optional. Default: RGBA(1,1,1,1).
 * @param {TentaGL.Color} emission  Optional. This one doesn't actually react
 *      to other light source in the scene. This actually functions as an 
 *      additive color to the computed color after lighting. So, it produces a 
 *      glowing effect for the object.
 *      Default: RGBA(0,0,0,1).
 */
TentaGL.MaterialProps = function(diffuse, specular, shininess, ambient, emission) {
  if(!diffuse) {
    diffuse = TentaGL.Color.RGBA(1, 1, 1, 1); // all diffuse
  }
  if(!specular) {
    specular = TentaGL.Color.RGBA(1, 1, 1, 1); // all specular
  }
  if(!shininess) {
    shininess = 10;
  }
  if(!ambient) {
    ambient = TentaGL.Color.RGBA(1, 1, 1, 1); // all ambient
  }
  if(!emission) {
    emission = TentaGL.Color.RGBA(0, 0, 0, 1); // no emission
  }
  
  this._diffuse = diffuse;
  this._specular = specular;
  this._shininess = shininess;
  this._ambient = ambient;
  this._emission = emission;
};

TentaGL.MaterialProps.prototype = {
  
  constructor: TentaGL.MaterialProps,
  
  isaMaterialProps: true,
  
  
  /** 
   * Returns the diffuse material property. 
   * @return {TentaGL.Color}
   */
  getDiffuse: function() {
    return this._diffuse;
  },
  
  /** 
   * Sets the diffuse property. 
   * @param {TentaGL.Color} color
   */
  setDiffuse: function(color) {
    this._diffuse = color;
  },
  
  
  /** 
   * Returns the specular material property.
   * @return {TentaGL.Color}
   */
  getSpecular: function() {
    return this._specular;
  },
  
  
  /** 
   * Sets the diffuse property. 
   * @param {TentaGL.Color} color
   */
  setSpecular: function(color) {
    this._specular = color;
  },
  
  
  /** 
   * Returns the shininess material property.
   * @return {number}
   */
  getShininess: function() {
    return this._shininess;
  },
  
  /** 
   * Sets the shininess property.
   * @param {number} shininess
   */
  setShininess: function(shininess) {
    this._shininess = shininess;
  },
  
  
  /** 
   * Returns the ambient material property.
   * @return {TentaGL.Color}
   */
  getAmbient: function() {
    return this._ambient;
  },
  
  /** 
   * Sets the ambient property. 
   * @param {TentaGL.Color} color
   */
  setAmbient: function(color) {
    this._ambient = color;
  },
  
  
  /** 
   * Returns the emission material property.
   * @return {TentaGL.Color}
   */
  getEmission: function() {
    return this._emission;
  },
  
  
  /** 
   * Sets the emission property. 
   * @param {TentaGL.Color} color
   */
  setEmission: function(color) {
    this._emission = color;
  },
  
  
  /** 
   * Uses the material properties in the shader. 
   * @param {WebGLRenderingContext} gl
   */
  useMe: function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    
    if(program.setMaterialProps) {
      program.setMaterialProps(gl, this);
    }
  }
  
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/**
 * Rendering modes are functions that set up the state of the gl context
 * for some specific mode of rendering. Each rendering mode function
 * accepts a WebGLRenderingContext as an argument.
 */ 
TentaGL.RenderMode = {};


/** A 3D rendering mode for opaque objects. */
TentaGL.RenderMode.set3DOpaque = function(gl) {
  TentaGL.Blend.setEnabled(gl, false);
  TentaGL.DepthBuffer.setEnabled(gl, true);
  TentaGL.Cull.setMode(gl, GL_NONE);
};


/** A 3D rendering mode for translucent objects. */
TentaGL.RenderMode.set3DTrans = function(gl) {
  TentaGL.Blend.setEnabled(gl, true);
  TentaGL.Blend.setEquation(gl, GL_FUNC_ADD, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  
  TentaGL.DepthBuffer.setEnabled(gl, false);
  TentaGL.Cull.setMode(gl, GL_NONE);
};



/** a 2D rendering mode for opaque and translucent objects. */
TentaGL.RenderMode.set2D = function(gl) {
  TentaGL.Blend.setEnabled(gl, true);
  TentaGL.Blend.setEquation(gl, GL_FUNC_ADD, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  
  TentaGL.DepthBuffer.setEnabled(gl, false);
  TentaGL.Cull.setMode(gl, GL_NONE);
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A VBOData object encapsulates cached vertex attribute and element index 
 * data for a model for VBO rendering. 
 * @constructor
 * @param {WebGLContextRenderer} gl
 * @param {TentaGL.Model} model  The model we're creating the data for.
 * @param {associative arry: {int} -> {TentaGL.AttrProfile}} attrProfileSet
 */
TentaGL.VBOData = function(gl, model, attrProfileSet) {
  
//  console.log("Creating VBO data");
  
  var attrData = [];
  this._byteOffsets = {};
  var vertices = model.getVertices();
  
//  console.log(vertices.length);
  
  for(var i=0; i < vertices.length; i++) {
    var vertex = vertices[i];
    
  //  console.log(vertex);
    var offset = 0;
    for(var j in attrProfileSet) {
      var attr = attrProfileSet[j];
      var values = attr.getValues(vertex);
      
    //  console.log("  " + attr.id() + " : " + Util.Debug.arrayString(values));
      
      this._byteOffsets[j] = offset;
      offset += attr.sizeBytes();
      
      for(var k=0; k<values.length; k++) {
        attrData.push(values[k]);
      }
    }
    
  }
  
  this._attrBuffer = gl.createBuffer();
  gl.bindBuffer(GL_ARRAY_BUFFER, this._attrBuffer);
  gl.bufferData(GL_ARRAY_BUFFER, new Float32Array(attrData), GL_STATIC_DRAW);
//  console.log("Attr data array: " + attrData);
  
  var elemData = model.getIndices();
  
  this._numIndices = model.numIndices();
  this._elemBuffer = gl.createBuffer();
  gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, this._elemBuffer);
  gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, new Uint16Array(elemData), GL_STATIC_DRAW);
  
//  console.log("Elem data array: " + elemData);
  
  this._attrSet = attrProfileSet;
  this._stride = TentaGL.AttrProfiles.getStride(attrProfileSet);
  
  this._mode = model.getDrawMode();
  this._cull = model.getCullMode();
};




TentaGL.VBOData.prototype = {
  constructor: TentaGL.VBOData,
  
  /** 
   * Returns the buffer of vertex attribute data. 
   * @return {WebGLBuffer}
   */
  getAttrBuffer:function() {
    return this._attrBuffer;
  },
  
  /** 
   * Returns the buffer of element indices. 
   * @return {WebGLBuffer}
   */
  getElemBuffer:function() {
    return this._elemBuffer;
  },
  
  
  /** Returns the number of indices in the element index buffer. */
  numIndices:function() {
    return this._numIndices;
  },
  
  
  /** 
   * Gets the byte offset for an AttrProfile in this data.
   * An Error is thrown if data is not available in the VBO for the AttrProfile.
   * @param {TentaGL.AttrProfile} attrProfile
   */
  getOffset:function(attrProfile) {
    var id = attrProfile.id();
    if(this._byteOffsets[id] === undefined) {
      throw new Error("VBOData does not contain data for AttrProfile: " + attrProfile.toString());
    }
    else {
      return this._byteOffsets[id];
    }
  },
  
  
  /** Returns the byte stride for this VBO data. */
  getStride:function() {
    return this._stride;
  },
  
  
  /**
   * Returns the ShaderProgram used to fill the vertex data.
   * @return {TentaGL.ShaderProgram}
   */
  getShader:function() {
    return this._shader;
  },
  
  
  /** 
   * Returns the primitive drawing mode preferred for rendering this model. 
   * @return {GLenum}   Either GL_LINES or GL_TRIANGLES.
   */
  getDrawMode:function() {
    return this._mode;
  },
  
  /** Returns the face culling mode for rendering this model. */
  getCullMode:function() {
    return this._cull;
  },
  
  
  /** 
   * Deletes the VBOData's buffers from GL memory.
   * @param {WebGLRenderingContext} gl
   */
  clean:function(gl) {
    gl.deleteBuffer(this._attrBuffer);
    gl.deleteBuffer(this._elemBuffer);
  }
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


TentaGL.VBORenderer = {
  
  _mode:GL_TRIANGLES,
  
  /** 
   * Returns the preferred drawing mode for primitives. 
   * @return {GLenum}   Either GL_LINES or GL_TRIANGLES.
   */
  getDrawMode:function() {
    return this._mode;
  },
  
  /** 
   * Sets the preferred drawing mode for primitives. 
   * @param {GLenum} mode   Either GL_LINES or GL_TRIANGLES.
   */
  setDrawMode:function(mode) {
    this._mode = mode;
  },
  
  
  /** 
   * Renders a Model with the ShaderProgram and Material currently in use. 
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.VBOData} vboData   The VBOData of the model to be rendered.
   */
  render:function(gl, vboData) {
    var program = TentaGL.ShaderLib.current(gl);
    
    // Get the data buffers for the model and program, creating them if necessary.
    var attrBuffer = vboData.getAttrBuffer();
    var elemBuffer = vboData.getElemBuffer();
    var stride = vboData.getStride();
    
    // Bind the vertex data.
    gl.bindBuffer(GL_ARRAY_BUFFER, attrBuffer);
    var attrs = program.getAttributes();
    for(var i=0; i < attrs.length; i++) {
      var attr = attrs[i];
      var offset = vboData.getOffset(attr.getProfile());
//      console.log("binding attr: " + attr.getName() + ", loc: " + attr.getLocation() + ", unitSize: " + attr.getSizeUnits() + ", unitType: " + TentaGL.glTypeName(attr.getUnitType()) + ", stride: " + stride + ", offset: " + offset);
      
      
      gl.vertexAttribPointer( attr.getLocation(), 
                              attr.getSizeUnits(), attr.getUnitType(), 
                              false, 
                              stride, offset);
    }
    
    var mode = this._mode;
    if(vboData.getDrawMode() == GL_LINES) {
      mode = GL_LINES;
    }
    TentaGL.Cull.setMode(gl, vboData.getCullMode());
    
    // Bind the index data and draw.
    gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, elemBuffer);
  //  console.log(model.numIndices());
    gl.drawElements(mode, vboData.numIndices(), GL_UNSIGNED_SHORT, 0);
  }
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** An interface for renderable objects. */
TentaGL.Renderable = {};

TentaGL.Renderable.prototype = {
  
  isaRenderable:true,
  
  /** 
   * Renders this object to the scene being rendered by the GL context.  
   * @param {WebGLRenderingContext} gl
   */
  render:function(gl) {}
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Interface for a node in a scene graph. All nodes in a scene graph have a set
 * of affine transforms which are implemented here. SceneNodes can also be made
 * visible or invisible.
 * @constructor
 * @param {vec3} xyz    The node's position in local 3D space.
 */
TentaGL.SceneNode = function(xyz) {
  if(xyz === undefined) {
    xyz = [0, 0, 0];
  }
  if(!xyz[2]) {
    xyz[2] = 0;
  }
  
  this._xyz = vec4.fromValues(xyz[0], xyz[1], xyz[2], 1);
  
  this._scaleXYZ = [1, 1, 1];
  this._scaleUni = 1;
  
  this._quat = quat.create();
  
  this._objLook = vec3.fromValues(0,0,1);
  this._objUp = vec3.fromValues(0,1,0);
  
  this._transform = mat4.create();
  this._tranDirty = true;
  this._isVisible = true;
  
  this._parent = undefined;
};


TentaGL.SceneNode.prototype = {
  
  constructor:TentaGL.SceneNode,
  
  isaSceneNode: true,
  
  /** 
   * Frees any GL memory and resources used only by this SceneNode. 
   * This should be called before disposing of the node. The default 
   * implementation does nothing.
   * Override me.
   */
  clean:function(gl) {},
  
  
  //////// Scene Graph hierarchy
  
  /**
   * Returns the parent of this node in the scene graph. If this node has no
   * parent, it returns undefined.
   * @return {TentaGL.SceneNode}
   */
  getParent:function() {
    return this._parent;
  },
  
  /** 
   * Sets the parent of this node in the scene graph. Although it is possible
   * for a node to be a child for several nodes, a node can only have 1 parent.
   * This can produce unpredictable results when calling methods to get the 
   * node's world transforms which require a traversal up the node's 
   * ancestors.
   * @param {TentaGL.SceneNode}
   */
  setParent:function(node) {
    this._parent = node;
  },
  
  
  /** 
   * Returns whether this node has a parent node in the scene graph. 
   * @return {Boolean}
   */
  hasParent:function() {
    if(this._parent) {
      return true;
    }
    else {
      return false;
    }
  },
  
  /** 
   * Removes this node from its parent in the scene graph.
   */
  removeFromParent:function() {
    if(this._parent && this._parent.remove) {
      this._parent.remove(this);
      this._parent = null;
    }
  },
  
  
  //////// Compositing
  
  /** 
   * If this node is a composite component, this returns its composite parent.
   * Otherwise, this returns undefined.
   * @return {TentaGL.SceneNode}
   */
  getCompositeParent:function() {
    return this._compositeParent;
  },
  
  /** 
   * Sets this node as a composite component of another node.
   * @param {TentaGL.SceneNode} parent
   */
  setCompositeParent:function(parent) {
    this._compositeParent = parent;
  },
  
  
  /**
   * Returns a list of this node's composite hierarchy, with 
   * this at index 0, and the top composite in the last index.
   * @return {array:TentaGL.SceneNode}
   */
  getCompositePath:function() {
    var result = [];
    
    var current = this;
    while(current) {
      result.push(current);
      current = current.getCompositeParent();
    }
    
    return result;
  },
  
  
  //////// Visibility
  
  /** 
   * Returns true iff this node's visibility flag is true. 
   * @return {Boolean}
   */
  isVisible:function() {
    return this._isVisible;
  },
  
  
  /** 
   * Sets whether this node is visible. 
   */
  setVisible:function(visible) {
    this._isVisible = visible;
  },
  
  
  //////// Position
  
  /** 
   * Returns the Sprite's XYZ position in local coordinates.
   * @return {vec4}
   */
  getXYZ:function() {
    return this._xyz;
  },
  
  
  getWorldXYZ:function() {
    var wTran = this.getWorldTransform();
    var x = wTran[12];
    var y = wTran[13];
    var z = wTran[14];
    return vec4.fromValues(x, y, z, 1);
  },
  
  
  /** 
   * Sets the Sprite's XYZ in local coordinates.
   * @param {vec3} xyz
   */
  setXYZ:function(xyz) {
    this._xyz[0] = xyz[0];
    this._xyz[1] = xyz[1];
    this._xyz[2] = xyz[2];
    this._tranDirty = true;
  },
  
  /**
   * Returns the Sprites X local coordinate.
   * @return {Number}
   */
  getX:function() {
    return this._xyz[0];
  },
  
  /**
   * Returns the Sprites Y local coordinate.
   * @return {Number}
   */
  getY:function() {
    return this._xyz[1];
  },
  
  /**
   * Returns the Sprites Z local coordinate.
   * @return {Number}
   */
  getZ:function() {
    return this._xyz[2];
  },
  
  
  //////// Euclid angles
  
  
  /** 
   * Sets the orientation to be equivalent to the following matrix product: 
   * rotateX*rotateY*rotateZ
   * @param {length-3 array} xyz
   */
  setEuclidXYZ:function(xyz) {
    var q = quat.create();
    quat.rotateX(q, q, xyz[0]);
    quat.rotateY(q, q, xyz[1]);
    quat.rotateZ(q, q, xyz[2]);
    
    this.setQuat(q);
  },
  
  /** 
   * Sets the orientation to be equivalent to the following matrix product: 
   * rotateX*rotateZ*rotateY
   * @param {length-3 array} xyz
   */
  setEuclicXZY:function(xyz) {
    var q = quat.create();
    quat.rotateX(q, q, xyz[0]);
    quat.rotateZ(q, q, xyz[2]);
    quat.rotateY(q, q, xyz[1]);
    
    this.setQuat(q);
  },
  
  /** 
   * Sets the orientation to be equivalent to the following matrix product: 
   * rotateY*rotateX*rotateZ
   * @param {length-3 array} xyz
   */
  setEuclicYXZ:function(xyz) {
    var q = quat.create();
    quat.rotateY(q, q, xyz[1]);
    quat.rotateX(q, q, xyz[0]);
    quat.rotateZ(q, q, xyz[2]);
    
    this.setQuat(q);
  },
  
  /** 
   * Sets the orientation to be equivalent to the following matrix product: 
   * rotateY*rotateZ*rotateX
   * @param {length-3 array} xyz
   */
  setEuclidYZX:function(xyz) {
    var q = quat.create();
    quat.rotateY(q, q, xyz[1]);
    quat.rotateZ(q, q, xyz[2]);
    quat.rotateX(q, q, xyz[0]);
    
    this.setQuat(q);
  },
  
  /** 
   * Sets the orientation to be equivalent to the following matrix product: 
   * rotateZ*rotateX*rotateY
   * @param {length-3 array} xyz
   */
  setEuclidZXY:function(xyz) {
    var q = quat.create();
    quat.rotateZ(q, q, xyz[2]);
    quat.rotateX(q, q, xyz[0]);
    quat.rotateY(q, q, xyz[1]);
    
    this.setQuat(q);
  },
  
  /** 
   * Sets the orientation to be equivalent to the following matrix product: 
   * rotateZ*rotateY*rotateX
   * @param {length-3 array} xyz
   */
  setEuclidZYX:function(xyz) {
    var q = quat.create();
    quat.rotateZ(q, q, xyz[2]);
    quat.rotateY(q, q, xyz[1]);
    quat.rotateX(q, q, xyz[0]);
    
    this.setQuat(q);
  },
  
  
  //////// Quaterion/Orientation
  
  
  /** 
   * Returns the quaternion for this sprite. 
   * @return {quat}
   */
  getQuat:function() {
    return this._quat;
  },
  
  /** 
   * Returns the quaternion representing this node's orietnation 
   * in world coordinates. 
   * @return {quat}
   */
  getWorldQuat:function() {
    return this._getWorldQuat(quat.create());
  },
  
  _getWorldQuat:function(q) {
    quat.mul(q, this.getQuat(), q);
    if(this._parent) {
      return this._parent._getWorldQuat(q);
    }
    else {
      return q;
    }
  },
  
  /** 
   * Sets the quaternion for this sprite. 
   * @param {quat} q
   */
  setQuat:function(q) {
    this._quat = q;
    this._tranDirty = true;
  },
  
  
  getParentWorldQuat:function() {
    if(this._parent) {
      return this._parent.getWorldQuat();
    }
    else {
      return quat.create();
    }
  },
  
  
  /** 
   * Rotates the quaternion for this node ccw around the specified axis by the  
   * specified number of radians. 
   * @param {vec3} axis
   * @param {Number} rads
   */
  rotate:function(axis, rads) {
    var q = quat.setAxisAngle(quat.create(), axis, rads);
    this.setQuat(quat.mul(this._quat, q, this._quat));
  },
  
  
  /** 
   * Rotates the quaternion for this node's orientation S with some 
   * other quaternion T. 
   * The result quaternion is Q = T*S.
   * @param {quat} q
   */
  mulQuat:function(q) {
    this.setQuat(quat.mul(this._quat, q, this._quat));
  },
  
  
  //////// Look vector & orientation
  
  /** 
   * Returns the node's unit look vector in local space. This is used as the X
   * axis in the node's look space.
   * @return {vec3}
   */
  getBaseLook:function() {
    return this._objLook;
  },
  
  
  /** 
   * Returns the node's unit look vector in world space. This is used as the X
   * axis in the node's look space.
   * @return {vec3}
   */
  getWorldBaseLook:function() {
    var q = this.getParentWorldQuat();
    return vec3.transformQuat(vec3.create(), this._objLook, q);
  },
  
  
  /** 
   * Sets and normalizes the base look vector for the node in local space. 
   * @param {vec3} look
   */
  setBaseLook:function(look) {
    vec3.normalize(this._objLook, look);
    this._correctUpVector();
  },
  
  
  /** 
   * Get the node's oiented look vector in local coordinates.
   * @return {vec3}
   */
  getLook:function() {
    return vec3.transformQuat(vec3.create(), this._objLook, this._quat);
  },
  
  
  
  /** 
   * Returns the oriented look vector of this node in world coordinates. 
   * @return {vec3}
   */
  getWorldLook:function() {
    var worldQuat = this.getWorldQuat();
    return vec3.transformQuat(vec3.create(), this.getBaseLook(), worldQuat);
  },

  
  //////// Right vector & orientation
  
  /**
   * Returns the node's base unit right vector. (The cross product
   * of the look and up unit vectors). This is used as the Z axis in
   * look space.
   */
  getBaseRight:function() {
    return vec3.cross(vec3.create(), this._objLook, this._objUp);
  },
  
  /** 
   * Returns the node's unit right vector in world space. This is used as the Z 
   * axis in look space.
   * @return {vec3}
   */
  getWorldBaseRight:function() {
    var q = this.getParentWorldQuat();
    return vec3.transformQuat(vec3.create(), this.getBaseRight(), q);
  },
  
  
  /** 
   * Returns the oriented right vector of this node in local space.
   * @return {vec3}
   */
  getRight:function() {
    return vec3.transformQuat(vec3.create(), this.getBaseRight(), this._quat);
  },
  
  
  /**
   * Returns the oriented right vector of this node in world coordinates.
   * @return {vec3}
   */
  getWorldRight:function() {
    var worldQuat = this.getWorldQuat();
    return vec3.transformQuat(vec3.create(), this.getBaseRight(), worldQuat);
  },
  
  
  //////// Up vector & orientation
  
  /** 
   * Get the node's oriented up vector in local coordinates.
   * @return {vec3}
   */
  getUp:function() {
    return vec3.transformQuat(vec3.create(), this._objUp, this._quat);
  },
  
  
  /**
   * Returns the oriented up vector of this node in world coordinates.
   * @return {vec3}
   */
  getWorldUp:function() {
    var worldQuat = this.getWorldQuat();
    return vec3.transformQuat(vec3.create(), this.getBaseUp(), worldQuat);
  },
  
  
  /** 
   * Returns the node's base unit up vector. This is used as the Y axis in the
   * node's look space. 
   * @return {vec3}
   */
  getBaseUp:function() {
    return this._objUp;
  },
  
  
  /** 
   * Returns the node's unit up vector in world space. This is used as the Y
   * axis in the node's look space.
   * @return {vec3}
   */
  getWorldBaseUp:function() {
    var q = this.getParentWorldQuat();
    return vec3.transformQuat(vec3.create(), this._objUp, q);
  },
  

  /** 
   * Sets and normalizes the base up vector for the node. 
   * @param {vec3} up
   */
  setBaseUp:function(up) {
    vec3.normalize(this._objUp, up);
    this._correctUpVector();
  },
  
  /** 
   * Corrects the base up vector so that it forms a right angle with the base 
   * look vector. 
   */
  _correctUpVector:function() {
    var look = this._objLook;
    var up = this._objUp;
    var right = vec3.cross(vec3.create(), look, up);
    this._objUp = vec3.cross(up, right, look);
  },
  
  
  //////// Look/Up/Right vectors
  
  /** 
   * Returns an array containing the node's base look, up, and right vectors, 
   * in that order.
   * @return {length 3 array} Each element is a vec3.
   */
  getBaseLookVectors:function() {
    return [this.getBaseLook(), this.getBaseUp(), this.getBaseRight()];
  },
  
  
  /** 
   * Returns an array containing the node's look, up, and right vectors in
   * local coordinates, in that order.
   * @return {length 3 array} Each element is a vec3.
   */
  getLookVectors:function() {
    var q = this.getQuat();
    var look = vec3.transformQuat(vec3.create(), this._objLook, this._quat);
    var up = vec3.transformQuat(vec3.create(), this._objUp, this._quat);
    var right = vec3.transformQuat(vec3.create(), this.getBaseRight, this._quat);
    
    return [look, up, right];
  },
  
  /** 
   * Returns an array containing the node's look, up, and right vectors in
   * world coordinates, in that order.
   * @return {length 3 array} Each element is a vec3.
   */
  getWorldLookVectors:function() {
    var q = this.getWorldQuat();
    var look = vec3.transformQuat(vec3.create(), this._objLook, this._quat);
    var up = vec3.transformQuat(vec3.create(), this._objUp, this._quat);
    var right = vec3.transformQuat(vec3.create(), this.getBaseRight, this._quat);
    
    return [look, up, right];
  },
  
  
  
  
  //////// Orientation
  
  /** 
   * Orients the node so that its look and up vectors are in the 
   * specified directions in local space. 
   * @param {vec3} look
   * @param {vec3} up
   */
  orient:function(look, up) {
    /*
    var q = TentaGL.Math.getQuatFromTo(this.getBaseLook(), look);
    this.setQuat(q);
    
    if(up) {
      var curUp = this.getUp();
      var q2 = TentaGL.Math.getQuatFromTo(curUp, up);
      this.mulQuat(q2);
    }
    */
    
    this.setQuat(TentaGL.Math.getOrientation(this.getBaseLook(), this.getBaseUp(), look, up));
  },
  
  /** 
   * Orients the node so that its look and up vectors are in the specified 
   * directions in world space.
   * @param {vec3} look
   * @param {vec3} up
   */
  orientWorld:function(look, up) {
    var qToLocal = this.getParentWorldQuat();
    quat.invert(qToLocal, qToLocal);
    look = vec3.transformQuat(vec3.create(), look, qToLocal);
    up = vec3.transformQuat(vec3.create(), up, qToLocal);
    
    this.setQuat(TentaGL.Math.getOrientation(this.getBaseLook(), this.getBaseUp(), look, up));
  },
  
  
  //////// Look-At/Billboarding
  
  /** 
   * Orients the node to look towards the specified point in local space.
   * The look vector will be oriented towards the point, but the up vector
   * will be tilted from the base up vector.
   */
  lookAt:function(p) {
    var xyz = this.getXYZ();
    
    var dx = p[0] - xyz[0];
    var dy = p[1] - xyz[1];
    var dz = p[2] - xyz[2];
    
    var look = vec3.fromValues(dx, dy, dz);
    var right = vec3.cross(vec3.create(), look, this.getBaseUp());
    var up = vec3.cross(vec3.create(), right, look);
    
    this.orient(look, up);
  },
  
  /** 
   * Orients the node to look towards the specified point in world space.
   * The look vector will be oriented towards the point, but the up vector
   * will be tilted from the base up vector.
   */
  lookAtWorld:function(p) {
    var xyz = this.getWorldXYZ();
    
    var dx = p[0] - xyz[0];
    var dy = p[1] - xyz[1];
    var dz = p[2] - xyz[2];
    
    var look = vec3.fromValues(dx, dy, dz);
    var right = vec3.cross(vec3.create(), look, this.getWorldBaseUp());
    var up = vec3.cross(vec3.create(), right, look);
    
    this.orientWorld(look, up);
  },
  
  
  
  
  /** 
   * Orients the node so that it looks towards a certain point in local space 
   * and its up vector is oriented in some specified general direction 
   * in local space.
   * @param {vec4} p    The point to look at.
   * @param {vec3} up   The general direction of "up".
   */
  billboardPoint:function(p, up) {
    var xyz = this.getXYZ();
    
    var dx = p[0] - xyz[0];
    var dy = p[1] - xyz[1];
    var dz = p[2] - xyz[2];
    
    var look = vec3.fromValues(dx, dy, dz);
    var right = vec3.cross(vec3.create(), look, up);
    up = vec3.cross(vec3.create(), right, look);
    
    this.orient(look, up);
  },
  
  
  /** 
   * Orients the node so that it looks towards a certain point in world space 
   * and its up vector is oriented in some specified general direction 
   * in world space.
   * @param {vec4} p    The point to look at.
   * @param {vec3} up   The general direction of "up".
   */
  billboardWorldPoint:function(p, up) {
    var xyz = this.getWorldXYZ();
    
    var dx = p[0] - xyz[0];
    var dy = p[1] - xyz[1];
    var dz = p[2] - xyz[2];
    
    var look = vec3.fromValues(dx, dy, dz);
    var right = vec3.cross(vec3.create(), look, up);
    up = vec3.cross(vec3.create(), right, look);
    
    this.orientWorld(look, up);
  },
  
  
  /** 
   * Orients the node so that it looks in the direction of some point in local space, 
   * but its up vector remains set as the base up vector.
   */
  billboardAxis:function(p) {
    var xyz = this.getXYZ();
    var baseLook = this.getBaseLook();
    var baseUp = this.getBaseUp();
    
    var dx = p[0] - xyz[0];
    var dy = p[1] - xyz[1];
    var dz = p[2] - xyz[2];
    
    var look = vec3.fromValues(dx, dy, dz);
    var q = TentaGL.Math.getQuatFromTo(baseLook, look);
    var up = vec3.transformQuat(vec3.create(), baseUp, q);
    
    var rightP = vec3.cross(vec3.create(), look, baseUp);
    var upP = vec3.cross(vec3.create(), rightP, look);
    
    var q2 = TentaGL.Math.getQuatFromTo(up, upP);
    quat.mul(q, q2, q);
    
    var q2 = TentaGL.Math.getQuatFromTo(upP, baseUp);
    quat.mul(q, q2, q);
    
    look = vec3.transformQuat(look, baseLook, q);
    up = baseUp
    
    
    this.orient(look, up);
  },
  
  
  /** 
   * Orients the node so that it looks in the direction of some point in world space, 
   * but its up vector remains set as the base up vector.
   */
  billboardWorldAxis:function(p) {
    var xyz = this.getWorldXYZ();
    var baseLook = this.getWorldBaseLook();
    var baseUp = this.getWorldBaseUp();
    
    var dx = p[0] - xyz[0];
    var dy = p[1] - xyz[1];
    var dz = p[2] - xyz[2];
    
    var look = vec3.fromValues(dx, dy, dz);
    var q = TentaGL.Math.getQuatFromTo(baseLook, look);
    var up = vec3.transformQuat(vec3.create(), baseUp, q);
    
    var rightP = vec3.cross(vec3.create(), look, baseUp);
    var upP = vec3.cross(vec3.create(), rightP, look);
    
    var q2 = TentaGL.Math.getQuatFromTo(up, upP);
    quat.mul(q, q2, q);
    
    var q2 = TentaGL.Math.getQuatFromTo(upP, baseUp);
    quat.mul(q, q2, q);
    
    look = vec3.transformQuat(look, baseLook, q);
    up = baseUp
    
    
    this.orientWorld(look, up);
  },
  
  
  /** 
   * Orients the node so that it is oriented in some plane in local space
   * defined by a look vector and an up vector.
   * @param {vec3} look
   * @param {vec3} up
   */
  billboardPlane:function(look, up) {
    this.orient(look, up);
  },
  
  
  /** 
   * Orients the node so that it is oriented in some plane in local space
   * defined by a look vector and an up vector.
   * @param {vec3} look
   * @param {vec3} up
   */
  billboardWorldPlane:function(look, up) {
    this.orientWorld(look, up);
  },
  
  
  //////// Scale
  
  /** 
   * Returns the sprite's scales along its X, Y, and Z axes.
   * @return {vec3}
   */
  getScaleXYZ:function() {
    return this._ScaleXYZ;
  },
  
  /** 
   * Sets the sprite's scales along its X, Y, and Z axes.
   * @param {vec3} xyz
   */
  setScaleXYZ:function(xyz) {
    this._scaleXYZ = vec3.fromValues(xyz[0], xyz[1], xyz[2]);
    this._tranDirty = true;
  },
  
  /** 
   * Returns the X component of the sprite's scale.
   * @return {Number}
   */
  getScaleX:function() {
    return this._scaleXYZ[0];
  },
  
  /**
   * Returns the Y component of the sprite's scale.
   * @return {Number}
   */
  getScaleY:function() {
    return this._scaleXYZ[1];
  },
  
  /** 
   * Returns the Z component of the sprite's scale.
   * @return {Number}
   */
  getScaleZ:function() {
    return this._scaleXYZ[2];
  },
  
  /** 
   * Returns the uniform scale value of the sprite. 
   * In the sprite's scale transform, this multiplies the axial scale values
   * of the sprite.
   * @return {Number}
   */
  getScaleUni:function() {
    return this._scaleUni;
  },
  
  /** 
   * Sets the uniform scale value of the sprite.
   * In the sprite's scale transform, this multiplies the axial scale values
   * of the sprite.
   * @param {Number} coeff
   */
  setScaleUni:function(coeff) {
    this._scaleUni = coeff;
    this._tranDirty = true;
  },
  
  
  getWorldScaleUni:function() {
    var scale = this.getScaleUni();
    if(this._parent) {
      scale += this._parent.getWorldScaleUni();
    }
    return scale;
  },
  
  //////// Model transform
  
  
  /** 
   * Produces and returns the sprite's local model transform.
   * @return {mat4}
   */
  getModelTransform:function() {
    if(this._tranDirty) {
      this._transform = this.getTRSTransform();
      this._tranDirty = false;
    }
    return this._transform;
  },
  
  
  getTRSTransform:function() {
    var tx = this.getX();
    var ty = this.getY();
    var tz = this.getZ();
    
    var sUni = this.getScaleUni();
    var scaleX = this.getScaleX()*sUni;
    var scaleY = this.getScaleY()*sUni;
    var scaleZ = this.getScaleZ()*sUni;
    
    var m = this._transform; 
    mat4.fromQuat(m, this.getQuat());
    m[0] *= scaleX;
    m[1] *= scaleX;
    m[2] *= scaleX;
    
    m[4] *= scaleY;
    m[5] *= scaleY;
    m[6] *= scaleY;
    
    m[8] *= scaleZ;
    m[9] *= scaleZ;
    m[10] *= scaleZ;
    
    m[12] = tx;
    m[13] = ty;
    m[14] = tz;
    m[15] = 1;
    
    return m;
  },
  
  
  /** 
   * Obtains the world transform matrix for this node in the scene graph. 
   * This is simply the product of this node's model transform with its
   * ancestors' that results in the final model transformation of the node at 
   * render time.
   * @return {mat4}
   */
  getWorldTransform:function() {
    return this._getWorldTransform(mat4.create());
  },
  
  /** Private helper for getWorldTransform. */
  _getWorldTransform:function(resultMat) {
    mat4.mul(resultMat, this.getModelTransform(), resultMat);
    if(this._parent) {
      this._parent._getWorldTransform(resultMat);
    }
    return resultMat;
  },
  
  
  
  //////// Rendering
  
  
  /** 
   * Renders this node, temporarily concatenating its model transform to the 
   * current Model-view transform of the scene. 
   * @param {WebGLRenderingContext} gl
   */
  render:function(gl) {
    if(!this.isVisible() || !TentaGL.SceneNode.filter(this)) {
      return;
    }
    TentaGL.ViewTrans.push(gl);

    TentaGL.ViewTrans.mul(gl, this.getModelTransform());
    this.draw(gl);
    
    TentaGL.ViewTrans.pop(gl);
  },
  
  
  /** 
   * "Draws" the contents of this node.
   * Override this. 
   */
  draw:function(gl) {}
};


/** 
 * Always returns true for all nodes. 
 * @param {TentaGL.SceneNode} node
 * @return {boolean}
 */
TentaGL.SceneNode.defaultRenderFilter = function(node) {
  return true;
};

/** 
 * Returns the function being used as the rendering filter for the scene graph.
 * If the render filter has not been set, it will be set to the default filter,
 * which always returns true.
 * @return {function(node : TentaGL.SceneNode) : boolean}
 */
TentaGL.SceneNode.getRenderFilter = function() {
  if(!TentaGL.SceneNode._renderFilter) {
    TentaGL.SceneNode.resetRenderFilter();
  }
  return TentaGL.SceneNode._renderFilter;
};

/**
 * Sets the function used as the rendering filter for the scene graph.
 * This rendering filter is used to tell the scene graph whether a node 
 * (and everything underneath it in the tree) should be rendered. 
 * The node will be rendered if the current rendering filter returns true for it.
 * @param {function(node : TentaGL.SceneNode) : boolean} filter
 */
TentaGL.SceneNode.setRenderFilter = function(filter) {
  TentaGL.SceneNode._renderFilter = filter;
};


/** 
 * Sets the scene graph's rendering filter to the default one, 
 * which always returns true. 
 */
TentaGL.SceneNode.resetRenderFilter = function() {
  TentaGL.SceneNode.setRenderFilter(TentaGL.SceneNode.defaultRenderFilter);
};


/** 
 * Calls the current rendering filter on a SceneNode and returns the filter's result. 
 * @param {TentaGL.SceneNode} node
 * @return {boolean}
 */
TentaGL.SceneNode.filter = function(node) {
  return TentaGL.SceneNode.getRenderFilter()(node);
};


Util.Inheritance.inherit(TentaGL.SceneNode, TentaGL.Renderable);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A SceneNode containing a list of child SceneNodes. 
 * The group has an ordering from back to front with which it renders its
 * children nodes. The back nodes at the start of the group's list
 * are rendered first, followed by nodes towards the front at the end of the
 * group's list. This is more important for 2D rendering when depth-test
 * is turned off.
 */
TentaGL.SceneGroup = function(xyz) {
  TentaGL.SceneNode.call(this, xyz);
  this._children = [];
};


TentaGL.SceneGroup.prototype = {
  
  constructor:TentaGL.SceneGroup,
  
  
  /** 
   * Frees the GL memory and resources associated with any SceneNodes 
   * in this group. Then the group is cleared.
   */
  clean:function(gl) {
    for(var i in this._children) {
      this._children[i].clean(gl);
    }
    this.clear();
  },
  
  
  /** 
   * Returns the index of some node in the group. If the node doesn't exist in 
   * this group, it returns -1.
   * @param {TentaGL.SceneNode} node
   * @return {int}
   */
  indexOf:function(node) {
    return this._children.indexOf(node);
  },
  
  
  /** 
   * Returns the node at the specified index in the group.
   * @param {int} index
   * @return {TentaGL.SceneNode}
   */
  get:function(index) {
    return this._children[index];
  },
  
  /** 
   * Returns a copy of the group's children SceneNodes. 
   * @return {Array}
   */
  getChildren:function() {
    return this._children.concat([]);
  },
  
  
  /** 
   * Adds a node to the front of the group. 
   * @param {TentaGL.SceneNode} node
   */
  add:function(node) {
    this._children.push(node);
    node.setParent(this);
  },
  
  
  /** 
   * Returns the size of the group. 
   * @return {int}
   */
  size:function() {
    return this._children.length;
  },
  
  
  /** 
   * Removes a node from this group. Returns true if the remove was successful
   * or false if not.
   * @param {TentaGL.SceneNode} node
   * @return {Boolean}
   */
  remove:function(node) {
    var index = this._children.indexOf(node);
    if(index == -1) {
      return false;
    }
    else {
      this._children.splice(index, 1);
      return true;
    }
  },
  
  
  /** 
   * Removes all the group's children nodes. 
   */
  clear:function() {
    this._children = [];
  },
  
  /** 
   * Moves a node back 1 place in the group, swapping positions with the one
   * previously behind it.
   * @param {TentaGL.SceneNode} node
   */
  moveBack:function(node) {
    var index = this._children.indexOf(node);
    if(index > 0) {
      var temp = this._children[index-1];
      this._children[index-1] = this._children[index];
      this._children[index] = temp;
    }
  },
  
  /** 
   * Moves a node forward 1 place in the group, swapping positions with the one
   * previously in front of it.
   * @param {TentaGL.SceneNode} node
   */
  moveForward:function(node) {
    
    if(index != -1 && index < this._children.length) {
      var temp = this._children[index+1];
      this._children[index+1] = this._children[index];
      this._children[index] = temp;
    }
  },
  
  /** 
   * Moves a node to the front of the group. 
   * @param {TentaGL.SceneNode} node
   */
  moveToFront:function(node) {
    if(this.remove(node)) {
      this._children.push(node);
    }
  },
  
  
  /** 
   * Moves a node to the back of the group.
   * @param {TentaGL.SceneNode} node
   */
  moveToBack:function(node) {
    if(this.remove(node)) {
      this._children.unshift(node);
    }
  },
  
  
  /** 
   * Render's this group's children in ascending Z order in view space. 
   * @param {WebGLRenderingContext} gl
   */
  renderSorted:function(gl) {
    if(!this.isVisible()) {
      return;
    }
    
    // TODO: Better sorted rendering. This doesn't sort descendants of descendants.
    
    // Sort the children nodes.
    var viewTrans = TentaGL.ViewTrans.getCamera(gl).getViewTransform();
    this._children.sort(function(a, b) {
      var aPos = a.getWorldXYZ();
      vec3.transformMat4(aPos, aPos, viewTrans);
      
      var bPos = b.getWorldXYZ();
      vec3.transformMat4(bPos, bPos, viewTrans);
      
      return aPos[2] - bPos[2];
    });
    
    // Render the group node.
    this.render(gl);
  },
  
  
  /** Renders the nodes in this group. */
  draw:function(gl) {
    for(var i=0; i<this.size(); i++) {
      var child = this._children[i];
      child.render(gl);
    }
  }
};

Util.Inheritance.inherit(TentaGL.SceneGroup, TentaGL.SceneNode);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Constructs a sprite (some transformable entity existing at a point in 
 * 3D space) at the specified world coordinates.
 * Most sprite properties are only useful if the ShaderProgram provides uniform
 * variables to use them. 
 *
 * However, TentaGL requires shaders to mind a mvpTrans uniform and a 
 * normalTrans uniform. This should be done through the ShaderProgram's 
 * bindMVPTransUni and bindNormalTransUni methods after the 
 * ShaderProgram is created, but before any sprites are rendered.
 * @constructor
 * @param {vec3} xyz  Optional. If the sprite's world coordinates aren't 
 *      provided, they will be set to [0, 0, 0]. 
 */
TentaGL.Sprite = function(xyz) {
  TentaGL.SceneNode.call(this, xyz);
  
  this._anchorXYZ = vec4.fromValues(0, 0, 0, 1);
  this._pickEventListeners = [];
};


TentaGL.Sprite.prototype = {
  
  constructor:TentaGL.Sprite,
  
  isaSprite:true,
  
  //////// Anchor point
  
  /** 
   * Returns the homogeneous xyz coordinates of the sprite's anchor point. 
   * The anchor point is the position of the sprite's origin point in relation
   * to its model's origin point.
   * @return {vec4}
   */
  getAnchorXYZ:function() {
    return this._anchorXYZ;
  },
  
  /** 
   * Sets the anchor point for the sprite.
   * The anchor point is the position of the sprite's origin point in relation
   * to its model's origin point.
   * @param {vec3} xyz
   */
  setAnchorXYZ:function(xyz) {
    this._anchorXYZ = vec4.fromValues(xyz[0], xyz[1], xyz[2], 1);
  },
  
  /** 
   * Returns the x coordinate of the sprite's anchor point. 
   * @return {Number}
   */
  getAnchorX:function() {
    return this._anchorXYZ[0];
  },
  
  /** 
   * Returns the y coordinate of the sprite's anchor point. 
   * @return {Number}
   */
  getAnchorY:function() {
    return this._anchorXYZ[1];
  },
  
  /** 
   * Returns the z coordinate of the sprite's anchor point. 
   * @return {Number}
   */
  getAnchorZ:function() {
    return this._anchorXYZ[2];
  },
  
  
  //////// Events
  
  /** 
   * Publishes a PickEvent to this sprite's PickEventListeners in relevance 
   * to some context.
   * @param {Object} context
   */
  firePickEvent:function(context) {
    var event = new TentaGL.PickEvent(this, context);
    
    for(var i in this._pickEventListeners) {
      this._pickEventListeners[i].handlePickEvent(event);
    }
  },
  
  
  /** 
   * Subscribes a PickEventListener to this Sprite.  
   * @param {TentaGL.PickEventListener} listener
   */
  addPickEventListener:function(listener) {
    this._pickEventListeners.push(listener);
  },
  
  
  /** 
   * Removes a PickEventListener from this Sprite's subscribers.
   * @param {TentaGL.PickEventListener} listener
   */
  removePickEventListener:function(listener) {
    var index = this._pickEventListeners.indexOf(node);
    if(index == -1) {
      return false;
    }
    else {
      this._pickEventListeners.splice(index, 1);
      return true;
    }
  },
  
  
  //////// Transform
  
  
  /** The model transform for sprites also needs to take into account anchor points. */
  getTRSTransform:function() {
    var tx = this.getX();
    var ty = this.getY();
    var tz = this.getZ();
    
    var ax = 0-this.getAnchorX();
    var ay = 0-this.getAnchorY();
    var az = 0-this.getAnchorZ();
    
    var sUni = this.getScaleUni();
    var scaleX = this.getScaleX()*sUni;
    var scaleY = this.getScaleY()*sUni;
    var scaleZ = this.getScaleZ()*sUni;
    
    var m = this._transform; 
    mat4.fromQuat(m, this.getQuat());
    m[0] *= scaleX;
    m[1] *= scaleX;
    m[2] *= scaleX;
    
    m[4] *= scaleY;
    m[5] *= scaleY;
    m[6] *= scaleY;
    
    m[8] *= scaleZ;
    m[9] *= scaleZ;
    m[10] *= scaleZ;
    
    m[12] = ax*m[0] + ay*m[4] + az*m[8] + tx;
    m[13] = ax*m[1] + ay*m[5] + az*m[9] + ty;
    m[14] = ax*m[2] + ay*m[6] + az*m[10] + tz;
    m[15] = 1;
    
    return m;
  },
  
  //////// Rendering

  
  /** 
   * Sets the materials for and draws the Models making up this sprite. 
   * Override this. 
   */
  draw:function(gl) {}
};


Util.Inheritance.inherit(TentaGL.Sprite, TentaGL.SceneNode);




/** 
 * Creates a simple, generic sprite which renders using a specified model, 
 * material, material lighting properties, and shader.
 * @param {vec3} xyz
 * @param {string} modelName
 * @param {string} materialName
 * @param {string} shaderName
 * @param {TentaGL.MaterialProps} matProps    Optional. If not provided, a default MaterialProps is created.
 * @return {TentaGL.Sprite}
 */
TentaGL.Sprite.create = function(xyz, modelName, materialName, shaderName, matProps) {
  var sprite = new TentaGL.Sprite(xyz);
  
  if(!matProps) {
    matProps = new TentaGL.MaterialProps();
  }
  
  sprite.draw = function(gl) {
    try {
      TentaGL.ShaderLib.use(gl, shaderName);
      TentaGL.MaterialLib.use(gl, materialName);
      matProps.useMe(gl);
      TentaGL.ModelLib.render(gl, modelName);
    }
    catch (e) {
      // console.log("sprite resource not ready: " + e.message);
    }
  };
  
  return sprite;
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A sprite in 3D space that is always facing towards the camera's eye and is oriented 
 * relative to the camera's up vector. 
 * @constructor
 * @param {vec4} xyz
 */
TentaGL.BillboardSprite = function(xyz) {
  TentaGL.Sprite.call(this, xyz);
};


TentaGL.BillboardSprite.prototype = {
  
  constructor:TentaGL.BillboardSprite,
  
  isaBillboardSprite:true,
  
  //////// Rendering
  
  /** 
   * Renders this sprite, temporarily concatenating its model transform to the 
   * current Model-view transform of the scene. 
   * @param {WebGLRenderingContext} gl
   */
  render:function(gl) {
    if(!this.isVisible() || !TentaGL.SceneNode.filter(this)) {
      return;
    }
    TentaGL.ViewTrans.push(gl);
    
    var camera = TentaGL.ViewTrans.getCamera(gl);
    var camEye = camera.getEye();
    this.billboardWorldPoint(camEye, camera.getUp())
    
    TentaGL.ViewTrans.mul(gl, this.getModelTransform());
    this.draw(gl);
    
    TentaGL.ViewTrans.pop(gl);
  },
  
  /** 
   * Sets the materials for and draws the Models making up this sprite. 
   * Override this. 
   */
  draw:function(gl) {}
};


Util.Inheritance.inherit(TentaGL.BillboardSprite, TentaGL.Sprite);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A composite sprite is similar to both a SceneGroup and a Sprite. It is a 
 * Sprite that consists of several other child SceneNodes.
 * If a component within a CompositeSprite is picked, the picker will return 
 * the CompositeSprite instead of the underlying sprite that was actually 
 * picked.
 * @mixes {TentaGL.Sprite}
 * @constructor
 * @param {vec3} xyz
 * @param {array:SceneNode} components
 */
TentaGL.CompositeSprite = function(xyz, components) {
  TentaGL.Sprite.call(this, xyz);
  
  this._components = [];
  for(var i in components) {
    this.addComponent(components[i]);
  }
};


TentaGL.CompositeSprite.prototype = {
  
  constructor:TentaGL.CompositeSprite,
  
  isaCompositeSprite:true,
  
  /** 
   * Adds a SceneNode as a component of this composite. 
   * @param {TentaGL.SceneNode} sceneNode
   */
  addComponent:function(sceneNode) {
    if(sceneNode.getCompositeParent()) {
      throw new Error("CompositeSprite component cycle detected.");
    }
    
    this._components.push(sceneNode);
    sceneNode.setCompositeParent(this);
    sceneNode.setParent(this);
  },
  
  /** 
   * Returns the list of component SceneNodes composing this sprite.
   * @return {array:SceneNode}
   */
  getComponents:function() {
    return this._components;
  },
  
  
  /** 
   * Renders each component in the composite sprite, starting from index 0 to
   * the last index.
   * @param {WebGLRenderingContext} gl
   */
  draw:function(gl) {
    for(var i=0; i < this._components.length; i++) {
      this._components[i].render(gl);
    }
  }
  
};


Util.Inheritance.inherit(TentaGL.CompositeSprite, TentaGL.Sprite);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * A composite sprite consisting of an icon and a label. 
 * @constructor
 * @param {vec3} xyz
 * @param {string} iconTexName    The name of the Material to use for the icon.
 * @param {string} labelText      The text to be displayed as the label.
 * @param {string} labelBGTexName   The name of the texture used for the frame around the label.
 * @param {TentaGL.BlitteredFont} blitFont  The blittered font used to render the text.
 */
TentaGL.LabelledIconSprite = function(xyz, iconTexName, labelText, labelBGTexName, blitFont) {
  TentaGL.CompositeSprite.call(this, xyz);
  
  this._createIcon(iconTexName);
  this._createLabel(labelText, labelBGTexName, blitFont);
};


TentaGL.LabelledIconSprite.prototype = {
  
  constructor:TentaGL.LabelledIconSprite,
  
  isaLabelledIconSprite:true,
  
  /** 
   * Creates the sprite for the icon.
   * @private 
   */
  _createIcon:function(iconTexName) {
    this._icon = new TentaGL.ImageIconSprite([0, 0, 0], iconTexName);
    this._icon.setAlignment(TentaGL.Align.CENTER, TentaGL.Align.CENTER);
    
    this.addComponent(this._icon);
  },
  
  
  /** 
   * Creates the sprites for the label and its frame.
   * @param {string} labelText      The text to be displayed as the label.
   * @param {string} labelBGTexName   The name of the texture used for the frame around the label.
   * @param {TentaGL.BlitteredFont} blitFont  The blittered font used to render the text.
   */
  _createLabel:function(labelText, labelBGTexName, blitFont) {
    // Create the label sprite.
    this._label = new TentaGL.TextIconSprite([0, 0.3, 0.001], labelText, blitFont, 0.5);
    this._label.setAlignment(TentaGL.Align.CENTER, TentaGL.Align.BOTTOM);
    this.addComponent(this._label);
    
    // Create the label background.
    this._labelBG = new TentaGL.ImageIconSprite([0, 0.3, 0.0005], labelBGTexName);
    this._labelBG.setAlignment(TentaGL.Align.CENTER, TentaGL.Align.BOTTOM);
    this._fitLabelBG();
    this.addComponent(this._labelBG);
  },
  
  
  _fitLabelBG: function() {
    this._labelBG.setScaleXYZ([
      this._label.getIconWidth()/this._labelBG.getIconWidth()+0.1, 
      this._label.getIconHeight()/this._labelBG.getIconHeight(), 
      1
    ]);
  },
  
  //////// Icon
  
  /** 
   * Returns the name of the texture material used for the icon. 
   * @return {string}
   */
  getIcon:function() {
    return this._icon.getTextureName();
  },
  
  
  /** 
   * Sets the texture displayed by the icon to the one with the specified name. 
   * @param {string} name
   */
  setIcon:function(name) {
    this._icon.setTextureName(name);
  },
  
  
  //////// Label
  
  
  /** 
   * Returns the label's text. 
   * @return {string}
   */
  getText:function() {
    return this._label.getText();
  },
  
  /** 
   * Sets the label's text.
   * @param {string} text
   */
  setText:function(text) {
    this._label.setText(text);
    this._fitLabelBG();
  },
  
  
  /** 
   * Returns the name of material used for the label background.
   * @return {string}
   */
  getLabelBG:function() {
    return this._labelBG.getTextureName();
  },
  
  
  /** 
   * Sets the material used for the label background.
   * 
   */
  setLabelBG:function(name) {
    this._labelBG.setTextureName(name);
  },
  
  
  //////// Metrics
  
  
  /** 
   * Returns the pixel width of the icon's texture.
   * @return {int}
   */
  getIconWidth:function() {
    return this._icon.getIconWidth();
  },
  
  /** 
   * Returns the pixel height of the icon's texture.
   * @return {int}
   */
  getIconHeight:function() {
    return this._icon.getIconHeight();
  },
  
  
  //////// Events
  
  /** 
   * The LabelledIconSprite listens for PickEvents from its components 
   * and republishes them as its own. 
   * @param {TentaGL.PickEvent} event
   */
  handlePickEvent:function(event) {
    var src = event.getSource();
    if(src == this._label || src == this._labelBG || src == this._icon) {
      this.firePickEvent(event.getContext());
    }
  },
  
  
  
  //////// Rendering
  
  
  /** 
   * Renders this sprite, temporarily concatenating its model transform to the 
   * current Model-view transform of the scene. 
   * @param {WebGLRenderingContext} gl
   */
  render:function(gl) {
    if(!this.isVisible() || !TentaGL.SceneNode.filter(this)) {
      return;
    }
    TentaGL.ViewTrans.push(gl);
    
    var camera = TentaGL.ViewTrans.getCamera(gl);
    var camEye = camera.getEye();
    this.billboardWorldPlane(vec3.negate(vec3.create(), camera.getLook()), camera.getUp())
    
    this._fitLabelBG();
    
    TentaGL.ViewTrans.mul(gl, this.getModelTransform());
    this.draw(gl);
    
    TentaGL.ViewTrans.pop(gl);
  }
};

Util.Inheritance.inherit(TentaGL.LabelledIconSprite, TentaGL.CompositeSprite);
Util.Inheritance.inherit(TentaGL.LabelledIconSprite, TentaGL.PickEventListener);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An interface for a sprite that always faces the plane behind the camera, 
 * rather than at the camera eye like BillboardSprite does.
 * @constructor
 * @param {vec3} xyz
 */
TentaGL.IconSprite = function(xyz) {
  TentaGL.Sprite.call(this, xyz);
  
  this._hAlign = TentaGL.Align.LEFT;
  this._vAlign = TentaGL.Align.BOTTOM;
};


TentaGL.IconSprite.prototype = {
  
  constructor:TentaGL.IconSprite,
  
  isaIconSprite:true,
  
  
  //////// Metrics
  
  /** 
   * Returns icon's width. Override this.
   * @return {number}
   */
  getIconWidth:function() {},
  
  /**
   * Returns icon's height. Override this.
   * @return {number}
   */
  getIconHeight:function() {},
  
  
  /** 
   * Returns the aspect ratio of the icon. 
   * @return {number}
   */
  getIconAspect:function() {
    return this.getIconWidth()/this.getIconHeight();
  },
  
  
  //////// Alignment
  
  /** 
   * Sets the horizontal and vertical alignment properties of the icon. 
   * @param {enum: TentaGL.Align} horizontal  LEFT, CENTER, or RIGHT
   * @param {enum: TentaGL.Alight} vertical   TOP, CENTER, or BOTTOM
   */
  setAlignment:function(horizontal, vertical) {
    this._hAlign = horizontal;
    this._vAlign = vertical;
    
    this._updateAlignment();
  },
  
  
  
  _updateAlignment: function() {
    var x = undefined;
    var y = undefined;
    
    // Set horizontal alignment.
    if(this._hAlign == TentaGL.Align.LEFT) {
      x =0;
    }
    else if(this._hAlign == TentaGL.Align.CENTER) {
      x = this.getIconWidth()/2;
    }
    else if(this._hAlign == TentaGL.Align.RIGHT) {
      x = this.getIconWidth();
    }
    
    // Set vertical alignment.
    if(this._vAlign == TentaGL.Align.BOTTOM) {
      y = 0;
    }
    else if(this._vAlign == TentaGL.Align.CENTER) {
      y = this.getIconHeight()/2;
    }
    else if(this._vAlign == TentaGL.Align.TOP) {
      y = this.getIconHeight();
    }
    
    this.setAnchorXYZ([x,y,0]);
  },
  
  
  //////// Scaling
  
  /** 
   * Scales the icon such that its X and Y scale properties equal its
   * width and height, respectively.
   */
  scaleIconDims:function() {
    this.setScaleXYZ([this.getIconWidth(), this.getIconHeight(), 1]);
  },
  
  
  /** 
   * Scales the icon such that it becomes the specified width and its height
   * is set such that the aspect ratio for the icon's texture is maintained.
   * @param {Number} width
   */
  scaleToWidth:function(width) {
    var aspect = this.getIconWidth()/this.getIconHeight();
    this.setScaleXYZ([width, width/aspect, 1]);
  },
  
  
  /** 
   * Scales the icon such that it becomes the specified height and its width
   * is set such that the aspect ratio for the icon's texture is maintained.
   * @param {Number} height
   */
  scaleToHeight:function(height) {
    var aspect = this.getIconWidth()/this.getIconHeight();
    this.setScaleXYZ([height*aspect, height, 1]);
  },
  
  
  //////// Rendering
  
  /** 
   * Renders this sprite, temporarily concatenating its model transform to the 
   * current Model-view transform of the scene. 
   * @param {WebGLRenderingContext} gl
   */
  render:function(gl) {
    if(!this.isVisible() || !TentaGL.SceneNode.filter(this)) {
      return;
    }
    TentaGL.ViewTrans.push(gl);
    
    this._updateAlignment();
    
    var camera = TentaGL.ViewTrans.getCamera(gl);
    var camEye = camera.getEye();
    this.billboardWorldPlane(vec3.negate(vec3.create(), camera.getLook()), camera.getUp())
    
    TentaGL.ViewTrans.mul(gl, this.getModelTransform());
    this.draw(gl);
    
    TentaGL.ViewTrans.pop(gl);
  },
  
  
  /** 
   * Sets the materials for and draws the Models making up this sprite. 
   * Override this. 
   */
  draw:function(gl) {}
};



Util.Inheritance.inherit(TentaGL.IconSprite, TentaGL.Sprite);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An IconSprite for displaying an image.
 * All ImageIconSprites are 1 unit tall, unscaled.
 * @constructor
 * @param {vec3} xyz
 * @param {string} texName  The name of the image's texture in MaterialLib.
 */
TentaGL.ImageIconSprite = function(xyz, texName) {
  TentaGL.IconSprite.call(this, xyz);
  this._texName = texName;
  this._texWidth = 1;
  this._texHeight = 1;
};


TentaGL.ImageIconSprite.prototype = {
  
  constructor:TentaGL.ImageIconSprite,
  
  isaImageIconSprite:true,
  
  //////// Texture properties
  
  /** 
   * Returns the name of this icon's texture material. 
   * @return {string}
   */
  getTextureName:function() {
    return this._texName;
  },
  
  
  /** 
   * Changes the texture material used by this icon to the one with the 
   * specified name. 
   * @param {string} name
   */
  setTextureName:function(name) {
    this._texName = name;
  },
  
  
  /** 
   * Returns this icon's texture material. 
   * @return {TentaGL.Texture}
   */
  getTexture:function(gl) {
    return TentaGL.MaterialLib.get(gl, this._texName);
  },
  
  
  /** 
   * Returns the PixelData for the icon's texture material.
   * @return {TentaGL.PixelData}
   */
  getPixelData:function(gl) {
    return this.getTexture(gl).getPixelData();
  },
  
  
  //////// Metrics
  
  /** 
   * Returns width of the icon. 
   * @return {number}
   */
  getIconWidth:function() {
    return this._texWidth/this._texHeight;
  },
  
  /**
   * Returns the height of the icon.
   * @return {number}
   */
  getIconHeight:function() {
    return 1; 
  },
  
  
  /** 
   * Returns the pixel width of the icon's image. 
   * @return {int}
   */
  getTextureWidth: function() {
    return this._texWidth;
  },
  
  /**
   * Returns the pixel height of the icon's image.
   * @return {int}
   */
  getTextureHeight: function() {
    return this._texHeight; 
  },
  
  
  //////// Rendering
  
  
  /** Draws the icon's texture onto a unit plane. */
  draw:function(gl) {    
    TentaGL.MaterialLib.use(gl, this._texName);
    
    var tex = this.getTexture(gl);
    this._texWidth = tex.getWidth();
    this._texHeight = tex.getHeight();
    
    var iconW = this.getIconWidth();
    var iconH = this.getIconHeight();
    
    TentaGL.ViewTrans.scale(gl, [iconW, iconH]);
    TentaGL.ModelLib.render(gl, "unitPlane");
  }
};



Util.Inheritance.inherit(TentaGL.ImageIconSprite, TentaGL.IconSprite);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A sprite for blittered text.
 * @constructor
 * @param {vec3} xyz    The position of the sprite.
 * @param {string} text   The text displayed by this sprite. 
 * @param {TentaGL.BlitteredFont} blitFont    The BlitteredFont used to render 
 *      the text.
 * @param {boolean} yFlipped    Optional. Whether the y axis is flipped.  
 *      If true, y increases down. Else, y increases up. Default false.
 * @param {number} charH    Optional. The preferred height for a single line 
 *      of text displayed with this sprite. If omitted, the height of a line of 
 *      text will be a number of units equal to the blittered font's pixel line 
 *      height.
 */
TentaGL.TextSprite = function(xyz, text, blitFont, yFlipped, charH) {
  TentaGL.Sprite.call(this, xyz);

  if(!yFlipped) {
    yFlipped = false;
  }
  
  this._blitFont = blitFont;
  this._charH = charH;
  this._yFlipped = yFlipped;
  
  this.setText(text);
};


TentaGL.TextSprite.prototype = {
  
  constructor: TentaGL.TextSprite,
  
  isaTextSprite: true,
  
  
  
  //////// Text
  
  /** 
   * Returns the text displayed by this sprite.
   * @return {string}
   */
  getText: function() {
    return this._text;
  },
  
  /** 
   * Sets the text displayed by this sprite.
   * @param {string} text
   */
  setText: function(text) {
    this._text = text;
    
    var dims = this._blitFont.getStringDimensions(text, this._charH);
    this._width = dims[0];
    this._height = dims[1];
  },
  
  
  
  //////// Font
  
  /** 
   * Returns the BlitteredFont used to render this sprite's text.
   * @return {TentaGL.BlitteredFont}
   */
  getBlitteredFont: function() {
    return this._blitFont;
  },
  
  
  /** 
   * Sets the BlitteredFont used to render this sprite's text.
   * @param {TentaGL.BlitteredFont} font
   */
  setBlitteredFont: function(font) {
    this._blitFont = font;
  },
  
  
  //////// Metrics
  
  /** 
   * Returns the preferred height of a single line of text displayed by this 
   * sprite.
   * @return {number}
   */
  getLineHeight: function() {
    if(this._charH === undefined) {
      this._blitFont.getLineHeight();
    }
    else {
      return this._charH;
    }
  },
  
  /** 
   * Sets the preferred height of a single line of text displayed by this 
   * sprite. If set to undefined, this will be the line height of the blittered 
   * font, in pixels.
   * @param {number} h
   */
  setLineHeight: function(h) {
    this._charH = h;
  },
  
  
  /** 
   * Returns the width of the text rendered in this sprite.
   * @return {number}
   */
  getWidth: function() {
    return this._width;
  },
  
  
  /** 
   * Returns the height of the text rendered in this sprite. 
   * @return {number}
   */
  getHeight: function() {
    return this._height;
  },
  
  
  
  
  //////// Rendering
  
  /** 
   * Draws the sprite.
   * @param {WebGLRenderingContext} gl
   */
  draw: function(gl) {
    this._blitFont.renderString(gl, this._text, [0,0,0], this._yFlipped, this._charH);
  }
};

Util.Inheritance.inherit(TentaGL.TextSprite, TentaGL.Sprite);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/



/** 
 * A TextSprite that is also an IconSprite. It displays 2D text in 3D space that
 * is always oriented to face the plane behind the camera.
 * The line height of a TextIconSprite is 1 unit, unscaled.
 * @constructor
 * @param {vec4} xyz
 * @param {string} text
 * @param {TentaGL.BlitteredFont} blitFont    The BlitteredFont used to render 
 *      the text.
 */
TentaGL.TextIconSprite = function(xyz, text, blitFont, lineHeight) {
  TentaGL.IconSprite.call(this);
  TentaGL.TextSprite.call(this, xyz, text, blitFont);
  
  if(!lineHeight) {
    lineHeight = 1;
  }
  this._lineHeight = lineHeight;
};


TentaGL.TextIconSprite.prototype = {
  
  constructor:TentaGL.TextIconSprite,
  
  isaTextIconSprite:true,
  
  
  //////// Metrics
  
  /** 
   * Returns the width of this icon.. 
   * @return {int}
   */
  getIconWidth:function() {
    var dims = this.getBlitteredFont().getStringDimensions(this._text, this._lineHeight);
    return dims[0];
  },
  
  /**
   * Returns the height of this icon.
   * @return {int}
   */
  getIconHeight:function() {
    var dims = this.getBlitteredFont().getStringDimensions(this._text, this._lineHeight);
    return dims[1];
  },
  
  
  /** 
   * Returns the height of a line of text rendered for this TextIconSprite.
   * @return {number}
   */
  getLineHeight: function() {
    return this._lineHeight;
  },
  
  
  /** 
   * Sets the height of a line of text rendered for this TextIconSprite. 
   * @param {number} h
   */
  setLineHeight: function(h) {
    this._lineHeight = h;
  },
  
  
  //////// Rendering
  
  /** 
   * Draws the sprite.
   * @param {WebGLRenderingContext} gl
   */
  draw: function(gl) {
    var dims = this.getBlitteredFont().getStringDimensions(this._text, this._lineHeight);
    TentaGL.ViewTrans.translate(gl, [0, dims[1] - this._lineHeight, 0]);
    
    this.getBlitteredFont().renderString(gl, this._text, [0,0,0], this._yFlipped, this._lineHeight);
  }
};

Util.Inheritance.inherit(TentaGL.TextIconSprite, TentaGL.IconSprite);
Util.Inheritance.inherit(TentaGL.TextIconSprite, TentaGL.TextSprite);


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * An API for changing the Model-View-Projection and Normal transforms for a scene.
 */
TentaGL.ViewTrans = {
  
  
  //////// View transform
  
  /** 
   * Sets the model-view transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans  The new model-view transform matrix.
   */
  set: function(gl, trans) {
    gl._modelViewTrans = trans;
  },
  
  
  /** 
   * Returns the current model-view transform matrix.
   * @return {mat4}
   */
  get: function(gl) {
    return gl._modelViewTrans;
  },
  
  
  /** 
   * Multiplies the model-view transform matrix (M) by another matrix (T) so 
   * that the result is M = M x T.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans
   */
  mul: function(gl, trans) {
    mat4.mul(gl._modelViewTrans, gl._modelViewTrans, trans);
  },
  
  
  /** 
   * Translates the model-view transform matrix. 
   * This is equivalent to calling TentaGL.ViewTrans.mul(gl, T), 
   * where T is a translation transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {vec3} xyz  The amount to translate along each axis.
   */
  translate: function(gl, xyz) {
    if(!xyz[2]) {
      xyz[2] = 0;
    }
    var trans = mat4.create();
    mat4.translate(trans, trans, xyz);
    
    this.mul(gl, trans);
  },
  
  
  /** 
   * Rotates the model-view transform matrix about an axis. 
   * @param {WebGLRenderingContext} gl
   * @param {vec3} axis   The axis to rotate around.
   * @param {number} rads   The angle, in radians.
   */
  rotate: function(gl, axis, rads) {
    var q = quat.create();
    quat.setAxisAngle(q, axis, rads);
    
    var trans = mat4.create();
    mat4.fromQuat(trans, q);
    
    this.mul(gl, trans);
  },
  
  
  /** 
   * Scales the model-view transform matrix. 
   * @param {WebGLRenderingContext} gl
   * @param {vec3} xyz  The amount to scale along each axis.
   */
  scale: function(gl, xyz) {
    if(xyz[2] === undefined) {
      xyz[2] = 1;
    }
    var trans = mat4.create();
    mat4.scale(trans, trans, xyz);
    
    this.mul(gl, trans);
  },
  
  
  /** 
   * Multiplies the model-view transform matrix (M) by another matrix (T) so 
   * that the result is M = T x M.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans
   */
  premul: function(gl, trans) {
    mat4.mul(gl._modelViewTrans, trans, gl._modelViewTrans);
  },
  
  
  /** 
   * Saves the current model-view transform matrix onto the transform stack. 
   * @param {WebGLRenderingContext} gl
   */
  push: function(gl) {
    gl._transformStack.push(mat4.clone(gl._modelViewTrans));
  },
  
  
  /**
   * Restores the current model-view transform matrix from the transform stack.
   * @param {WebGLRenderingContext} gl
   */
  pop: function(gl) {
    gl._modelViewTrans = gl._transformStack.pop();
  },
  
  
  /** 
   * Resets the model-view and projection transform matrices to the identity 
   * matrix and empties the model-view transform stack.
   * @param {WebGLRenderingContext} gl
   */
  reset: function(gl) {
    this.set(gl, mat4.create());
    gl._transformStack = [];
    
    this.setProjection(gl, mat4.create());
    
    gl._normalTrans = mat3.create();
    gl._mvpTrans = mat4.create();
  },
  
  
  //////// View transform
  
  /** 
   * Sets the view transform matrix (and model-view transform matrix). 
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans  The new view matrix.
   */
  setView: function(gl, trans) {
    this.set(trans);
    gl._viewTrans = trans;
  },
  
  
  /** 
   * Returns the current view transform matrix.
   * @return {mat4}
   */
  getView: function(gl) {
    return gl._viewTrans;
  },
  
  
  /** 
   * Multiplies the view transform matrix (M) by another matrix (T) so that the
   * result is M = M x T.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans
   */
  mulView: function(gl, trans) {
    mat4.mul(gl._viewTrans, gl._viewTrans, trans);
  },
  
  /** 
   * Multiplies the view transform matrix (M) by another matrix (T) so 
   * that the result is M = T x M.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans
   */
  premulView: function(gl, trans) {
    mat4.mul(gl._viewTrans, trans, gl._viewTrans);
  },
  
  
  //////// Projection transform
  
  /** 
   * Sets the projection transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans  The new projection matrix.
   */
  setProjection: function(gl, trans) {
    gl._projTrans = trans;
  },
  
  
  /** 
   * Returns the current projection transform matrix.
   * @return {mat4}
   */
  getProjection: function(gl) {
    return gl._projTrans;
  },
  
  
  /** 
   * Multiplies the projection transform matrix (M) by another matrix (T) so 
   * that the result is M = M x T.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans
   */
  mulProjection: function(gl, trans) {
    mat4.mul(gl._projTrans, gl._projTrans, trans);
  },
  
  
  /** 
   * Multiplies the projection transform matrix (M) by another matrix (T) so 
   * that the result is M = T x M.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} trans
   */
  premulProjection: function(gl, trans) {
    mat4.mul(gl._projTrans, trans, gl._projTrans);
  },
  
  
  //////// Shader vars
  
  
  /** 
   * Updates the MVP and normal transform matrix uniform variables in the 
   * currently bound shader program, using the current projection and 
   * model-view matrices.
   * @param {WebGLRenderingContext} gl
   */
  updateMVPUniforms: function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    
    if(program.setNormalTrans) {
      mat3.normalFromMat4(gl._normalTrans, gl._modelViewTrans);
      program.setNormalTrans(gl, gl._normalTrans);
    }
    
    if(program.setMVPTrans) {
      mat4.mul(gl._mvpTrans, gl._projTrans, gl._modelViewTrans);
      program.setMVPTrans(gl, gl._mvpTrans);
    }
    
    if(program.setMVTrans) {
      program.setMVTrans(gl, gl._modelViewTrans);
    }
    
    if(program.setVTrans) {
      program.setVTrans(gl, gl._viewTrans);
    }
  },
  
  
  
  //////// Current camera
  

  /** 
   * Returns the camera being used for the view and projection 
   * transforms by the gl context. 
   * @param {WebGLRenderingContext} gl
   * @return {TentaGL.Camera}
   */
  getCamera: function(gl) {
    return gl._camera;
  },


  /** 
   * Sets the camera being used for the view and projection transforms by the 
   * gl context. The gl context's transforms are set to those of the camera, 
   * effectively reseting the scene transform to the view-projection matrix.
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Camera} camera
   * @param {float} aspect    The aspect ratio for the view.
   */
  setCamera: function(gl, camera, aspect) {
    gl._camera = camera;
    
    this.set(gl, camera.getViewTransform());
    this.setView(gl, camera.getViewTransform());
    this.setProjection(gl, camera.getProjectionTransform(aspect));
  }
  
};




/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/**  
 * A custom font produced from a sprite map of character images.
 * @constructor
 * @param {TentaGL.PixelData} pixelData   The pixel data for the sprite map for the font.
 *      The sprite map should have 16 characters per row with character 0x20 
 *      (space character) first in the upper left corner. It is als assumed that 
 *      each character image in the map has the same dimensions and has a 
 *      1-pixel border. See the example font map at images/finalFontasy.png.
 * @param {boolean} monospaced    Whether the font is monospaced.
 * @param {uint} charW            The width of each character image in the sprite map.
 * @param {uint} charH            The height of each character image in the sprite map.
 * @param {int} hPad              The horizontal padding between rendered characters, in pixels.
 * @param {int} vPad              The vertical padding between rendered characters, in pixels.
 */
TentaGL.BlitteredFont = function(pixelData, monospaced, charW, charH, hPad, vPad) {
  if(pixelData) {
    this._createChars(pixelData, monospaced, charW, charH);
  }
  
  if(hPad === undefined) {
    hPad = 1;
  }
  if(vPad === undefined) {
    vPad = 1;
  }
  
  this._hPad = hPad;
  this._vPad = vPad;
  
  this._texIDPrefix = "bfont" + TentaGL.BlitteredFont._count + ":";
  TentaGL.BlitteredFont._count++;
};

TentaGL.BlitteredFont._count = 0;

TentaGL.BlitteredFont.prototype = {
  
  constructor: TentaGL.BlitteredFont,
  
  isaBlitteredFont: true,
  
  /** 
   * Removes the textures for each character of this blittered font from the 
   * GL context. 
   */
  clean: function(gl) {
    for(var c in this._charPixData) {
      var id = this._texIDPrefix + c;
      
      TentaGL.MaterialLib.remove(gl, id);
    }
  },
  
  
  /** 
   * Creates the pixel data for each of the characters in this blittered font.
   * @param {TentaGL.PixelData} pixelData   The pixel data for the font map image.
   * @param {boolean} monospaced    Whether the blittered font is monospaced.
   * @param {uint} charW            The width of a single character image in the font map.
   * @param {uint} charH            The height of a single character image in the font map.
   */
  _createChars: function(pixelData, monospaced, charW, charH) {
    this._charPixData = {};
    this._charWidths = {};
    
    this._monospaced = monospaced;
    this._charW = charW;
    this._charH = charH;
    
    for(var c = 32; c < 128; c++) {
      var i = (c-32)%16;
      var j = Math.floor((c-32)/16);
      
      var x = 1 + i*(charW + 2);
      var y = pixelData.getHeight() - (1 + charH + j*(2 + charH));
      
      var charID = String.fromCharCode(c);
      var charPix = pixelData.crop(x, y, charW, charH);
      
      
      if(!monospaced && c != 32) {
        var left = 0;
        var right = charPix.getWidth() - 1;
        
        // Find the left border.
        var leftFound = false;
        while(left < right && !leftFound) {
          for(var y=0; y < charPix.getHeight(); y++) {
            if(charPix.getPixelAt(left, y)[3] != 0) { 
              leftFound = true;
              break;
            }
          }
          
          if(!leftFound) {
            left++;
          }
        }
        
        // Find the right border.
        var rightFound = false;
        while(right > left && !rightFound) {
          for(var y=0; y < charPix.getHeight(); y++) {
            if(charPix.getPixelAt(right, y)[3] != 0) { 
              rightFound = true;
              break;
            }
          }
          
          if(!rightFound) {
            right--;
          }
        }
        
        var w = right - left + 1;
        charPix = charPix.crop(left, 0, w, charH);
        
        this._charWidths[charID] = w;
        this._charPixData[charID] = charPix;
        
        charPix.toCanvas();
      }
      else if(!monospaced && c == 32) {
        // None-monospaced spaces are half an em wide.
        this._charWidths[charID] = charW/2;
        this._charPixData[charID] = charPix;
        
        charPix.toCanvas();
      }
      else {
        this._charWidths[charID] = charW;
        this._charPixData[charID] = charPix;
        
        charPix.toCanvas();
      }
    }
  },
  
  
  /** 
   * Returns whether the blittered font is monospaced.
   * @return {boolean}
   */
  isMonospaced: function() {
    return this._monospaced;
  },
  
  
  /** 
   * Returns the height, in pixels, of a single line of text rendered with 
   * the blittered font. 
   * @return {uint}
   */
  getLineHeight: function() {
    return this._charH;
  },
  
  
  /**  
   * Returns the PixelData for a particular character in the blittered font.
   * @param {string} ch   The character.
   * @return {TentaGL.PixelData}
   */
  getCharPixelData: function(ch) {
    return this._charPixData[ch];
  },
  
  
  /** 
   * Returns the width, in pixels, of a particular character in the blittered font.
   * For a monospaced font, this returns the same value for all characters.
   * @param {string} ch   The character.
   * @return {uint}
   */
  getCharWidth: function(ch) {
    return this._charWidths[ch];
  },
  
  
  /** 
   * Returns the horizontal padding between characters for this blittered font, 
   * in pixels.
   * @return {uint}
   */
  getHorizontalPadding: function() {
    return this._hPad;
  },
  
  
  /** 
   * Returns the 
   */
  getVerticalPadding: function() {
    return this._vPad;
  },
  
  
  /** 
   * Creates the textures for each character in the blittered font in the 
   * GL context. 
   * @param {WebGLRenderingContext} gl
   */
  _createTextures: function(gl) {
    for(var c in this._charPixData) {
      var id = this._texIDPrefix + c;
      
      var charTex = TentaGL.Texture.fromPixelData(gl, this._charPixData[c]);
      TentaGL.MaterialLib.add(gl, id, charTex);
    }
  },
  
  
  /** 
   * Returns the dimensions of a string rendered with this blittered font.
   * @param {string} text
   * @param {number} charH    Optional. If provided, the text will be uniformly 
   *      scaled such that every character's height is charH units. If omitted, 
   *      each character's height in units will be equal to the character pixel 
   *      height for this blittered font.
   * @return {[width: number, height: number]}
   */
  getStringDimensions: function(text, charH) {
    if(!this._charWidths) {
      return [0, 0];
    }
    
    var width = 0;
    var height = 0;
    
    var lineHeight = this.getLineHeight();
    var vPad = this.getVerticalPadding();
    var hPad = this.getHorizontalPadding();
    
    var s = 1;
    if(charH) {
      s = charH/lineHeight;
    }
    
    var lines = text.split("\n");
    for(var i=0; i < lines.length; i++) {
      var line = lines[i];
      
      var lineWidth = 0;
      
      for(var j=0; j < line.length; j++) {
        var ch = line.charAt(j);
        var w = this.getCharWidth(ch);
        
        lineWidth += w + hPad;
      }
      
      if(lineWidth > width) {
        width = lineWidth;
      }
      
      height += lineHeight + vPad;
    }
    
    return [width*s, height*s];
  },
  
  
  /** 
   * Renders a string using the blittered font.
   * @param {WebGLRenderingContext} gl
   * @param {string} text     The text to be rendered.
   * @param {vec3} xyz        The position to render the text at.
   * @param {boolean} yFlipped    Optional. Whether the y axis is flipped.  
   *      If true, y increases down. Else, y increases up. Default false.
   * @param {number} charH    Optional. If provided, the text will be uniformly 
   *      scaled such that every character's height is charH units. If omitted, 
   *      each character's height in units will be equal to the character pixel 
   *      height for this blittered font.
   */
  renderString: function(gl, text, xyz, yFlipped, charH) {
    if(!this._charPixData) {
      return;
    }
    
    // If this is the MaterialLib doesn't have the textures loaded, load them.
    if(!TentaGL.MaterialLib.has(gl, this._texIDPrefix + " ")) {
      this._createTextures(gl);
    }
    
    var h = this.getLineHeight();
    var vPad = this.getVerticalPadding();
    var hPad = this.getHorizontalPadding();
    
    TentaGL.ViewTrans.push(gl);
    
    TentaGL.ViewTrans.translate(gl, xyz);
    
    // If charH was provided, uniformly scale the transform so that each 
    // character's height will be charH.
    if(charH) {
      var s = charH/h;
      TentaGL.ViewTrans.scale(gl, [s,s]);
    }
    
    // Render the text line by line.
    var lines = text.split("\n");
    for(var i=0; i < lines.length; i++) {
      var line = lines[i];
      
      TentaGL.ViewTrans.push(gl);
      
      // Render the line character by character.
      for(var j=0; j < line.length; j++) {
        var ch = line.charAt(j);
        var texID = this._texIDPrefix + ch;
        var w = this.getCharWidth(ch);
        
        TentaGL.MaterialLib.use(gl, texID);
        
        // Render the character.
        TentaGL.ViewTrans.push(gl);
        TentaGL.ViewTrans.scale(gl, [w,h]);
        TentaGL.ViewTrans.updateMVPUniforms(gl);
        if(yFlipped) {
          TentaGL.ModelLib.render(gl, "unitSprite");
        }
        else {
          TentaGL.ModelLib.render(gl, "unitPlane");
        }
        TentaGL.ViewTrans.pop(gl);
        
        // Translate over to next character.
        TentaGL.ViewTrans.translate(gl, [w + hPad, 0]);
      }
      
      TentaGL.ViewTrans.pop(gl);
      
      // Translate down to next line.
      if(yFlipped) {
        TentaGL.ViewTrans.translate(gl, [0, h + vPad]);
      }
      else {
        TentaGL.ViewTrans.translate(gl, [0, -(h + vPad)]);
      }
    }
    
    TentaGL.ViewTrans.pop(gl);
  }
  
};


/** 
 * Produces a BlitteredFont from an fontmap image at some url. 
 * @param {string} url
 * @param {boolean} monospaced    Whether the font is monospaced.
 * @param {uint} charW            The width of each character image in the sprite map.
 * @param {uint} charH            The height of each character image in the sprite map.
 * @param {int} hPad              The horizontal padding between rendered characters, in pixels.
 * @param {int} vPad              The vertical padding between rendered characters, in pixels.
 * @param {function(pixels: TentaGL.PixelData): TentaGL.PixelData} pixelsCB  
 *      Optional. A callback function that manipulates the pixel data from the 
 *      fontmap image before using it to create the data for the blittered font.
 * @return {TentaGL.BlitteredFont}
 */
TentaGL.BlitteredFont.fromURL = function(url, monospaced, charW, charH, hPad, vPad, pixelsCB) {
  var bFont = new TentaGL.BlitteredFont(undefined, monospaced, charW, charH, hPad, vPad);
  
  TentaGL.PixelData.fromURL(url, function(pixels) {
    if(pixelsCB) {
      pixels = pixelsCB(pixels);
    }
    
    bFont._createChars(pixels, monospaced, charW, charH);
  });
  
  return bFont;
};



/** 
 * Produces a BlitteredFont from a Font with some Color.
 * @param {TentaGL.Font} font
 * @param {TentaGL.Color} color
 * @param {function(pixels: TentaGL.PixelData): TentaGL.PixelData} pixelsCB  
 *      Optional. A callback function that manipulates the pixel data from the 
 *      fontmap image before using it to create the data for the blittered font.
 * @return {TentaGL.BlitteredFont}
 */
TentaGL.BlitteredFont.fromFont = function(font, color, hPad, vPad, pixelsCB) {
  var monospaced = (font.getType() == "monospace");
  var dimsEm = font.getStringDimensions("W");
  var charW = dimsEm[0];
  var charH = dimsEm[1];
  
  var bFont = new TentaGL.BlitteredFont(undefined, monospaced, charW, charH, hPad, vPad);
  
  // Create a canvas for the fontmap.
  var bgColor;
  if(color.getRed() + color.getGreen() + color.getBlue() > 1.5) {
    bgColor = new TentaGL.Color.RGBA(0,0,0,1);
  }
  else {
    bgColor = new TentaGL.Color.RGBA(1,1,1,1);
  }
  
  var canvas = TentaGL.Canvas2D.create((charW + 2)*16, (charH + 2)*6, bgColor);
  
  for(var c = 32; c < 128; c++) {
    var i = (c-32)%16;
    var j = Math.floor((c-32)/16);
    
    var x = 1 + i*(charW + 2);
    var y = 1 + j*(charH + 2);
    
    var charID = String.fromCharCode(c);
    
    var charCanvas = TentaGL.Canvas2D.create(charW, charH, bgColor);
    TentaGL.Canvas2D.drawString(charCanvas, charID, font, color, 0, 0);
    
    TentaGL.Canvas2D.drawImage(canvas, charCanvas, x, y);
  }
  
  
  
  
  // Convert our fontmap canvas to PixelData. Make the bgColor transparent
  // and use the pixelsCB to apply any other filters provided by the user.
  var pixels = TentaGL.PixelData.fromCanvas(canvas);
  pixels = pixels.filter(new TentaGL.RGBAFilter.OneColor(color, 0.5));
  if(pixelsCB) {
    pixels = pixelsCB(pixels);
  }
  
  // Set the pixel data for the blittered font.
  bFont._createChars(pixels, monospaced, charW, charH);
  
  return bFont;
};





/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * An encapsulation for a CSS font. 
 * @constructor
 * @param {string} name   The name of the physical font to be used.
 * @param {string} fontType   The generic family of the font to be used, in 
 *      case the physical font is not available. This should be one of either 
 *      "serif", "sans-serif", or "monospace".
 * @param {int} sizePx    The pixel size of the font.
 */
TentaGL.Font = function(name, fontType, sizePx) { 
  this._name = name;
  this._type = fontType;
  this._size = sizePx;
  
  this._bold = false;
  this._italic = false;
  this._vPad = 1;
};


TentaGL.Font.prototype = {
  
  constructor:TentaGL.Font, 
  
  
  /** 
   * Returns the name of this font.
   * @return {string}
   */
  getName:function() {
    return this._name;
  },
  
  
  /** 
   * Returns the font's generic family.
   * @return {string}
   */
  getType:function() {
    return this._type;
  },
  
  
  /**  
   * Returns the pixel size of this font.
   * @return {string}
   */
  getSize:function() {
    return this._size;
  },
  
  
  /** 
   * Returns the amount of vertical padding between lines of text 
   * with this font, in pixels. 
   * @return {int}
   */
  getVerticalPadding:function() {
    return this._vPad;
  },
  
  /** 
   * Sets the amount of vertical padding between lines of text with this font, 
   * in pixels. 
   * @param {int} pad
   */
  setVerticalPadding:function(pad) {
    this._vPad = pad;
  },
  
  
  /** 
   * Returns whether this font is set to bold. 
   * @return {Boolean}
   */
  isBold:function() {
    return this._bold;
  },
  
  /** 
   * Sets whether this font is bold.
   * @param {Boolean} bold
   */
  setBold:function(bold) {
    this._bold = bold;
  },
  
  
  /** 
   * Returns whether this font is set to italic.
   * @return {Boolean}
   */
  isItalic:function() {
    return this._italic;
  },
  
  
  /** 
   * Sets whether this font is italic.
   * @param {Boolean} italic
   */
  setItalic:function(italic) {
    this._italic = italic;
  },
  
  
  /** 
   * Returns a CSS string representation of this font. 
   * @param {string}
   */
  toCSS:function() {
    var result = "";
    if(this._italic) {
      result += "italic ";
    }
    if(this._bold) {
      result += "bold ";
    }
    
    result += this._size + "px ";
    result += this._name + "," + this._type;
    return result;
  },
  
  
  /** 
   * Returns the appoximate pixel dimensions of a string of text displayed 
   * with this font in a canvas 2D context. 
   * @param {string} str
   * @return {[width: uint, height: uint]}
   */
  getStringDimensions:function(str) {
    var canvas = document.createElement("canvas");
    var g = canvas.getContext("2d");
    g.font = this.toCSS();
    
    var width = 0;
    var height = 0;
    
    var lines = str.split("\n");
    for(var i in lines) {
      var line = lines[i];
      height += this._size;
      
      var w = g.measureText(line).width;
      if(w > width) {
        width = w;
      }
      
      height += this._vPad;
    }
    height += this._size/4;
    
    return [width, height];
  }
  
};


/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Constructs an object representing a variable in a ShaderProgram.
 * The purpose of this is to serve as a super-type for Attribute and Uniform.
 * @constructor
 * @param {WebGLActiveInfo } info   Information about the variable returned 
 *      return from a getActiveAttrib or getActiveUniform call.
 * @param {WebGLProgram} glProg   The program containing the variable.
 */
TentaGL.ShaderVar = function(info, glProg) {
  this._name = info.name;  
  this._size = info.size;
  this._type = info.type;
  this._sizeBytes = info.size*TentaGL.glSizeBytes(info.type);
  this._sizeUnits = TentaGL.glSizeUnits(info.type);
  this._isArray = (this._size > 1);
  
  this._glProg = glProg;
};

TentaGL.ShaderVar.prototype = {
  
  constructor: TentaGL.ShaderVar,
  
  /** 
   * Returns the name of the variable. 
   * @return {string}
   */
  getName:function() {
    return this._name;
  },
  
  
  /** 
   * Returns the size of the variable. 
   * Variables other than arrays will have a size of 1.
   * For arrays, this will return the capacity of the array.
   * @return {GLint}
   */
  getSize:function() {
    return this._size;
  },
  
  
  /** 
   * Returns whether this variable is an array of values. 
   * @return {boolean}
   */
  isArray:function() {
    return this._isArray;
  },
  
  
  /** 
   * Returns the size of the variable in bytes.
   * @return {GLint}
   */
  getSizeBytes:function() {
    return this._sizeBytes;
  },
  
  
  /** 
   * Returns the size of the variable in units of its base type.
   * @return {GLint}
   */
  getSizeUnits:function() {
    return this._sizeUnits;
  },
  
  
  /** 
   * Returns the GL type of the variable. 
   * @return {GLenum}
   */
  getType:function() {
    return this._type;
  },
  
  /** Returns the unit type of the variable. */
  getUnitType:function() {
    return TentaGL.glUnitType(this._type);
  },
  
  
  /**
   * Returns the string representation of this variable's GL type.
   * @return {string}
   */
  getTypeName:function() {
    return TentaGL.glTypeName(this._type);
  },
  
  
  /** 
   * Returns true iff this is a built-in variable. Built-in variables are any
   * whose name starts with "gl_".
   */
  isBuiltIn:function() {
    return (this._substring(0,3).valueOf() == "gl_");
  }
  
  
};




/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Constructs an object representing a vertex attribute in a ShaderProgram.
 * @constructor
 * @param {WebGLActiveInfo } info   Information about the variable returned 
 *      return from a getActiveAttrib or getActiveUniform call.
 * @param {WebGLProgram} glProg   The program containing the variable.
 * @param {GLint} location   The location of the variable in 
 *      the WebGL context.
 */
TentaGL.Attribute = function(info, glProg, location) {
  TentaGL.ShaderVar.call(this, info, glProg);
  this._location = location;
};

TentaGL.Attribute.prototype = {
  
  constructor:TentaGL.Attribute,
  
  /** 
   * Returns the location of the Attribute in the WebGL context. 
   * @return {WebGLUniformLocation}
   */
  getLocation:function() {
    return this._location;
  },


  /** 
   * Sets the attribute to use the currently bound array buffer.
   * @param {WebGLRenderingContext} gl
   * @param {GLint} bufferStride    The byte offset between consecutive 
   *      attributes of this type in the bound buffer. If 0, then the attributes
   *      are understood to be sequential.
   * @param {GLint} bufferOffset    The offset of the first attribute of this 
   *      type in the bound buffer.
   */
  set:function(gl, bufferStride, bufferOffset) {
    gl.vertexAttribPointer(this._location, this.getSizeUnits(),  
                          this.getUnitType(), false, 
                          bufferStride, bufferOffset);
  },


  /** 
   * Assigns which Vertex prototype function for returns the typed data array   
   * for this Attribute. E.G.: If this is an attribute for the vertex's position,
   * the user should call thisAttribute.setGetter(TentaGL.Vertex.prototype.getXYZ).
   * For each Attribute in a ShaderProgram, this method should be used to 
   * specify the corresponding Vertex getter function for the Attribute after the
   * ShaderProgram is loaded, but before it is used to render anything.
   * @param {Function} getter  The Vertex prototype getter function that
   *      returns a typed array corresponding to this Attribute.
   */
  setGetter:function(getter) {
    this._getterFunc = getter;
  },


  /** 
   * Extracts this attribute's values from a Vertex. 
   * @param {TentaGL.Vertex} vertex
   * @return {Typed Array} A typed array of the appropriate size and type for 
   *      this attribute.
   */
  getValues:function(vertex) {
    var result = this._getterFunc.call(vertex);
    
    if(result.length != this.getSizeUnits()) {
      throw new Error("Vertex attribute " + this.getName() + " is wrong size: " + result.length + ". Expected: " + this.getSizeUnits());
    }
    
    return result;
  },



  /** 
   * Returns the profile data for this attribute. 
   * @return {TentaGL.AttrProfile}
   */
  getProfile:function() {
    if(!this._profile) {
      this._profile = new TentaGL.AttrProfile(TentaGL.UNKNOWN,
                                              this.getUnitType(),
                                              this.getSizeUnits(),
                                              this._getterFunc);
    }
    return this._profile;
  }



};


Util.Inheritance.inherit(TentaGL.Attribute, TentaGL.ShaderVar);




/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Constructs an object representing a uniform variable in a ShaderProgram.
 * @constructor
 * @param {WebGLActiveInfo } info   Information about the variable returned 
 *      return from a getActiveAttrib or getActiveUniform call.
 * @param {WebGLProgram} glProg   The program containing the variable.
 * @param {WebGLUniformLocation} location   The location of the variable in 
 *      the WebGL context.
 */
TentaGL.Uniform = function(info, glProg, location) {
  TentaGL.ShaderVar.call(this, info, glProg);
  this._location = location;
};

TentaGL.Uniform.prototype = {
  
  constructor:TentaGL.Uniform,
  
  /** 
   * Returns the location of the Uniform in the WebGL context. 
   * @return {WebGLUniformLocation}
   */
  getLocation:function() {
    return this._location;
  },


  /** 
   * Returns the current value of this Uniform in the GL context.
   * @return {any} see getUniform at http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.10
   */
  get:function(gl) {
    gl.getUniform(this._glProg, this._location);
  },


  /** 
   * Sets the value of this Uniform in the GL context.
   * @param {WebGLRenderingContext} gl
   * @param {typed array} valueArray    An array of the appropriate type  
   *      and length for the variable. This doesn't necessarily need to be a 
   *      typed array. See WebGL specification, section 5.1: Types.
   */
  set:function(gl, valueArray) {
    TentaGL.Uniform.setters[this._type].call(this, gl, valueArray);
  }
};


Util.Inheritance.inherit(TentaGL.Uniform, TentaGL.ShaderVar);



TentaGL.Uniform.setters = [];
TentaGL.Uniform.setters[GL_FLOAT] = function(gl, valueArray) { gl.uniform1fv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_FLOAT_VEC2] = function(gl, valueArray) { gl.uniform2fv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_FLOAT_VEC3] = function(gl, valueArray) { gl.uniform3fv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_FLOAT_VEC4] = function(gl, valueArray) { gl.uniform4fv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_INT] = function(gl, valueArray) { gl.uniform1iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_INT_VEC2] = function(gl, valueArray) { gl.uniform2iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_INT_VEC3] = function(gl, valueArray) { gl.uniform3iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_INT_VEC4] = function(gl, valueArray) { gl.uniform4iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_BOOL] = function(gl, valueArray) { gl.uniform1iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_BOOL_VEC2] = function(gl, valueArray) { gl.uniform2iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_BOOL_VEC3] = function(gl, valueArray) { gl.uniform3iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_BOOL_VEC4] = function(gl, valueArray) { gl.uniform4iv(this._location, valueArray); };
TentaGL.Uniform.setters[GL_FLOAT_MAT2] = function(gl, valueArray) { gl.uniformMatrix2fv(this._location, false, valueArray); };
TentaGL.Uniform.setters[GL_FLOAT_MAT3] = function(gl, valueArray) { gl.uniformMatrix3fv(this._location, false, valueArray); };
TentaGL.Uniform.setters[GL_FLOAT_MAT4] = function(gl, valueArray) { gl.uniformMatrix4fv(this._location, false, valueArray); };
TentaGL.Uniform.setters[GL_SAMPLER_2D] = function(gl, valueArray) { gl.uniform1iv(this._location, valueArray); };
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Defines a matchable profile for a vertex attribute variable.
 * @constructor
 * @param {ProfileEnum} id  The enumeration constant used to identify the attribute.
 *      If this is TentaGL.UNKNOWN, then it will try to determine its actual ID
 *      from TentaGL.AttrProfiles.
 * @param {GLenum} unitType   The unit type of the variable. 
 *      E.g. GL_INT, GL_FLOAT, etc., but not types such as GL_FLOAT_VEC3.
 * @param {int} sizeUnits   The size of the variable in terms of its unit type.
 *      E.g. GL_FLOAT_VEC3 would be 3 since it is the size of 3 GL_FLOATs.
 * @param {function} getterFunc   The Vertex prototype function that should be 
 *      called to get the relevant data for the attribute.
 */
TentaGL.AttrProfile = function(id, unitType, sizeUnits, getterFunc) {
  if(!getterFunc) {
    throw new Error("Could not create AttrProfile without getter.");
  }
  
  this._unitType = unitType;
  this._sizeUnits = sizeUnits;
  this._getterFunc = getterFunc;
  
  // If the ID is unknown, find a registered profile that is equal to this and
  // use its ID. This is how attributes from shader programs learn their IDs.
  if(id === TentaGL.UNKNOWN) {
    var found = false;
    
    for(var i in TentaGL.AttrProfiles) {
      if(this.equals(TentaGL.AttrProfiles[i])) {
        this._id = i;
        found = true;
        break;
      }
    }
    
    if(!found) {
      throw new Error("AttrProfile doesn't match any registered profiles: " + this.toString());
    }
  }
  else {
    this._id = id;
  }
};

TentaGL.AttrProfile.prototype = {
  constructor:TentaGL.AttrProfile, 
  
  /** 
   * Returns the ProfileEnum constant that serves as an ID for matching the
   * AttrProfile to its byte offset in VBO data.
   * @return {ProfileEnum}
   */
  id:function() {
    return this._id;
  },
  
  /**
   * Returns the unit GL primitive type for the attribute.
   * e.g. gl.INT, gl.FLOAT, etc., but not anything like gl.FLOAT_VEC3.
   * @return {GLenum}
   */
  unitType:function() {
    return this._unitType;
  },
  
  /** 
   * Returns the size of the attribute in terms of its attribute type.
   * e.g. For a gl.FLOAT_VEC3 attribute this would return 3.
   * @return {int}
   */
  sizeUnits:function() {
    return this._sizeUnits;
  },
  
  /** 
   * Returns the size of this attribute in bytes.
   * @return {int}
   */
  sizeBytes:function() {
    return this._sizeUnits*TentaGL.glSizeBytes(this._unitType);
  },
  
  /** 
   * Returns the Vertex prototype function used to get the relevant data for
   * this attribute.
   * @return {function}
   */
  getterFunc:function() {
    return this._getterFunc;
  },
  
  /**
   * Tests if this AttrProfile is equal to another one. Two
   * AttrProfiles are considered equal if they call the same getter function.
   * @return {Boolean}
   */
  equals:function(other) {
    return (this._getterFunc === other._getterFunc);
  },
  
  /** 
   * Calls the attribute's getter function on a vertex and returns the results.
   * @param {TentaGL.Vertex} vertex   The vertex we're getting attribute data for.
   * @return {typed array}
   */
  getValues:function(vertex) {
    var result = this._getterFunc.call(vertex);
  
    if(result.length != this.sizeUnits()) {
      throw new Error("Vertex attribute is wrong size: " + result.length + ". Expected: " + this.sizeUnits());
    }
    
    return result;
  },
  
  /** 
   * Produces a string respresentation of the AttrProfile.
   * @return {string}
   */
  toString:function() {
    return "AttrProfile(Unit type: " + TentaGL.glTypeName(this._unitType) + ", Units Size: " + this._sizeUnits + ", Getter Function: " + this._getterFunc + ")";
  }
};

// ProfileEnums

/** ID constant for unknown attributes. */
TentaGL.UNKNOWN = 0;

/** ID constant for homogeneous 3D XYZ coordinates. */
TentaGL.POS_4F = 1;

/** ID constant for surface normal vectors. */
TentaGL.NORMAL_3F = 2;

/** ID constant for 2D texture map coordinates. */
TentaGL.TEX_2F = 3;

/** ID constant for surface tangental vectors. */
TentaGL.TANG_3F = 4;

/** ID constant for animation bone index. */
TentaGL.BONE_I = 5;


// The master list of available AttrProfiles, keyed by their enumeration constants.
// The default set of AttrProfiles provides these. If you would like to 
// use different custom attributes, just create ProfileEnum constants for them
// (like those above) and add them into TentaGL.AttrProfiles, keyed by their
// constants. 
// That should be done before any models are loaded into the ModelLib!
TentaGL.AttrProfiles = {};
TentaGL.AttrProfiles[TentaGL.POS_4F] = new TentaGL.AttrProfile( TentaGL.POS_4F, 
                                                                GL_FLOAT, 
                                                                4, 
                                                                TentaGL.Vertex.prototype.getXYZ);
TentaGL.AttrProfiles[TentaGL.NORMAL_3F] = new TentaGL.AttrProfile(TentaGL.NORMAL_3F, 
                                                                  GL_FLOAT, 
                                                                  3, 
                                                                  TentaGL.Vertex.prototype.getNormal);
TentaGL.AttrProfiles[TentaGL.TEX_2F] = new TentaGL.AttrProfile( TentaGL.TEX_2F, 
                                                                GL_FLOAT, 
                                                                2, 
                                                                TentaGL.Vertex.prototype.getTexST);
TentaGL.AttrProfiles[TentaGL.TANG_3F] = new TentaGL.AttrProfile(TentaGL.TANG_3F, 
                                                                GL_FLOAT, 
                                                                3, 
                                                                TentaGL.Vertex.prototype.getTangental);


/** 
 * Returns the default set of Attribute profiles: 
 * POS_4F, NORMAL_3F, TEX_2F, and TANG_3F. 
 * @return {associative array: {ProfileEnum}->{AttrProfile}}
 */
TentaGL.getDefaultAttrProfileSet = function() {
  if(!TentaGL._defaultAttrProfileSet) {
    TentaGL._defaultAttrProfileSet = TentaGL.AttrProfiles.createSet([ TentaGL.POS_4F, 
                                                                      TentaGL.NORMAL_3F, 
                                                                      TentaGL.TEX_2F, 
                                                                      TentaGL.TANG_3F]);
  }
  return TentaGL._defaultAttrProfileSet;
};


/** 
 * Produces a set of AttrProfiles, given a list of the profile enum constants 
 * identifying them. 
 */
TentaGL.AttrProfiles.createSet = function(profileEnumArray) {
  var result = {};
  for(var i = 0; i < profileEnumArray.length; i++) {
    var profileEnum = profileEnumArray[i];
    result[profileEnum] = TentaGL.AttrProfiles[profileEnum];
  }
  return result;
};


/** Computes the total byte stride for a set of AttrProfiles. */
TentaGL.AttrProfiles.getStride = function(attrProfileSet) {
  var stride = 0;
  for(var i in attrProfileSet) {
    stride += attrProfileSet[i].sizeBytes();
  }
  return stride;
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * An API for managing the set of shader programs loaded in a gl context.
 */
TentaGL.ShaderLib = {
  
  
  /** 
   * Removes all loaded shader programs the shader library for a gl context. 
   * @param {WebGLRenderingContext} gl
   */
  clean:function(gl) {
    for(var i in gl._shaderLib) {
      gl._shaderLib[i].clean(gl);
    }
    gl._shaderLib = {};
  },
  
  
  /** 
   * Cleans the library and preloads the following built-in shader programs:  
   * "pickShader" - Program used by TentaGL.Picker which colors each sprite
   *                a unique solid color which can then be read back for
   *                mouse-overs.   
   */
  reset:function(gl) {
    this.clean(gl);
    //TentaGL.Picker.loadShaderProgram(gl);
    TentaGL.DefaultShader.load(gl, TentaGL.DefaultShader.SHADER_ID);
    TentaGL.PickShader.load(gl, TentaGL.Picker.SHADER_ID);
    
    gl._shaderLibLocked = false;
    
    this.use(gl, TentaGL.DefaultShader.SHADER_ID);
  },
  
  
  
  /** 
   * Returns the default root directory for loading premade ShaderPrograms.
   * By default, this is "./shaders/".
   * @param {WebGLRenderingContext} gl
   */
  getDefaultShaderPath: function(gl) {
    if(!gl._shaderDir) {
      gl._shaderDir = "./shaders/";
    }
    return gl._shaderDir;
  },
  
  
  /** 
   * Sets the default root directory for loading premade ShaderPrograms.
   * @param {WebGLRenderingContext} gl
   * @param {string} dirPath
   */
  setDefaultShaderPath: function(gl, dirPath) {
    gl._shaderDir = dirPath;
  },
  
  
  /** 
   * Adds a program to the shader library of a gl context. 
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   * @param {TentaGL.ShaderProgram} program
   * @return {TentaGL.ShaderProgram}  The ShaderProgram that was added.
   */
  add: function(gl, name, program) {
    gl._shaderLib[name] = program;
    return program;
  },
  
  
  /** 
   * Deletes the shader program with the specified name from a gl context.
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   */
  remove:function(gl, name) {
    var program = gl._shaderLib[name];
    program.clean(gl);
    
    // Remove the program from the library's associative arrays.
    delete gl._shaderLib[name];
  },
  
  /** 
   * Sets the WebGL context to use the specified shader program. 
   * @return {TentaGL.ShaderProgram} The shader program now being used.
   */
  use:function(gl, name) {
    if(gl._shaderLibLocked || gl._shaderLibCurrentName === name) {
      return;
    }
    
    var program = gl._shaderLib[name];
    program.useMe(gl);
    
    gl._shaderLibCurrentProgram = program;
    gl._shaderLibCurrentName = name;
    TentaGL.MaterialLib.useNone(gl);
    
    return program;
  },
  
  /** 
   * Returns the ShaderProgram currently being used by the WebGL context. 
   * @return {TentaGL.ShaderProgram}
   */
  current:function(gl) {
    return gl._shaderLibCurrentProgram;
  },
  
  
  /** Returns the ID of the ShaderProgram currently being used. */
  currentName: function(gl) {
    return gl._shaderLibCurrentName;
  },
  
  
  /** 
   * Locks the ShaderLib so that it can't change which shader program is being 
   * used by the GL context. 
   */
  lock:function(gl) {
    gl._shaderLibLocked = true;
  },
  
  /** 
   * Unlocks the ShaderLib so that it can once again be able to change
   * which shader program is being used by the GL context.
   */
  unlock:function(gl) {
    gl._shaderLibLocked = false;
  }
};



/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * Constructs a shader program and loads it into a WebGL context. 
 * If any compile errors occur while compiling the vertex or fragment shaders
 * or while linking the program, they are printed to the console 
 * and an Error is thrown.
 * @constructor
 * @param {WebGLRenderingContext} gl  The WebGL context.
 * @param {string} vertSrc  The source code string for the program's 
 *    vertex shader.
 * @param {string} fragSrc  The source code string for the program's
 *    fragment shader.
 */
TentaGL.ShaderProgram = function(gl, vertSrc, fragSrc) {
  var vert = this._compileShader(gl, GL_VERTEX_SHADER, vertSrc);
  var frag = this._compileShader(gl, GL_FRAGMENT_SHADER, fragSrc);
  
  this._glProg = this._linkProgram(gl, vert, frag);
  this._uniforms = this._initUniforms(gl);
  this._attributes = this._initAttributes(gl);
  
  this._showErrors = true;
};

TentaGL.ShaderProgram.prototype = {
  
  constructor: TentaGL.ShaderProgram,
  
  
  /** 
   * Compiles a source code for either a vertex shader or fragment shader. 
   * @private
   * @param {WebGLRenderingContext} gl
   * @param {int} glType  Either GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
   * @param {string} src  The source code for the shader.
   * @return {WebGLShader} The compiled shader.
   */
  _compileShader:function(gl, glType, src) {
    if(glType != GL_VERTEX_SHADER && glType != GL_FRAGMENT_SHADER) {
      var msg = "Invalid shader type constant: " + glType;
      throw new Error(msg);
    }
    else {
      
      // Create a shader of the appropriate type.
      var shader = gl.createShader(glType);
      
      // Compile the shader source code.
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      
      // Alert the user of any compile errors for the shader.
      if(!gl.getShaderParameter(shader, GL_COMPILE_STATUS)) {
        var msg = gl.getShaderInfoLog(shader);
        var typeStr = "";
        if(glType == GL_VERTEX_SHADER) {
          typeStr = "vertex";
        }
        else if(glType == GL_FRAGMENT_SHADER) {
          typeStr = "fragment";
        }
        throw new Error("Failed to compile " + typeStr + " shader :\n" + msg);
      }
      
      return shader;
    }
  },
  
  
  /** 
   * Links the compiled vertex and fragment shaders into a shader program.
   * @private
   * @param {WebGLRenderingContext} gl
   * @param {WebGLShader} vert  The compiled vertex shader.
   * @param {WebGLShader} frag  The compiled fragment shader.
   * @return {WebGLProgram} The linked shader program.
   */
  _linkProgram:function(gl, vert, frag) {
    var program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);
    
    if(!gl.getProgramParameter(program, GL_LINK_STATUS)) {
      var msg = gl.getProgramInfoLog(program);
      
      var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
      console.log("max varyings: " + maxVaryings);
      
      throw new Error("Failed to link shader program:\n" + msg);
    }
    
    return program;
  },
  
  
  /** 
   * Returns the location for this ProgramShader in GL memory.
   * @return {WebGLProgram}
   */
  getLocation:function() {
    return this._glProg;
  },
  
  
  /** Deletes this ProgramShader from the WebGL context. */
  clean:function(gl) {
    gl.deleteProgram(this._glProg);
  },
  
  
  /** Sets the WebGL context to use this ShaderProgram. */
  useMe:function(gl) {
    // Disable the variables of the program previously being used. 
    var previous = TentaGL.ShaderLib.current(gl);
    if(previous !== undefined) {
      previous._disableAllAttrs(gl);
    }
    
    gl.useProgram(this._glProg);
    
    // Enable the vertex attributes defined for this ShaderProgram.
    this._enableAllAttrs(gl);
  },
  
  
  /** 
   * Returns the location of a vertex attribute variable in the WebGL context. 
   * @return {GLint}
   */
  getAttribLocation:function(gl, name) {
    return gl.getAttribLocation(this._glProg, name);
  },
  
  
  /** 
   * Returns the location of a uniform variable in the WebGL context. 
   * @return {WebGLUniformLocation}
   */
  getUniformLocation:function(gl, name) {
    return gl.getUniformLocation(this._glProg, name);
  },
  
  
  /**
   * Initializes and returns the uniform variables for the program, mapped by
   * name.
   * @private
   * @param {WebGLRenderingContext} gl
   */
  _initUniforms:function(gl) {
    var uniMap = {};
    var numVars = gl.getProgramParameter(this._glProg, GL_ACTIVE_UNIFORMS);
    console.log("# Active Uniforms: " + numVars);
    
    for(var i = 0; i < numVars; i++) {
      var info = gl.getActiveUniform(this._glProg, i);
      var name = info.name;
      var location = gl.getUniformLocation(this._glProg, name);
      var uni = new TentaGL.Uniform(info, this._glProg, location);
      
      console.log("Uniform " + i + ": " + name + ", type " + TentaGL.glTypeName(info.type) + ", size " + info.size + ", byteSize " + uni.getSizeBytes() + ", unitSize " + uni.getSizeUnits());
      
      uniMap[name] = uni;
    }
    
    return uniMap;
  },
  
  
  /**
   * Initializes and returns the vertex attribute variables for the program,
   *  mapped by name.
   * @private
   * @param {WebGLRenderingContext} gl
   */
  _initAttributes:function(gl) {
    var attrMap = {};
    var numVars = gl.getProgramParameter(this._glProg, GL_ACTIVE_ATTRIBUTES);
    console.log("# Active Attributes: " + numVars);
    
    for(var i = 0; i < numVars; i++) {
      var info = gl.getActiveAttrib(this._glProg, i);
      var name = info.name;
      var location = gl.getAttribLocation(this._glProg, name);
      var attr = new TentaGL.Attribute(info, this._glProg, location);
      
      console.log("Attribute " + i + ": " + info.name + ", type " + TentaGL.glTypeName(info.type) + ", size " + info.size + ", byteSize " + attr.getSizeBytes() + ", unitSize " + attr.getSizeUnits());
      
      attrMap[name] = attr;
    }
    
    return attrMap;
  },
  
  
  /** 
   * Returns true if this program has a uniform variable with the given name. 
   * @param {string} name
   * @return {Boolean}
   */
  hasUniform:function(name) {
    if(this._uniforms[name]) {
      return true;
    }
    else {
      return false;
    }
  },
  
  
  /** 
   * Returns a Uniform variable for the program, given its name.
   * @param {string} name
   * @return {TentaGL.Uniform}
   */
  getUniform:function(name) {
    if(!this._uniforms[name] && this._showErrors) {
      console.log("Uniform variable " + name + " doesn't exist.");
    //  throw new Error();
    }
    return this._uniforms[name];
  },
  
  /**
   * Returns an Attribute variable for the program, given its name.
   * @param {string} name
   * @return {TentaGL.Attribute}
   */
  getAttribute:function(name) {
    return this._attributes[name];
  },
  
  
  /** 
   * Returns a list of this program's uniform variables. 
   * @return {Array: TentaGL.Uniform}
   */
  getUniforms:function() {
    var result = [];
    for(var i in this._uniforms) {
      result.push(this._uniforms[i]);
    }
    return result;
  },
  
  /** 
   * Returns a list of this program's attribute variables.
   * @return {Array: TentaGL.Attribute}
   */
  getAttributes:function() {
    var result = [];
    for(var i in this._attributes) {
      result.push(this._attributes[i]);
    }
    return result;
  },
  
  
  /** 
   * Returns a list of this program's uniform variable names.
   * @return {Array: string}
   */
  getUniNames:function() {
    var result = [];
    for(var i in this._uniforms) {
      result.push(i);
    }
    return result;
  },
  
  /** 
   * Returns a list of this program's attribute variable names.
   * @return {Array: string}
   */
  getAttrNames:function() {
    var result = [];
    for(var i in this._attributes) {
      result.push(i);
    }
    return result;
  },
  
  /** 
   * Returns the value of a Uniform variable.
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   * @return {any} see getUniform at http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.10
   */
  getUniValue:function(gl, name) {
    var uniform = this._uniforms[name];
    return uniform.get(gl);
  },
  
  /** 
   * Sets the value of a Uniform variable.
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   * @param {typed array} valueArray   A typed array of the appropriate type and 
   *      length for the variable.
   */
  setUniValue:function(gl, name, valueArray) {
    var uniform = this.getUniform(name);
    if(uniform) {
      uniform.set(gl, valueArray);
    }
  },
  
  
  /** 
   * Sets a vertex Attribute to read from the currently bound array buffer with
   * the specified stride and offset.
   * @param {WebGLRenderingContext} gl
   * @param {string} name
   * @param {GLint} bufferStride    The byte offset between consecutive 
   *      attributes of this type in the bound buffer. If 0, then the attributes
   *      are understood to be sequential.
   * @param {GLint} bufferOffset    The offset of the first attribute of this 
   *      type in the bound buffer.
   */
  bindAttr:function(gl, name, bufferStride, bufferOffset) {
    var attribute = this._attributes[name];
    attribute.set(gl, bufferStride, bufferOffset);
  },
  
  
  /** 
   * Sets which method in TentaGL.Vertex's prototype is used to get the data
   * for the specified attribute.
   * @param {string} name   The attribute's name.
   * @param {Function} getterFunc   Vertex's getter function returning the 
   *      typed array corresponding to the attribute.
   */
  setAttrGetter:function(name, getterFunc) {
    this._attributes[name].setGetter(getterFunc);
  },
  
  
  /** 
   * Returns the total byte stride needed for a tightly packed buffer to  
   * contain the data for all this program's attribute data.
   * @return {int}
   */
  getAttrStride:function() {
    if(this._totalStride === undefined) {
      this._totalStride = 0;
      for(var attrName in this._attributes) {
        var attr = this._attributes[attrName];
        this._totalStride += attr.getSizeBytes();
      }
    }
    return this._totalStride;
  },
  
  
  
  /** 
   * Enables all vertex attributes for this program.
   * @param {WebGLRenderingContext} gl
   */
  _enableAllAttrs:function(gl) {
    for(var name in this._attributes) {
      var attr = this._attributes[name];
      gl.enableVertexAttribArray(attr.getLocation());
    }
  },
  
  
  /** 
   * Disables all vertex attributes for this program.
   * @param {WebGLRenderingContext} gl
   */
  _disableAllAttrs:function(gl) {
    for(var name in this._attributes) {
      var attr = this._attributes[name];
      gl.disableVertexAttribArray(attr.getLocation());
    }
  }
  
  
};


/** 
 * Loads the vertex and fragment shader source code from their URLs. 
 * @param {WebGLRenderingContexT} gl
 * @param {string} vertURL   The URL of the vertex shader source code.
 * @param {string} fragURL   The URL of the fragment shader source code.
 * @return {array: [vertSrc : string, fragSrc : string]}
 */
TentaGL.ShaderProgram.srcFromURL = function(gl, vertURL, fragURL) {
  var req = new XMLHttpRequest();
  
  req.open("get", vertURL, false);
  req.send();
  var vertSrc = req.responseText;
  
  req.open("get", fragURL, false);
  req.send();
  var fragSrc = req.responseText;
  
  return [vertSrc, fragSrc];
};

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * The default shader, used when no other shader is used. It is a simple
 * pass-through shader that applies no transforms and colors all fragments 
 * white.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.DefaultShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "simple.vert";
  var fragURL = shaderRoot + "simple.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  console.log("\nCreating DefaultShader");
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
};

TentaGL.DefaultShader.SHADER_ID = "_default";

TentaGL.DefaultShader.prototype = {
  
  constructor: TentaGL.DefaultShader,
  
  isaDefaultShader: true
};


/** 
 * Loads DefaultShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.DefaultShader.load = function(gl, name) {
  var program = new TentaGL.DefaultShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.DefaultShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A pre-fabricated shader program that applies a model-view-projection 
 * transform to vertices in the scene and colors texels using a texture.
 * Lighting/Shading is not provided in this program.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.LinearGradientShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "gradientLinear.vert";
  var fragURL = shaderRoot + "gradientLinear.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  console.log("\nCreating linear gradient shader");
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.getNormal);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._normalUni = this.getUniform("normalTrans");
  
  this._startPtUni = this.getUniform("p");
  this._gradVectorUni = this.getUniform("u");
  this._colorsUni = this.getUniform("colors[0]");
  this._breakPtsUni = this.getUniform("breakPts[0]");
  this._breakPtCountUni = this.getUniform("breakPtCount");
};

TentaGL.LinearGradientShader.prototype = {
  
  constructor: TentaGL.LinearGradientShader,
  
  isaLinearGradientShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} value
   */
  setMVPTrans: function(gl, value) {
    this._mvpUni.set(gl, value);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the normal transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat3} value
   */
  setNormalTrans: function(gl, value) {
    this._normalUni.set(gl, value);
  },
  
  
  /** 
   * Sets the start point of the gradient from which the gradient vector 
   * is projected.
   * @param {vec2} pt     The point, in normalized texture coordinates.
   */
  setStartPoint: function(gl, pt) {
    this._startPtUni.set(gl, pt);
    
   // console.log(pt);
  },
  
  
  /** 
   * Sets the vector indicating the direction and length of the gradient. 
   * @param {vec2} v    The vector, in normalized texture coordinates.
   */
  setGradVector: function(gl, v) {
    this._gradVectorUni.set(gl, v);
    
  //  console.log(v);
  },
  
  
  /** 
   * Sets the uniform variable for the array of gradient colors corresponding 
   * to each break point. 
   * The shader supports colors for up to 16 break points.
   * @param {WebGLRenderingContext} gl
   * @param {array: TentaGL.Color} colors
   */
  setColors: function(gl, colors) {
    var arr = [];
    
    for(var i=0; i<colors.length; i++) {
      arr.push(colors[i].getRed());
      arr.push(colors[i].getGreen());
      arr.push(colors[i].getBlue());
      arr.push(colors[i].getAlpha());
    }
    
    this._colorsUni.set(gl, arr);
    
    // console.log(arr);
  },
  
  
  /** 
   * Sets the parametric values for the break points along the gradient vector. 
   * The shader supports up to 16 break points.
   * Each of these values should be in the range [0, 1].
   * @param {WebGLRenderingContext} gl
   * @param {array: float} pts
   */
  setBreakPoints: function(gl, pts) {
    this._breakPtsUni.set(gl, pts);
    this._breakPtCountUni.set(gl, [pts.length]);
    
  //  console.log(pts, pts.length);
  }
};


/** 
 * Loads LinearGradientShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.LinearGradientShader.load = function(gl, name) {
  var program = new TentaGL.LinearGradientShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.LinearGradientShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A pre-fabricated shader program that applies a model-view-projection 
 * transform to vertices in the scene and colors texels using the
 * interpolated normal vector of their surface.
 * Normal vector components in the range [-1, 1] will be converted into a 
 * corresponding normalized color component in the range [0,1].
 * The color's alpha component will be derived from the texture passed to the
 * shader.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.NormalShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "normal.vert";
  var fragURL = shaderRoot + "normal.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.getNormal);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._normalUni = this.getUniform("normalTrans");
  
  this._texUni = this.getUniform("tex");
  this._useTexUni = this.getUniform("useTex");
};

TentaGL.NormalShader.prototype = {
  
  constructor: TentaGL.NormalShader,
  
  isaSimpleShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} value
   */
  setMVPTrans: function(gl, value) {
    this._mvpUni.set(gl, value);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the normal transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat3} value
   */
  setNormalTrans: function(gl, value) {
    this._normalUni.set(gl, value);
  },
  
  
  /** 
   * Sets the uniforms to not use the alpha values of a texture. 
   * All color alpha values will be assumed to be 1.
   */
  setColor: function(gl, rgba) {
    this._useTexUni.set(gl, [0]);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the primary texture offset. 
   * @param {WebGLRenderingContext} gl
   * @param {int}
   */
  setTex: function(gl, value) {
    this._texUni.set(gl, [value]);
    this._useTexUni.set(gl, [1]);
  }
};


/** 
 * Loads NormalShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.NormalShader.load = function(gl, name) {
  var program = new TentaGL.NormalShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.NormalShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A Phong shader that computes lighting per vertex. This is faster than per 
 * fragment Phong but lower quality. Per vertex Phong doesn't support bump 
 * mapping either.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.PerVertexPhongShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "phongPerVertex.vert";
  var fragURL = shaderRoot + "phongPerVertex.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  console.log("\nCreating PerVertexPhongShader");
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.getNormal);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  this.setAttrGetter("vertexTang", TentaGL.Vertex.prototype.getTangental);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._mvUni = this.getUniform("mvTrans");
  this._vUni = this.getUniform("vTrans");
  this._normalUni = this.getUniform("normalTrans");
  
  this._colorUni = this.getUniform("solidColor");
  this._texUni = this.getUniform("tex");
  this._useTexUni = this.getUniform("useTex");
  
  // Material struct
  this._materialUni = {};
  this._materialUni.diff = this.getUniform("m.diff");
  this._materialUni.spec = this.getUniform("m.spec");
  this._materialUni.amb = this.getUniform("m.amb");
  this._materialUni.emis = this.getUniform("m.emis");
  this._materialUni.shininess = this.getUniform("m.shininess");
  
  // Lights struct array
  this._lightsUni = []; 
  for(var i=0; i < TentaGL.PerVertexPhongShader.MAX_LIGHTS; i++) {
    var light = this._lightsUni[i] = {};
    var prefix = "lights[" + i + "]";
    
    light.type = this.getUniform(prefix + ".type");
    light.pos = this.getUniform(prefix + ".pos");
    light.dir = this.getUniform(prefix + ".dir");
    light.diff = this.getUniform(prefix + ".diff");
    light.spec = this.getUniform(prefix + ".spec");
    light.amb = this.getUniform(prefix + ".amb");
    light.attenA = this.getUniform(prefix + ".attenA");
    light.attenB = this.getUniform(prefix + ".attenB");
    light.attenC = this.getUniform(prefix + ".attenC");
    light.cutOffAngleCos = this.getUniform(prefix + ".cutOffAngleCos");
    light.spotExp = this.getUniform(prefix + ".spotExp");
  }
  
  this._numLightsUni = this.getUniform("numLights");
};

TentaGL.PerVertexPhongShader.MAX_LIGHTS = 16;
TentaGL.PerVertexPhongShader.LIGHT_AMB = 1;
TentaGL.PerVertexPhongShader.LIGHT_PT = 2;
TentaGL.PerVertexPhongShader.LIGHT_DIR = 3;
TentaGL.PerVertexPhongShader.LIGHT_SPOT = 4;

TentaGL.PerVertexPhongShader.prototype = {
  
  constructor: TentaGL.PerVertexPhongShader,
  
  isaPerVertexPhongShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} m
   */
  setMVPTrans: function(gl, m) {
    this._mvpUni.set(gl, m);
  },
  
  
  /** 
   * Sets the uniform for the model-view transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} m
   */
  setMVTrans: function(gl, m) {
    this._mvUni.set(gl, m);
  },
  
  
  /** 
   * Sets the uniform for the view transform matrix. This is used to 
   * get the light vectors in view-space in the shader.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} m
   */
  setVTrans: function(gl, m) {
    this._vUni.set(gl, m);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the normal model-view transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat3} value
   */
  setNormalTrans: function(gl, value) {
    this._normalUni.set(gl, value);
  },
  
  
  /** 
   * Sets the uniform variables for using a solid color instead of using a 
   * texture for color. Solid colors are compatible with bump maps! Just call 
   * setBump after setColor, since setColor unsets the useBumpTex uniform.
   * @param {WebGLRenderingContext} gl
   * @param {vec4} rgba
   */
  setColor: function(gl, rgba) {
    this._colorUni.set(gl, rgba);
    this._useTexUni.set(gl, [0]);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the primary texture offset 
   * and unsets the bump texture offset. If you want to use bump mapping, 
   * call setTex first, followed by setBump.
   * @param {WebGLRenderingContext} gl
   * @param {int} value
   */
  setTex: function(gl, value) {
    this._texUni.set(gl, [value]);
    this._useTexUni.set(gl, [1]);
  },
  
  /** 
   * Sets the material light properties struct.
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Material.LightProps} matProps
   */
  setMaterialProps: function(gl, matProps) {
    this._materialUni.diff.set(gl, matProps.getDiffuse().getRGBA());
    this._materialUni.spec.set(gl, matProps.getSpecular().getRGBA());
    this._materialUni.amb.set(gl, matProps.getAmbient().getRGBA());
    this._materialUni.emis.set(gl, matProps.getEmission().getRGBA());
    this._materialUni.shininess.set(gl, [matProps.getShininess()]);
  },
  
  
  /** 
   * Sets the lights uniform variable array. 
   */
  setLights: function(gl, lights) {
    var numLights = Math.min(lights.length, TentaGL.PerVertexPhongShader.MAX_LIGHTS); // See MAX_LIGHTS constant in shader.
    this._numLightsUni.set(gl, [lights.length]);
    
    for(var i=0; i < numLights; i++) {
      var light = lights[i];
      var lightUni = this._lightsUni[i];
      
      // type (int)
      if(light.isaAmbientLight) {
        lightUni.type.set(gl, [TentaGL.PerVertexPhongShader.LIGHT_AMB]);
      }
      if(light.isaPointLight) {
        lightUni.type.set(gl, [TentaGL.PerVertexPhongShader.LIGHT_PT]);
      }
      if(light.isaDirectionalLight) {
        lightUni.type.set(gl, [TentaGL.PerVertexPhongShader.LIGHT_DIR]);
      }
      if(light.isaSpotLight) {
        lightUni.type.set(gl, [TentaGL.PerVertexPhongShader.LIGHT_SPOT]);
      }
      
      // pos (vec4)
      if(light.isaPointLight) {
        lightUni.pos.set(gl, light.getXYZ());
      }
      else {
        lightUni.pos.set(gl, [0, 0, 0, 0]);
      }
      
      // dir (vec3)
      if(light.isaDirectionalLight) {
        lightUni.dir.set(gl, light.getDirection());
      }
      else {
        lightUni.dir.set(gl, [0,0,0]);
      }
      
      // diff, spec, amb (vec4 x3) 
      lightUni.diff.set(gl, light.getDiffuse().getRGBA());
      lightUni.spec.set(gl, light.getSpecular().getRGBA());
      lightUni.amb.set(gl, light.getAmbient().getRGBA());
      
      // attenA, attenB, atten C (float x3)
      if(light.isaPointLight) {
        var atten = light.getAttenuation();
        lightUni.attenA.set(gl, [atten[0]]);
        lightUni.attenB.set(gl, [atten[1]]);
        lightUni.attenC.set(gl, [atten[2]]);
      }
      else {
        lightUni.attenA.set(gl, [0]);
        lightUni.attenB.set(gl, [0]);
        lightUni.attenC.set(gl, [0]);
      }
      
      // cutOffAngleCos, spotExp (float x2)
      if(light.isaSpotLight) {
        lightUni.cutOffAngleCos.set(gl, [Math.cos(light.getCutOffAngle())]);
        lightUni.spotExp.set(gl, [light.getSpotExponent()]);
      }
      else {
        lightUni.cutOffAngleCos.set(gl, [0]);
        lightUni.spotExp.set(gl, [0]);
      }
    }
    
    // 0-out unused lights.
    for(var i=numLights; i< TentaGL.PerVertexPhongShader.MAX_LIGHTS; i++) {
      var lightUni = this._lightsUni[i];
      
      lightUni.type.set(gl, [0]);
      lightUni.pos.set(gl, [0, 0, 0, 0]);
      lightUni.dir.set(gl, [0,0,0]);
      
      lightUni.diff.set(gl, [0, 0, 0, 0]);
      lightUni.spec.set(gl, [0, 0, 0, 0]);
      lightUni.amb.set(gl, [0, 0, 0, 0]);
      
      lightUni.attenA.set(gl, [0]);
      lightUni.attenB.set(gl, [0]);
      lightUni.attenC.set(gl, [0]);
      
      lightUni.cutOffAngleCos.set(gl, [0]);
      lightUni.spotExp.set(gl, [0]);
    }
  }
};


/** 
 * Loads PerVertexPhongShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.PerVertexPhongShader.load = function(gl, name) {
  var program = new TentaGL.PerVertexPhongShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.PerVertexPhongShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A phong lighting shader that also supports bump mapping.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.PhongShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "phong.vert";
  var fragURL = shaderRoot + "phong.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  console.log("\nCreating PhongShader");
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.getNormal);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  this.setAttrGetter("vertexTang", TentaGL.Vertex.prototype.getTangental);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._mvUni = this.getUniform("mvTrans");
  this._vUni = this.getUniform("vTrans");
  this._normalUni = this.getUniform("normalTrans");
  
  this._colorUni = this.getUniform("solidColor");
  this._texUni = this.getUniform("tex");
  this._useTexUni = this.getUniform("useTex");
  this._bumpTexUni = this.getUniform("bumpTex");
  this._useBumpUni = this.getUniform("useBumpTex");
  
  // Material struct
  this._materialUni = {};
  this._materialUni.diff = this.getUniform("m.diff");
  this._materialUni.spec = this.getUniform("m.spec");
  this._materialUni.amb = this.getUniform("m.amb");
  this._materialUni.emis = this.getUniform("m.emis");
  this._materialUni.shininess = this.getUniform("m.shininess");
  
  // Lights struct array
  this._lightsUni = []; 
  for(var i=0; i < TentaGL.PhongShader.MAX_LIGHTS; i++) {
    var light = this._lightsUni[i] = {};
    var prefix = "lights[" + i + "]";
    
    light.type = this.getUniform(prefix + ".type");
    light.pos = this.getUniform(prefix + ".pos");
    light.dir = this.getUniform(prefix + ".dir");
    light.diff = this.getUniform(prefix + ".diff");
    light.spec = this.getUniform(prefix + ".spec");
    light.amb = this.getUniform(prefix + ".amb");
    light.attenA = this.getUniform(prefix + ".attenA");
    light.attenB = this.getUniform(prefix + ".attenB");
    light.attenC = this.getUniform(prefix + ".attenC");
    light.cutOffAngleCos = this.getUniform(prefix + ".cutOffAngleCos");
    light.spotExp = this.getUniform(prefix + ".spotExp");
  }
  
  this._numLightsUni = this.getUniform("numLights");
};

TentaGL.PhongShader.MAX_LIGHTS = 16;
TentaGL.PhongShader.LIGHT_AMB = 1;
TentaGL.PhongShader.LIGHT_PT = 2;
TentaGL.PhongShader.LIGHT_DIR = 3;
TentaGL.PhongShader.LIGHT_SPOT = 4;

TentaGL.PhongShader.prototype = {
  
  constructor: TentaGL.PhongShader,
  
  isaPhongShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} m
   */
  setMVPTrans: function(gl, m) {
    this._mvpUni.set(gl, m);
  },
  
  
  /** 
   * Sets the uniform for the model-view transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} m
   */
  setMVTrans: function(gl, m) {
    this._mvUni.set(gl, m);
  },
  
  
  /** 
   * Sets the uniform for the view transform matrix. This is used to 
   * get the light vectors in view-space in the shader.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} m
   */
  setVTrans: function(gl, m) {
    this._vUni.set(gl, m);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the normal model-view transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat3} value
   */
  setNormalTrans: function(gl, value) {
    this._normalUni.set(gl, value);
  },
  
  
  /** 
   * Sets the uniform variables for using a solid color instead of using a 
   * texture for color. Solid colors are compatible with bump maps! Just call 
   * setBump after setColor, since setColor unsets the useBumpTex uniform.
   * @param {WebGLRenderingContext} gl
   * @param {vec4} rgba
   */
  setColor: function(gl, rgba) {
    this._colorUni.set(gl, rgba);
    this._useTexUni.set(gl, [0]);
    this._useBumpUni.set(gl, [0]);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the primary texture offset 
   * and unsets the bump texture offset. If you want to use bump mapping, 
   * call setTex first, followed by setBump.
   * @param {WebGLRenderingContext} gl
   * @param {int} value
   */
  setTex: function(gl, value) {
    this._texUni.set(gl, [value]);
    this._useTexUni.set(gl, [1]);
    this._useBumpUni.set(gl, [0]);
  },
  
  
  /** 
   * Sets the uniform variable for the bump texture offset. 
   * @param {WebGLRenderingContext} gl
   * @param {int} value   If >= 0, set as the offset and turn bump mapping on. 
   *      Else, turn bump mapping off.
   */
  setBump: function(gl, value) {
    this._bumpTexUni.set(gl, [value]);
    this._useBumpUni.set(gl, [1]);
  },
  
  /** 
   * Sets the material light properties struct.
   * @param {WebGLRenderingContext} gl
   * @param {TentaGL.Material.LightProps} matProps
   */
  setMaterialProps: function(gl, matProps) {
    this._materialUni.diff.set(gl, matProps.getDiffuse().getRGBA());
    this._materialUni.spec.set(gl, matProps.getSpecular().getRGBA());
    this._materialUni.amb.set(gl, matProps.getAmbient().getRGBA());
    this._materialUni.emis.set(gl, matProps.getEmission().getRGBA());
    this._materialUni.shininess.set(gl, [matProps.getShininess()]);
  },
  
  
  /** 
   * Sets the lights uniform variable array. 
   */
  setLights: function(gl, lights) {
    var numLights = Math.min(lights.length, TentaGL.PhongShader.MAX_LIGHTS); // See MAX_LIGHTS constant in shader.
    this._numLightsUni.set(gl, [lights.length]);
    
    for(var i=0; i < numLights; i++) {
      var light = lights[i];
      var lightUni = this._lightsUni[i];
      
      // type (int)
      if(light.isaAmbientLight) {
        lightUni.type.set(gl, [TentaGL.PhongShader.LIGHT_AMB]);
      }
      if(light.isaPointLight) {
        lightUni.type.set(gl, [TentaGL.PhongShader.LIGHT_PT]);
      }
      if(light.isaDirectionalLight) {
        lightUni.type.set(gl, [TentaGL.PhongShader.LIGHT_DIR]);
      }
      if(light.isaSpotLight) {
        lightUni.type.set(gl, [TentaGL.PhongShader.LIGHT_SPOT]);
      }
      
      // pos (vec4)
      if(light.isaPointLight) {
        lightUni.pos.set(gl, light.getXYZ());
      }
      else {
        lightUni.pos.set(gl, [0, 0, 0, 0]);
      }
      
      // dir (vec3)
      if(light.isaDirectionalLight) {
        lightUni.dir.set(gl, light.getDirection());
      }
      else {
        lightUni.dir.set(gl, [0,0,0]);
      }
      
      // diff, spec, amb (vec4 x3) 
      lightUni.diff.set(gl, light.getDiffuse().getRGBA());
      lightUni.spec.set(gl, light.getSpecular().getRGBA());
      lightUni.amb.set(gl, light.getAmbient().getRGBA());
      
      // attenA, attenB, atten C (float x3)
      if(light.isaPointLight) {
        var atten = light.getAttenuation();
        lightUni.attenA.set(gl, [atten[0]]);
        lightUni.attenB.set(gl, [atten[1]]);
        lightUni.attenC.set(gl, [atten[2]]);
      }
      else {
        lightUni.attenA.set(gl, [0]);
        lightUni.attenB.set(gl, [0]);
        lightUni.attenC.set(gl, [0]);
      }
      
      // cutOffAngleCos, spotExp (float x2)
      if(light.isaSpotLight) {
        lightUni.cutOffAngleCos.set(gl, [Math.cos(light.getCutOffAngle())]);
        lightUni.spotExp.set(gl, [light.getSpotExponent()]);
      }
      else {
        lightUni.cutOffAngleCos.set(gl, [0]);
        lightUni.spotExp.set(gl, [0]);
      }
    }
    
    // 0-out unused lights.
    for(var i=numLights; i< TentaGL.PhongShader.MAX_LIGHTS; i++) {
      var lightUni = this._lightsUni[i];
      
      lightUni.type.set(gl, [0]);
      lightUni.pos.set(gl, [0, 0, 0, 0]);
      lightUni.dir.set(gl, [0,0,0]);
      
      lightUni.diff.set(gl, [0, 0, 0, 0]);
      lightUni.spec.set(gl, [0, 0, 0, 0]);
      lightUni.amb.set(gl, [0, 0, 0, 0]);
      
      lightUni.attenA.set(gl, [0]);
      lightUni.attenB.set(gl, [0]);
      lightUni.attenC.set(gl, [0]);
      
      lightUni.cutOffAngleCos.set(gl, [0]);
      lightUni.spotExp.set(gl, [0]);
    }
  }
};


/** 
 * Loads PhongShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.PhongShader.load = function(gl, name) {
  var program = new TentaGL.PhongShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.PhongShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A pre-fabricated shader program used by TentaGL's picker.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.PickShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "picker.vert";
  var fragURL = shaderRoot + "picker.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._texUni = this.getUniform("tex");
  this._pickIDUni = this.getUniform("pickID");
};

TentaGL.PickShader.prototype = {
  
  constructor: TentaGL.PickShader, 
  
  isaPickShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} value
   */
  setMVPTrans: function(gl, value) {
    this._mvpUni.set(gl, value);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the primary texture offset. 
   * @param {WebGLRenderingContext} gl
   * @param {int} value
   */
  setTex: function(gl, value) {
    this._texUni.set(gl, [value]);
  },
  
  
  /** 
   * Sets the value of the uniform variable for an object's pickID. 
   * @param {WebGLRenderingContext} gl
   * @param {vec4} value
   */
  setPickID: function(gl, value) {
    this._pickIDUni.set(gl, value); 
  }
};

/** 
 * Loads PickShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.PickShader.load = function(gl, name) {
  var program = new TentaGL.PickShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.PickShader, TentaGL.ShaderProgram);
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A pre-fabricated shader program that applies a model-view-projection 
 * transform to vertices in the scene and colors texels using a texture.
 * Lighting/Shading is not provided in this program.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.RadialGradientShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "gradientRadial.vert";
  var fragURL = shaderRoot + "gradientRadial.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  console.log("\nCreating linear gradient shader");
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.getNormal);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._normalUni = this.getUniform("normalTrans");
  
  this._startPtUni = this.getUniform("p");
  this._gradVectorUni = this.getUniform("u");
  this._colorsUni = this.getUniform("colors[0]");
  this._breakPtsUni = this.getUniform("breakPts[0]");
  this._breakPtCountUni = this.getUniform("breakPtCount");
};

TentaGL.RadialGradientShader.prototype = {
  
  constructor: TentaGL.RadialGradientShader,
  
  isaRadialGradientShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} value
   */
  setMVPTrans: function(gl, value) {
    this._mvpUni.set(gl, value);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the normal transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat3} value
   */
  setNormalTrans: function(gl, value) {
    this._normalUni.set(gl, value);
  },
  
  
  /** 
   * Sets the start point of the gradient from which the gradient vector 
   * is projected.
   * @param {vec2} pt     The point, in normalized texture coordinates.
   */
  setStartPoint: function(gl, pt) {
    this._startPtUni.set(gl, pt);
    
   // console.log(pt);
  },
  
  
  /** 
   * Sets the vector indicating the direction and length of the gradient. 
   * @param {vec2} v    The vector, in normalized texture coordinates.
   */
  setGradVector: function(gl, v) {
    this._gradVectorUni.set(gl, v);
    
  //  console.log(v);
  },
  
  
  /** 
   * Sets the uniform variable for the array of gradient colors corresponding 
   * to each break point. 
   * The shader supports colors for up to 16 break points.
   * @param {WebGLRenderingContext} gl
   * @param {array: TentaGL.Color} colors
   */
  setColors: function(gl, colors) {
    var arr = [];
    
    for(var i=0; i<colors.length; i++) {
      arr.push(colors[i].getRed());
      arr.push(colors[i].getGreen());
      arr.push(colors[i].getBlue());
      arr.push(colors[i].getAlpha());
    }
    
    this._colorsUni.set(gl, arr);
    
    // console.log(arr);
  },
  
  
  /** 
   * Sets the parametric values for the break points along the gradient vector. 
   * The shader supports up to 16 break points.
   * Each of these values should be in the range [0, 1].
   * @param {WebGLRenderingContext} gl
   * @param {array: float} pts
   */
  setBreakPoints: function(gl, pts) {
    this._breakPtsUni.set(gl, pts);
    this._breakPtCountUni.set(gl, [pts.length]);
    
  //  console.log(pts, pts.length);
  }
};


/** 
 * Loads RadialGradientShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.RadialGradientShader.load = function(gl, name) {
  var program = new TentaGL.RadialGradientShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.RadialGradientShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A pre-fabricated shader program that applies a model-view-projection 
 * transform to vertices in the scene and colors texels using a texture.
 * Lighting/Shading is not provided in this program.
 * @param {WebGLRenderingContext} gl
 */
TentaGL.SimpleShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "simple.vert";
  var fragURL = shaderRoot + "simple.frag";
  var src = TentaGL.ShaderProgram.srcFromURL(gl, vertURL, fragURL);
  
  console.log("\nCreating SimpleShader");
  TentaGL.ShaderProgram.call(this, gl, src[0], src[1]);
  
  this.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.getXYZ);
  this.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.getNormal);
  this.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.getTexST);
  
  this._mvpUni = this.getUniform("mvpTrans");
  this._normalUni = this.getUniform("normalTrans");
  
  this._colorUni = this.getUniform("solidColor");
  this._texUni = this.getUniform("tex");
  this._useTexUni = this.getUniform("useTex");
};

TentaGL.SimpleShader.prototype = {
  
  constructor: TentaGL.SimpleShader,
  
  isaSimpleShader: true,
  
  
  /** 
   * Sets the value of the uniform variable for the model-view-projection 
   * transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat4} value
   */
  setMVPTrans: function(gl, value) {
    this._mvpUni.set(gl, value);
  },
  
  
  /** 
   * Sets the value of the uniform variable for the normal transform matrix.
   * @param {WebGLRenderingContext} gl
   * @param {mat3} value
   */
  setNormalTrans: function(gl, value) {
    this._normalUni.set(gl, value);
  },
  
  
  /** 
   * Sets the uniform variables for using a solid color instead of using a 
   * texture for color. Solid colors are compatible with bump maps! Just call 
   * setBump after setColor, since setColor unsets the useBumpTex uniform.
   * @param {WebGLRenderingContext} gl
   * @param {vec4} rgba
   */
  setColor: function(gl, rgba) {
    this._colorUni.set(gl, rgba);
    this._useTexUni.set(gl, [0]);
  },
  
  /** 
   * Sets the value of the uniform variable for the primary texture offset. 
   * @param {WebGLRenderingContext} gl
   * @param {int} value
   */
  setTex: function(gl, value) {
    this._texUni.set(gl, [value]);
    this._useTexUni.set(gl, [1]);
  }
};


/** 
 * Loads SimpleShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
TentaGL.SimpleShader.load = function(gl, name) {
  var program = new TentaGL.SimpleShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(TentaGL.SimpleShader, TentaGL.ShaderProgram);

/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

/** 
 * A collection of enumerations for alignment.
 * @enum {Number}
 */
TentaGL.Align = {
  
  CENTER:1,
  
  LEFT:2,
  RIGHT:3,
  
  TOP:4,
  BOTTOM:5, 
  
  FRONT:6,
  BACK:7
};
/* 
 @preserve Copyright (c) 2014 Stephen "Cazra" Lindberg

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 The Software shall be used for Good, not Evil.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/


/** 
 * Provides a small framework for creating offscreen Canvas elements and 
 * drawing to them. 
 * Please remember that when drawing on a canvas, the positive Y axis is down
 * and the origin is at the upper-left corner of the canvas.
 */
TentaGL.Canvas2D = {
  
  /** 
   * Creates and returns a Canvas element of the specified width and height. 
   * @param {int} width
   * @param {int} height
   * @param {TentaGL.Color} color   Optional. A background color for the canvas.
   * @return {Canvas}
   */
  create:function(width, height, color) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    
    if(color) {
      this.drawRect(canvas, 0, 0, width, height, false, 0, color);
    }
    
    return canvas;
  },
  
  
  /** 
   * Sets the alpha component of all pixels that aren't 255 to 0.
   * If your application doesn't enable blending, you may want to use this on
   * any textures produced from canvas renderings. Otherwise you'll end up
   * with a messy white-ish outline.
   * @param {Canvas} canvas
   * @return {Canvas}
   */
  removeAlpha:function(canvas) {
    var g = canvas.getContext("2d");
    var pixels = g.getImageData(0, 0, canvas.width, canvas.height);
    var data = pixels.data;
    
    for(var i=0; i<data.length; i+=4) {
      if(data[i+3] < 255) {
        data[i+3] = 0;
      }
    }
    
    g.putImageData(pixels, 0, 0);
    
    return canvas;
  },
  
  
  
  /** 
   * Draws a string to a Canvas. This supports newline characters '\n'.
   * @param {Canvas} canvas
   * @param {string} str
   * @param {TentaGL.Font} font
   * @param {TentaGL.Color} 
   * @param {int} x   The position of the left edge of the rendered text.
   * @param {int} y   The position of the top edge of the rendered text.
   * @return {Canvas} canvas, for chaining.
   */
  drawString:function(canvas, str, font, color, x, y) {
    if(!x) {
      x = 0;
    }
    if(!y) {
      y = 0;
    }
    
    var g = canvas.getContext("2d");
    g.save();
    g.webkitImageSmoothingEnabled = false;
    g.font = font.toCSS();
    g.lineWidth = 1;
    g.fillStyle = color.toCSS();
    
    var lines = str.split("\n");
    for(var i in lines) {
      var line = lines[i];
      
      g.translate(0, font.getSize());
      g.fillText(line, x, y);
      g.translate(0, font.getVerticalPadding());
    }
    
    g.restore();
    
    return canvas;
  },
  
  
  /** 
   * Creates a new canvas with a rendered string.
   * @param {string} str
   * @param {TentaGL.Font} font
   * @param {TentaGL.Color} color
   * @return {Canvas}
   */
  createString:function(str, font, color) {
    var dims = font.getStringDimensions(str);
    var canvas = this.create(dims[0], dims[1]);
    var g = canvas.getContext("2d");
    
    if(color.getRed() == 1 && color.getGreen() == 1 && color.getBlue() == 1) {
      g.fillStyle = "black";
      g.fillRect(0,0,dims[0], dims[1]);
    }
    else {
      g.fillStyle = "white";
      g.fillRect(0,0,dims[0], dims[1]);
    }
    
    this.drawString(canvas, str, font, color, 0, 0);
    return canvas;
  },
  
  
  /** 
   * Draws a circle onto a Canvas. 
   * @param {Canvas} canvas
   * @param {Number} cx   The center X coordinate of the circle.
   * @param {Number} cy   The center Y coordinate of the circle.
   * @param {Number} r    The radius of the circle, sans edge thickness.
   * @param {TentaGL.Color} stroke  The color for the edge of the circle.
   * @param {Number} edgeW    The thickness of the edge of the circle.
   * @param {TentaGL.Color} fill    The color for the interior of the circle.
   * @return {Canvas}
   */
  drawCircle:function(canvas, cx, cy, r, stroke, edgeW, fill) {
    var g = canvas.getContext("2d");
    g.save();
    
    g.beginPath();
    g.arc(cx, cy, r, 0, TentaGL.TAU);
    if(fill) {
      g.fillStyle = fill.toCSS();
      g.fill();
    }
    if(stroke) {
      g.strokeStyle = stroke.toCSS();
      g.lineWidth = edgeW;
      g.stroke();
    }
    
    g.restore();
    return canvas;
  },
  
  
  /** 
   * Creates a new canvas with a rendered circle. 
   * @param {Number} r  The radius of the circle, sans edge thickness.
   * @param {TentaGL.Color} stroke  The color for the edge of the circle.
   * @param {Number} edgeW    The thickness of the edge of the circle.
   * @param {TentaGL.Color} fill    The color for the interior of the circle.
   * @return {Canvas}
   */
  createCircle:function(r, stroke, edgeW, fill) {
    var sideLen = r*2 + edgeW;
    var canvas = this.create(sideLen, sideLen);
    this.drawCircle(canvas, r+edgeW/2, r+edgeW/2, r, stroke, edgeW, fill);
    return canvas;
  },
  
  
  /** 
   * Draws a rectangle onto a canvas. 
   * @param {Canvas} canvas
   * @param {Number} x    The x coordinate of the rectangle's left edge.
   * @param {Number} y    The y coordinate of the rectangle's top edge.
   * @param {Number} w    The rectangle's width, sans edge thickness.
   * @param {Number} h    The rectangle's height, sans edge thickness.
   * @param {TentaGL.Color} stroke  The color for the edge of the rectangle.
   * @param {Number} edgeW  The thickness of the edge of the rectangle.
   * @param {TentaGL.Color} fill    The color of the interior of the rectangle.
   * @return {Canvas}
   */
  drawRect:function(canvas, x, y, w, h, stroke, edgeW, fill) {
    var g = canvas.getContext("2d");
    g.save();
    
    if(fill) {
      g.fillStyle = fill.toCSS();
      g.fillRect(x, y, w, h);
    }
    if(stroke) {
      g.strokeStyle = stroke.toCSS();
      g.lineWidth = edgeW;
      g.strokeRect(x, y, w, h);
    }
    
    g.restore();
    return canvas;
  },
  
  /** 
   * Creates a new canvas with a rendered rectangle. 
   * @param {Number} w
   * @param {Number} h
   * @param {TentaGL.Color} stroke  The color for the edge of the rectangle.
   * @param {Number} edgeW  The thickness of the edge of the rectangle.
   * @param {TentaGL.Color} fill    The color of the interior of the rectangle.
   * @return {Canvas}
   */
  createRect:function(w, h, stroke, edgeW, fill) {
    var canvas = this.create(w + edgeW, h + edgeW);
    this.drawRect(canvas, edgeW/2, edgeW/2, w, h, stroke, edgeW, fill);
    return canvas;
  },
  
  
  /** 
   * Draws a rounded rectangle onto a canvas. 
   * @param {Canvas} canvas
   * @param {Number} x    The x coordinate of the rectangle's left edge.
   * @param {Number} y    The y coordinate of the rectangle's top edge.
   * @param {Number} w    The rectangle's width, sans edge thickness.
   * @param {Number} h    The rectangle's height, sans edge thickness.
   * @param {Number} r    The radius of the rounded corners.
   * @param {TentaGL.Color} stroke  The color for the edge of the rectangle.
   * @param {Number} edgeW  The thickness of the edge of the rectangle.
   * @param {TentaGL.Color} fill    The color of the interior of the rectangle.
   * @return {Canvas}
   */
  drawRoundedRect:function(canvas, x, y, w, h, r, stroke, edgeW, fill) {
    var g = canvas.getContext("2d");
    g.save();
    
    g.beginPath();
    g.moveTo(x+r, y);
    g.lineTo(x+w-r, y);
    g.arc(x+w-r, y+r, r, TentaGL.TAU*3/4, 0);
    g.lineTo(x+w, y+h-r);
    g.arc(x+w-r, y+h-r, r, 0, TentaGL.TAU*1/4);
    g.lineTo(x+r, y+h);
    g.arc(x+r, y+h-r, r, TentaGL.TAU*1/4, TentaGL.TAU*2/4);
    g.lineTo(x, y+r);
    g.arc(x+r, y+r, r, TentaGL.TAU*2/4, TentaGL.TAU*3/4);
    
    if(fill) {
      g.fillStyle = fill.toCSS();
      g.fill();
    }
    if(stroke) {
      g.strokeStyle = stroke.toCSS();
      g.lineWidth = edgeW;
      g.stroke();
    }
    
    g.restore();
    return canvas;
  },
  
  
  /** 
   * Creates a new canvas with a rendered rounded rectangle. 
   * @param {Number} w    The rectangle's width, sans edge thickness.
   * @param {Number} h    The rectangle's height, sans edge thickness.
   * @param {Number} r    The radius of the rounded corners.
   * @param {TentaGL.Color} stroke  The color for the edge of the rectangle.
   * @param {Number} edgeW  The thickness of the edge of the rectangle.
   * @param {TentaGL.Color} fill    The color of the interior of the rectangle.
   * @return {Canvas}
   */
  createRoundedRect:function(w, h, r, stroke, edgeW, fill) {
    var canvas = this.create(w + edgeW, h + edgeW);
    this.drawRoundedRect(canvas, edgeW/2, edgeW/2, w, h, r, stroke, edgeW, fill);
    return canvas;
  },
  
  
  
  /** 
   * Draws an image or canvas element onto a canvas. 
   * @param {Canvas} canvas
   * @param {Image | Canvas} 
   * @param {int} x   The x coordinate of the image's left edge.
   * @param {int} y   The y coordinate of the image's top edge.
   * @param {uint} w  Optional. The stretched width of the image.
   * @param {uint} h  Optional. The stretched height of the image.
   * @return {Canvas}
   */
  drawImage: function(canvas, img, x, y, w, h) {
    var g = canvas.getContext("2d");
    
    if(w && h) {
      g.drawImage(img, x, y, w, h);
    }
    else {
      g.drawImage(img, x, y);
    }
    return canvas;
  },
  
  
  /** 
   * Creates a new canvas with a rendered image.
   * The canvas is fitted to the size of the image.
   * @param {Image | Canvas} img
   * @param {int} w   Optional. The stretched width of the image.
   * @param {int} h   Optional. The stretched height of the image.
   * @return {Canvas}
   */
  createImage: function(img, w, h) {
    var canvasW, canvasH;
    if(w) {
      canvasW = w;
    }
    else {
      canvasW = img.width;
    }
    
    if(h) {
      canvasH = h;
    }
    else {
      canvasH = img.height;
    }
    
    var canvas = this.create(canvasW, canvasH);
    this.drawImage(canvas, img, 0, 0, w, h);
    return canvas;
  },
  
  
  /** 
   * Creates a canvas as a cropped copy of an existing canvas or image.
   * @param {Image | Canvas} src
   * @param {uint} x  The left edge of the cropping region.
   * @param {uint} y  The top edge of the cropping region.
   * @param {uint} w  The width of the cropping region.
   * @param {uint} h  The height of the cropping region.
   * @return {Canvas}
   */
  crop: function(src, x, y, w, h) {
    var canvas = this.create(w, h);
    var g = canvas.getContext("2d");
    
    g.drawImage(src, x, y, w, h, 0, 0);
    
    return canvas;
  }
  
};

